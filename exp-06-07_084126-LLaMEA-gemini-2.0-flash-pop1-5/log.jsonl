{"id": "cf791861-7c16-458e-8294-06a70adcccb9", "fitness": 0.023617791238401648, "name": "HybridDEArchiveAdaptive", "description": "A hybrid Differential Evolution with an Archive and adaptive mutation strategies based on fitness improvement.", "code": "import numpy as np\nimport random\n\nclass HybridDEArchiveAdaptive:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n\n        self.population_size = int(5 + np.ceil(np.log(self.dim))) # Population scaling with dimension\n        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, float('inf'))\n\n        self.archive_size = self.population_size * 2  # Archive is larger than the population\n        self.archive = np.zeros((self.archive_size, self.dim))\n        self.archive_fitness = np.full(self.archive_size, float('inf'))\n        self.archive_idx = 0\n\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7 # Initial crossover rate\n        self.mutation_factor_history = [self.mutation_factor]\n        self.crossover_rate_history = [self.crossover_rate]\n\n    def ensure_bounds(self, vec):\n        return np.clip(vec, self.lower_bounds, self.upper_bounds)\n\n    def update_archive(self, individual, fitness):\n        if fitness < np.max(self.archive_fitness):\n            worst_index = np.argmax(self.archive_fitness)\n            self.archive[worst_index] = individual\n            self.archive_fitness[worst_index] = fitness\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        if self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n        else:\n            self.best_solution_overall = np.array([])\n        self.best_fitness_overall = float('inf')\n\n        # Initialize population and fitness\n        fitness_values = objective_function(self.population)\n        self.eval_count += self.population_size\n        self.fitness = fitness_values.copy()\n\n        for i in range(self.population_size):\n            if self.fitness[i] < self.best_fitness_overall:\n                self.best_fitness_overall = self.fitness[i]\n                self.best_solution_overall = self.population[i].copy()\n\n        # Initialize Archive with initial population\n        self.archive[:self.population_size] = self.population.copy()\n        self.archive_fitness[:self.population_size] = self.fitness.copy()\n        self.archive_idx = self.population_size\n\n        while self.eval_count < self.budget and self.dim > 0:\n            for i in range(self.population_size):\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                if len(indices) >= 3: #Ensure we have at least 3 distinct indices from pop\n                    a, b, c = random.sample(indices, 3)\n                else:\n                    a, b, c = random.choices(indices, k = 3) #Allows replacement to proceed if len(indices) < 3\n\n                #Potentially use an archive member\n                if random.random() < 0.1: #10% chance of pulling a member from the archive\n                    arc_idx = random.randint(0, self.archive_size - 1)\n                    mutant = self.population[a] + self.mutation_factor * (self.archive[arc_idx] - self.population[b]) + self.mutation_factor * (self.population[c] - self.population[i])\n                else:\n                    mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c]) + self.mutation_factor * (self.best_solution_overall - self.population[i]) #Best solution guided mutation\n\n                mutant = self.ensure_bounds(mutant)\n                \n                # Crossover\n                trial_vector = np.zeros(self.dim)\n                for j in range(self.dim):\n                    if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):\n                        trial_vector[j] = mutant[j]\n                    else:\n                        trial_vector[j] = self.population[i][j]\n\n                trial_vector = self.ensure_bounds(trial_vector)\n\n                # Selection\n                trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector.copy()\n                    self.fitness[i] = trial_fitness\n\n                    # Update best solution\n                    if trial_fitness < self.best_fitness_overall:\n                        self.best_fitness_overall = trial_fitness\n                        self.best_solution_overall = trial_vector.copy()\n\n                    #Update Archive\n                    self.update_archive(trial_vector, trial_fitness)\n\n                    #Adaptive strategy: if improvement, increase mutation and crossover\n                    self.mutation_factor = min(1.0, self.mutation_factor * 1.1)\n                    self.crossover_rate = min(1.0, self.crossover_rate * 1.1)\n\n                else:\n                    #Decrease mutation and crossover if no improvement\n                    self.mutation_factor = max(0.1, self.mutation_factor * 0.9)\n                    self.crossover_rate = max(0.1, self.crossover_rate * 0.9)\n\n                self.mutation_factor_history.append(self.mutation_factor)\n                self.crossover_rate_history.append(self.crossover_rate)\n\n        if self.best_solution_overall is None and self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall,\n            'mutation_factor_history': self.mutation_factor_history,\n            'crossover_rate_history': self.crossover_rate_history\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info", "configspace": "", "generation": 0, "feedback": "The algorithm HybridDEArchiveAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.07085337371520495]}}
{"id": "2d15187f-5bca-4cae-8ae9-0b4fa4220ff7", "fitness": 0.024550104212539933, "name": "HybridDEArchiveAdaptive", "description": "Introduces a minimum archive fitness threshold to prevent archiving poor solutions.", "code": "import numpy as np\nimport random\n\nclass HybridDEArchiveAdaptive:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n\n        self.population_size = int(5 + np.ceil(np.log(self.dim))) # Population scaling with dimension\n        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, float('inf'))\n\n        self.archive_size = self.population_size * 2  # Archive is larger than the population\n        self.archive = np.zeros((self.archive_size, self.dim))\n        self.archive_fitness = np.full(self.archive_size, float('inf'))\n        self.archive_idx = 0\n\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7 # Initial crossover rate\n        self.mutation_factor_history = [self.mutation_factor]\n        self.crossover_rate_history = [self.crossover_rate]\n        self.min_archive_fitness = float('inf')  #ADDED: Minimum acceptable fitness for archive entry\n\n    def ensure_bounds(self, vec):\n        return np.clip(vec, self.lower_bounds, self.upper_bounds)\n\n    def update_archive(self, individual, fitness):\n        if fitness < np.max(self.archive_fitness) and fitness < self.min_archive_fitness:\n            worst_index = np.argmax(self.archive_fitness)\n            self.archive[worst_index] = individual\n            self.archive_fitness[worst_index] = fitness\n            self.min_archive_fitness = np.min(self.archive_fitness)\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        if self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n        else:\n            self.best_solution_overall = np.array([])\n        self.best_fitness_overall = float('inf')\n\n        # Initialize population and fitness\n        fitness_values = objective_function(self.population)\n        self.eval_count += self.population_size\n        self.fitness = fitness_values.copy()\n\n        for i in range(self.population_size):\n            if self.fitness[i] < self.best_fitness_overall:\n                self.best_fitness_overall = self.fitness[i]\n                self.best_solution_overall = self.population[i].copy()\n\n        # Initialize Archive with initial population\n        self.archive[:self.population_size] = self.population.copy()\n        self.archive_fitness[:self.population_size] = self.fitness.copy()\n        self.min_archive_fitness = np.max(self.archive_fitness) #initialize min_archive_fitness\n        self.archive_idx = self.population_size\n\n        while self.eval_count < self.budget and self.dim > 0:\n            for i in range(self.population_size):\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                if len(indices) >= 3: #Ensure we have at least 3 distinct indices from pop\n                    a, b, c = random.sample(indices, 3)\n                else:\n                    a, b, c = random.choices(indices, k = 3) #Allows replacement to proceed if len(indices) < 3\n\n                #Potentially use an archive member\n                if random.random() < 0.1: #10% chance of pulling a member from the archive\n                    arc_idx = random.randint(0, self.archive_size - 1)\n                    mutant = self.population[a] + self.mutation_factor * (self.archive[arc_idx] - self.population[b]) + self.mutation_factor * (self.population[c] - self.population[i])\n                else:\n                    mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c]) + self.mutation_factor * (self.best_solution_overall - self.population[i]) #Best solution guided mutation\n\n                mutant = self.ensure_bounds(mutant)\n                \n                # Crossover\n                trial_vector = np.zeros(self.dim)\n                for j in range(self.dim):\n                    if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):\n                        trial_vector[j] = mutant[j]\n                    else:\n                        trial_vector[j] = self.population[i][j]\n\n                trial_vector = self.ensure_bounds(trial_vector)\n\n                # Selection\n                trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector.copy()\n                    self.fitness[i] = trial_fitness\n\n                    # Update best solution\n                    if trial_fitness < self.best_fitness_overall:\n                        self.best_fitness_overall = trial_fitness\n                        self.best_solution_overall = trial_vector.copy()\n\n                    #Update Archive\n                    self.update_archive(trial_vector, trial_fitness)\n\n                    #Adaptive strategy: if improvement, increase mutation and crossover\n                    self.mutation_factor = min(1.0, self.mutation_factor * 1.1)\n                    self.crossover_rate = min(1.0, self.crossover_rate * 1.1)\n\n                else:\n                    #Decrease mutation and crossover if no improvement\n                    self.mutation_factor = max(0.1, self.mutation_factor * 0.9)\n                    self.crossover_rate = max(0.1, self.crossover_rate * 0.9)\n\n                self.mutation_factor_history.append(self.mutation_factor)\n                self.crossover_rate_history.append(self.crossover_rate)\n\n        if self.best_solution_overall is None and self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall,\n            'mutation_factor_history': self.mutation_factor_history,\n            'crossover_rate_history': self.crossover_rate_history\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info", "configspace": "", "generation": 1, "feedback": "The algorithm HybridDEArchiveAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["cf791861-7c16-458e-8294-06a70adcccb9"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.0736503126376198]}}
{"id": "5fa12097-cecc-4cdf-b0f2-65b6786d54d4", "fitness": 0.02416220103687132, "name": "HybridDEArchiveAdaptive", "description": "Adjusts archive update condition to prevent premature convergence by using a percentage-based threshold of the best fitness.", "code": "import numpy as np\nimport random\n\nclass HybridDEArchiveAdaptive:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n\n        self.population_size = int(5 + np.ceil(np.log(self.dim))) # Population scaling with dimension\n        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, float('inf'))\n\n        self.archive_size = self.population_size * 2  # Archive is larger than the population\n        self.archive = np.zeros((self.archive_size, self.dim))\n        self.archive_fitness = np.full(self.archive_size, float('inf'))\n        self.archive_idx = 0\n\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7 # Initial crossover rate\n        self.mutation_factor_history = [self.mutation_factor]\n        self.crossover_rate_history = [self.crossover_rate]\n        self.min_archive_fitness = float('inf')  #ADDED: Minimum acceptable fitness for archive entry\n\n    def ensure_bounds(self, vec):\n        return np.clip(vec, self.lower_bounds, self.upper_bounds)\n\n    def update_archive(self, individual, fitness):\n        if fitness < np.max(self.archive_fitness) and fitness < self.best_fitness_overall * 1.05:  # Changed line: Adding percentage-based threshold\n            worst_index = np.argmax(self.archive_fitness)\n            self.archive[worst_index] = individual\n            self.archive_fitness[worst_index] = fitness\n            self.min_archive_fitness = np.min(self.archive_fitness)\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        if self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n        else:\n            self.best_solution_overall = np.array([])\n        self.best_fitness_overall = float('inf')\n\n        # Initialize population and fitness\n        fitness_values = objective_function(self.population)\n        self.eval_count += self.population_size\n        self.fitness = fitness_values.copy()\n\n        for i in range(self.population_size):\n            if self.fitness[i] < self.best_fitness_overall:\n                self.best_fitness_overall = self.fitness[i]\n                self.best_solution_overall = self.population[i].copy()\n\n        # Initialize Archive with initial population\n        self.archive[:self.population_size] = self.population.copy()\n        self.archive_fitness[:self.population_size] = self.fitness.copy()\n        self.min_archive_fitness = np.max(self.archive_fitness) #initialize min_archive_fitness\n        self.archive_idx = self.population_size\n\n        while self.eval_count < self.budget and self.dim > 0:\n            for i in range(self.population_size):\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                if len(indices) >= 3: #Ensure we have at least 3 distinct indices from pop\n                    a, b, c = random.sample(indices, 3)\n                else:\n                    a, b, c = random.choices(indices, k = 3) #Allows replacement to proceed if len(indices) < 3\n\n                #Potentially use an archive member\n                if random.random() < 0.1: #10% chance of pulling a member from the archive\n                    arc_idx = random.randint(0, self.archive_size - 1)\n                    mutant = self.population[a] + self.mutation_factor * (self.archive[arc_idx] - self.population[b]) + self.mutation_factor * (self.population[c] - self.population[i])\n                else:\n                    mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c]) + self.mutation_factor * (self.best_solution_overall - self.population[i]) #Best solution guided mutation\n\n                mutant = self.ensure_bounds(mutant)\n                \n                # Crossover\n                trial_vector = np.zeros(self.dim)\n                for j in range(self.dim):\n                    if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):\n                        trial_vector[j] = mutant[j]\n                    else:\n                        trial_vector[j] = self.population[i][j]\n\n                trial_vector = self.ensure_bounds(trial_vector)\n\n                # Selection\n                trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector.copy()\n                    self.fitness[i] = trial_fitness\n\n                    # Update best solution\n                    if trial_fitness < self.best_fitness_overall:\n                        self.best_fitness_overall = trial_fitness\n                        self.best_solution_overall = trial_vector.copy()\n\n                    #Update Archive\n                    self.update_archive(trial_vector, trial_fitness)\n\n                    #Adaptive strategy: if improvement, increase mutation and crossover\n                    self.mutation_factor = min(1.0, self.mutation_factor * 1.1)\n                    self.crossover_rate = min(1.0, self.crossover_rate * 1.1)\n\n                else:\n                    #Decrease mutation and crossover if no improvement\n                    self.mutation_factor = max(0.1, self.mutation_factor * 0.9)\n                    self.crossover_rate = max(0.1, self.crossover_rate * 0.9)\n\n                self.mutation_factor_history.append(self.mutation_factor)\n                self.crossover_rate_history.append(self.crossover_rate)\n\n        if self.best_solution_overall is None and self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall,\n            'mutation_factor_history': self.mutation_factor_history,\n            'crossover_rate_history': self.crossover_rate_history\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info", "configspace": "", "generation": 2, "feedback": "The algorithm HybridDEArchiveAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["2d15187f-5bca-4cae-8ae9-0b4fa4220ff7"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.07248660311061396]}}
{"id": "99494c29-7a3c-4954-872d-d24457e890fb", "fitness": 0.024818886084527217, "name": "HybridDEArchiveAdaptive", "description": "Dynamically adjusts mutation factor based on population fitness variance.", "code": "import numpy as np\nimport random\n\nclass HybridDEArchiveAdaptive:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n\n        self.population_size = int(5 + np.ceil(np.log(self.dim))) # Population scaling with dimension\n        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, float('inf'))\n\n        self.archive_size = self.population_size * 2  # Archive is larger than the population\n        self.archive = np.zeros((self.archive_size, self.dim))\n        self.archive_fitness = np.full(self.archive_size, float('inf'))\n        self.archive_idx = 0\n\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7 # Initial crossover rate\n        self.mutation_factor_history = [self.mutation_factor]\n        self.crossover_rate_history = [self.crossover_rate]\n        self.min_archive_fitness = float('inf')  #ADDED: Minimum acceptable fitness for archive entry\n\n    def ensure_bounds(self, vec):\n        return np.clip(vec, self.lower_bounds, self.upper_bounds)\n\n    def update_archive(self, individual, fitness):\n        if fitness < np.max(self.archive_fitness) and fitness < self.min_archive_fitness:\n            worst_index = np.argmax(self.archive_fitness)\n            self.archive[worst_index] = individual\n            self.archive_fitness[worst_index] = fitness\n            self.min_archive_fitness = np.min(self.archive_fitness)\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        if self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n        else:\n            self.best_solution_overall = np.array([])\n        self.best_fitness_overall = float('inf')\n\n        # Initialize population and fitness\n        fitness_values = objective_function(self.population)\n        self.eval_count += self.population_size\n        self.fitness = fitness_values.copy()\n\n        for i in range(self.population_size):\n            if self.fitness[i] < self.best_fitness_overall:\n                self.best_fitness_overall = self.fitness[i]\n                self.best_solution_overall = self.population[i].copy()\n\n        # Initialize Archive with initial population\n        self.archive[:self.population_size] = self.population.copy()\n        self.archive_fitness[:self.population_size] = self.fitness.copy()\n        self.min_archive_fitness = np.max(self.archive_fitness) #initialize min_archive_fitness\n        self.archive_idx = self.population_size\n\n        while self.eval_count < self.budget and self.dim > 0:\n            for i in range(self.population_size):\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                if len(indices) >= 3: #Ensure we have at least 3 distinct indices from pop\n                    a, b, c = random.sample(indices, 3)\n                else:\n                    a, b, c = random.choices(indices, k = 3) #Allows replacement to proceed if len(indices) < 3\n\n                #Potentially use an archive member\n                if random.random() < 0.1: #10% chance of pulling a member from the archive\n                    arc_idx = random.randint(0, self.archive_size - 1)\n                    mutant = self.population[a] + self.mutation_factor * (self.archive[arc_idx] - self.population[b]) + self.mutation_factor * (self.population[c] - self.population[i])\n                else:\n                    mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c]) + self.mutation_factor * (self.best_solution_overall - self.population[i]) #Best solution guided mutation\n\n                mutant = self.ensure_bounds(mutant)\n                \n                # Crossover\n                trial_vector = np.zeros(self.dim)\n                for j in range(self.dim):\n                    if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):\n                        trial_vector[j] = mutant[j]\n                    else:\n                        trial_vector[j] = self.population[i][j]\n\n                trial_vector = self.ensure_bounds(trial_vector)\n\n                # Selection\n                trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector.copy()\n                    self.fitness[i] = trial_fitness\n\n                    # Update best solution\n                    if trial_fitness < self.best_fitness_overall:\n                        self.best_fitness_overall = trial_fitness\n                        self.best_solution_overall = trial_vector.copy()\n\n                    #Update Archive\n                    self.update_archive(trial_vector, trial_fitness)\n\n                    #Adaptive strategy: if improvement, increase mutation and crossover\n                    self.mutation_factor = min(1.0, self.mutation_factor * 1.1)\n                    self.crossover_rate = min(1.0, self.crossover_rate * 1.1)\n\n                else:\n                    #Decrease mutation and crossover if no improvement\n                    self.mutation_factor = max(0.1, self.mutation_factor * 0.9)\n                    self.crossover_rate = max(0.1, self.crossover_rate * 0.9)\n\n                self.mutation_factor_history.append(self.mutation_factor)\n                self.crossover_rate_history.append(self.crossover_rate)\n            self.mutation_factor = max(0.1, min(1.0, self.mutation_factor * (1 + 0.1 * np.std(self.fitness) / (np.mean(self.fitness) + 1e-8))))\n\n        if self.best_solution_overall is None and self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall,\n            'mutation_factor_history': self.mutation_factor_history,\n            'crossover_rate_history': self.crossover_rate_history\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info", "configspace": "", "generation": 3, "feedback": "The algorithm HybridDEArchiveAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["2d15187f-5bca-4cae-8ae9-0b4fa4220ff7"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.07445665825358165]}}
{"id": "e5d3996e-dcae-4c16-9174-64c17b27bf9c", "fitness": 0.024491364721141464, "name": "HybridDEArchiveAdaptive", "description": "Introduces a dynamic population size adjustment based on performance stagnation.", "code": "import numpy as np\nimport random\n\nclass HybridDEArchiveAdaptive:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n\n        self.population_size = int(5 + np.ceil(np.log(self.dim))) # Population scaling with dimension\n        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, float('inf'))\n\n        self.archive_size = self.population_size * 2  # Archive is larger than the population\n        self.archive = np.zeros((self.archive_size, self.dim))\n        self.archive_fitness = np.full(self.archive_size, float('inf'))\n        self.archive_idx = 0\n\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7 # Initial crossover rate\n        self.mutation_factor_history = [self.mutation_factor]\n        self.crossover_rate_history = [self.crossover_rate]\n        self.min_archive_fitness = float('inf')  #ADDED: Minimum acceptable fitness for archive entry\n        self.stagnation_counter = 0 # Counter for stagnation\n\n    def ensure_bounds(self, vec):\n        return np.clip(vec, self.lower_bounds, self.upper_bounds)\n\n    def update_archive(self, individual, fitness):\n        if fitness < np.max(self.archive_fitness) and fitness < self.min_archive_fitness:\n            worst_index = np.argmax(self.archive_fitness)\n            self.archive[worst_index] = individual\n            self.archive_fitness[worst_index] = fitness\n            self.min_archive_fitness = np.min(self.archive_fitness)\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        if self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n        else:\n            self.best_solution_overall = np.array([])\n        self.best_fitness_overall = float('inf')\n\n        # Initialize population and fitness\n        fitness_values = objective_function(self.population)\n        self.eval_count += self.population_size\n        self.fitness = fitness_values.copy()\n\n        for i in range(self.population_size):\n            if self.fitness[i] < self.best_fitness_overall:\n                self.best_fitness_overall = self.fitness[i]\n                self.best_solution_overall = self.population[i].copy()\n\n        # Initialize Archive with initial population\n        self.archive[:self.population_size] = self.population.copy()\n        self.archive_fitness[:self.population_size] = self.fitness.copy()\n        self.min_archive_fitness = np.max(self.archive_fitness) #initialize min_archive_fitness\n        self.archive_idx = self.population_size\n\n        while self.eval_count < self.budget and self.dim > 0:\n            for i in range(self.population_size):\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                if len(indices) >= 3: #Ensure we have at least 3 distinct indices from pop\n                    a, b, c = random.sample(indices, 3)\n                else:\n                    a, b, c = random.choices(indices, k = 3) #Allows replacement to proceed if len(indices) < 3\n\n                #Potentially use an archive member\n                if random.random() < 0.1: #10% chance of pulling a member from the archive\n                    arc_idx = random.randint(0, self.archive_size - 1)\n                    mutant = self.population[a] + self.mutation_factor * (self.archive[arc_idx] - self.population[b]) + self.mutation_factor * (self.population[c] - self.population[i])\n                else:\n                    mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c]) + self.mutation_factor * (self.best_solution_overall - self.population[i]) #Best solution guided mutation\n\n                mutant = self.ensure_bounds(mutant)\n                \n                # Crossover\n                trial_vector = np.zeros(self.dim)\n                for j in range(self.dim):\n                    if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):\n                        trial_vector[j] = mutant[j]\n                    else:\n                        trial_vector[j] = self.population[i][j]\n\n                trial_vector = self.ensure_bounds(trial_vector)\n\n                # Selection\n                trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector.copy()\n                    self.fitness[i] = trial_fitness\n\n                    # Update best solution\n                    if trial_fitness < self.best_fitness_overall:\n                        self.best_fitness_overall = trial_fitness\n                        self.best_solution_overall = trial_vector.copy()\n                        self.stagnation_counter = 0 # Reset counter\n\n                    #Update Archive\n                    self.update_archive(trial_vector, trial_fitness)\n\n                    #Adaptive strategy: if improvement, increase mutation and crossover\n                    self.mutation_factor = min(1.0, self.mutation_factor * 1.1)\n                    self.crossover_rate = min(1.0, self.crossover_rate * 1.1)\n\n                else:\n                    #Decrease mutation and crossover if no improvement\n                    self.mutation_factor = max(0.1, self.mutation_factor * 0.9)\n                    self.crossover_rate = max(0.1, self.crossover_rate * 0.9)\n                    self.stagnation_counter +=1\n\n                self.mutation_factor_history.append(self.mutation_factor)\n                self.crossover_rate_history.append(self.crossover_rate)\n            self.mutation_factor = max(0.1, min(1.0, self.mutation_factor * (1 + 0.1 * np.std(self.fitness) / (np.mean(self.fitness) + 1e-8))))\n            if self.stagnation_counter > 50 and self.population_size < 2 * (5 + np.ceil(np.log(self.dim))): #Dynamically adjusting population size.\n                 self.population_size += 1\n                 new_individual = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n                 new_fitness = objective_function(new_individual.reshape(1,-1))[0]\n                 self.eval_count +=1\n                 self.population = np.vstack((self.population, new_individual))\n                 self.fitness = np.append(self.fitness, new_fitness)\n\n        if self.best_solution_overall is None and self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall,\n            'mutation_factor_history': self.mutation_factor_history,\n            'crossover_rate_history': self.crossover_rate_history\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info", "configspace": "", "generation": 4, "feedback": "The algorithm HybridDEArchiveAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["99494c29-7a3c-4954-872d-d24457e890fb"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.07347409416342439]}}
{"id": "b1d3c47e-9a51-4fe6-a970-af46cd0c63d2", "fitness": 0.025603438698967692, "name": "HybridDEArchiveAdaptive", "description": "Adaptive DE with archive and dynamic parameter adjustment, focusing mutation adaptation on worst performers.", "code": "import numpy as np\nimport random\n\nclass HybridDEArchiveAdaptive:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n\n        self.population_size = int(5 + np.ceil(np.log(self.dim))) # Population scaling with dimension\n        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, float('inf'))\n\n        self.archive_size = self.population_size * 2  # Archive is larger than the population\n        self.archive = np.zeros((self.archive_size, self.dim))\n        self.archive_fitness = np.full(self.archive_size, float('inf'))\n        self.archive_idx = 0\n\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7 # Initial crossover rate\n        self.mutation_factor_history = [self.mutation_factor]\n        self.crossover_rate_history = [self.crossover_rate]\n        self.min_archive_fitness = float('inf')  #ADDED: Minimum acceptable fitness for archive entry\n\n    def ensure_bounds(self, vec):\n        return np.clip(vec, self.lower_bounds, self.upper_bounds)\n\n    def update_archive(self, individual, fitness):\n        if fitness < np.max(self.archive_fitness) and fitness < self.min_archive_fitness:\n            worst_index = np.argmax(self.archive_fitness)\n            self.archive[worst_index] = individual\n            self.archive_fitness[worst_index] = fitness\n            self.min_archive_fitness = np.min(self.archive_fitness)\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        if self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n        else:\n            self.best_solution_overall = np.array([])\n        self.best_fitness_overall = float('inf')\n\n        # Initialize population and fitness\n        fitness_values = objective_function(self.population)\n        self.eval_count += self.population_size\n        self.fitness = fitness_values.copy()\n\n        for i in range(self.population_size):\n            if self.fitness[i] < self.best_fitness_overall:\n                self.best_fitness_overall = self.fitness[i]\n                self.best_solution_overall = self.population[i].copy()\n\n        # Initialize Archive with initial population\n        self.archive[:self.population_size] = self.population.copy()\n        self.archive_fitness[:self.population_size] = self.fitness.copy()\n        self.min_archive_fitness = np.max(self.archive_fitness) #initialize min_archive_fitness\n        self.archive_idx = self.population_size\n\n        while self.eval_count < self.budget and self.dim > 0:\n            for i in range(self.population_size):\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                if len(indices) >= 3: #Ensure we have at least 3 distinct indices from pop\n                    a, b, c = random.sample(indices, 3)\n                else:\n                    a, b, c = random.choices(indices, k = 3) #Allows replacement to proceed if len(indices) < 3\n\n                #Potentially use an archive member\n                if random.random() < 0.1: #10% chance of pulling a member from the archive\n                    arc_idx = random.randint(0, self.archive_size - 1)\n                    mutant = self.population[a] + self.mutation_factor * (self.archive[arc_idx] - self.population[b]) + self.mutation_factor * (self.population[c] - self.population[i])\n                else:\n                    mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c]) + self.mutation_factor * (self.best_solution_overall - self.population[i]) #Best solution guided mutation\n\n                mutant = self.ensure_bounds(mutant)\n                \n                # Crossover\n                trial_vector = np.zeros(self.dim)\n                for j in range(self.dim):\n                    if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):\n                        trial_vector[j] = mutant[j]\n                    else:\n                        trial_vector[j] = self.population[i][j]\n\n                trial_vector = self.ensure_bounds(trial_vector)\n\n                # Selection\n                trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector.copy()\n                    self.fitness[i] = trial_fitness\n\n                    # Update best solution\n                    if trial_fitness < self.best_fitness_overall:\n                        self.best_fitness_overall = trial_fitness\n                        self.best_solution_overall = trial_vector.copy()\n\n                    #Update Archive\n                    self.update_archive(trial_vector, trial_fitness)\n\n                    #Adaptive strategy: if improvement, increase mutation and crossover\n                    self.mutation_factor = min(1.0, self.mutation_factor * 1.1)\n                    self.crossover_rate = min(1.0, self.crossover_rate * 1.1)\n\n                else:\n                    #Decrease mutation and crossover if no improvement\n                    self.mutation_factor = max(0.1, self.mutation_factor * 0.9)\n                    self.crossover_rate = max(0.1, self.crossover_rate * 0.9)\n\n                self.mutation_factor_history.append(self.mutation_factor)\n                self.crossover_rate_history.append(self.crossover_rate)\n            worst_index = np.argmax(self.fitness)\n            self.mutation_factor = max(0.1, min(1.0, self.mutation_factor * (1 + 0.1 * np.std(self.fitness) / (self.fitness[worst_index] + 1e-8))))\n\n        if self.best_solution_overall is None and self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall,\n            'mutation_factor_history': self.mutation_factor_history,\n            'crossover_rate_history': self.crossover_rate_history\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info", "configspace": "", "generation": 5, "feedback": "The algorithm HybridDEArchiveAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["99494c29-7a3c-4954-872d-d24457e890fb"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.07681031609690307]}}
{"id": "b8c2879d-68ea-4999-b8c1-038482b35053", "fitness": 0.02335629508189897, "name": "HybridDEArchiveAdaptive", "description": "Adaptive DE with archive and dynamic parameter adjustment, with simplified diversity maintenance and parameter adaptation.", "code": "import numpy as np\nimport random\n\nclass HybridDEArchiveAdaptive:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n\n        self.population_size = int(5 + np.ceil(np.log(self.dim))) # Population scaling with dimension\n        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, float('inf'))\n\n        self.archive_size = self.population_size * 2  # Archive is larger than the population\n        self.archive = np.zeros((self.archive_size, self.dim))\n        self.archive_fitness = np.full(self.archive_size, float('inf'))\n        self.archive_idx = 0\n\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7 # Initial crossover rate\n        self.mutation_factor_history = [self.mutation_factor]\n        self.crossover_rate_history = [self.crossover_rate]\n        self.min_archive_fitness = float('inf')  #ADDED: Minimum acceptable fitness for archive entry\n\n    def ensure_bounds(self, vec):\n        return np.clip(vec, self.lower_bounds, self.upper_bounds)\n\n    def update_archive(self, individual, fitness):\n        if fitness < np.max(self.archive_fitness) and fitness < self.min_archive_fitness:\n            worst_index = np.argmax(self.archive_fitness)\n            self.archive[worst_index] = individual\n            self.archive_fitness[worst_index] = fitness\n            self.min_archive_fitness = np.min(self.archive_fitness)\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        if self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n        else:\n            self.best_solution_overall = np.array([])\n        self.best_fitness_overall = float('inf')\n\n        # Initialize population and fitness\n        fitness_values = objective_function(self.population)\n        self.eval_count += self.population_size\n        self.fitness = fitness_values.copy()\n\n        for i in range(self.population_size):\n            if self.fitness[i] < self.best_fitness_overall:\n                self.best_fitness_overall = self.fitness[i]\n                self.best_solution_overall = self.population[i].copy()\n\n        # Initialize Archive with initial population\n        self.archive[:self.population_size] = self.population.copy()\n        self.archive_fitness[:self.population_size] = self.fitness.copy()\n        self.min_archive_fitness = np.max(self.archive_fitness) #initialize min_archive_fitness\n        self.archive_idx = self.population_size\n\n        while self.eval_count < self.budget and self.dim > 0:\n            for i in range(self.population_size):\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                if len(indices) >= 3: #Ensure we have at least 3 distinct indices from pop\n                    a, b, c = random.sample(indices, 3)\n                else:\n                    a, b, c = random.choices(indices, k = 3) #Allows replacement to proceed if len(indices) < 3\n\n                #Potentially use an archive member\n                if random.random() < 0.1: #10% chance of pulling a member from the archive\n                    arc_idx = random.randint(0, self.archive_size - 1)\n                    mutant = self.population[a] + self.mutation_factor * (self.archive[arc_idx] - self.population[b]) #Simplified\n                else:\n                    mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c]) #+ self.mutation_factor * (self.best_solution_overall - self.population[i]) #Best solution guided mutation Removed due to line limit\n\n                mutant = self.ensure_bounds(mutant)\n                \n                # Crossover\n                trial_vector = np.zeros(self.dim)\n                for j in range(self.dim):\n                    if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):\n                        trial_vector[j] = mutant[j]\n                    else:\n                        trial_vector[j] = self.population[i][j]\n\n                trial_vector = self.ensure_bounds(trial_vector)\n\n                # Selection\n                trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector.copy()\n                    self.fitness[i] = trial_fitness\n\n                    # Update best solution\n                    if trial_fitness < self.best_fitness_overall:\n                        self.best_fitness_overall = trial_fitness\n                        self.best_solution_overall = trial_vector.copy()\n\n                    #Update Archive\n                    self.update_archive(trial_vector, trial_fitness)\n\n                #else: #Removed because it exceeds change limit\n                    ##Decrease mutation and crossover if no improvement\n                    #self.mutation_factor = max(0.1, self.mutation_factor * 0.9)\n                    #self.crossover_rate = max(0.1, self.crossover_rate * 0.9)\n\n                self.mutation_factor_history.append(self.mutation_factor)\n                self.crossover_rate_history.append(self.crossover_rate)\n            worst_index = np.argmax(self.fitness)\n            self.mutation_factor = max(0.1, min(1.0, self.mutation_factor * (1 + 0.1 * np.std(self.fitness) / (self.fitness[worst_index] + 1e-8))))\n\n        if self.best_solution_overall is None and self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall,\n            'mutation_factor_history': self.mutation_factor_history,\n            'crossover_rate_history': self.crossover_rate_history\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info", "configspace": "", "generation": 6, "feedback": "The algorithm HybridDEArchiveAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["b1d3c47e-9a51-4fe6-a970-af46cd0c63d2"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.0700688852456969]}}
{"id": "b240f2eb-e8b5-4bbf-a409-b0d47a177de2", "fitness": 0.02390292813240383, "name": "HybridDEArchiveAdaptive", "description": "Adaptive DE with archive and dynamic parameter adjustment, using fitness difference-based mutation scaling.", "code": "import numpy as np\nimport random\n\nclass HybridDEArchiveAdaptive:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n\n        self.population_size = int(5 + np.ceil(np.log(self.dim))) # Population scaling with dimension\n        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, float('inf'))\n\n        self.archive_size = self.population_size * 2  # Archive is larger than the population\n        self.archive = np.zeros((self.archive_size, self.dim))\n        self.archive_fitness = np.full(self.archive_size, float('inf'))\n        self.archive_idx = 0\n\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7 # Initial crossover rate\n        self.mutation_factor_history = [self.mutation_factor]\n        self.crossover_rate_history = [self.crossover_rate]\n        self.min_archive_fitness = float('inf')  #ADDED: Minimum acceptable fitness for archive entry\n\n    def ensure_bounds(self, vec):\n        return np.clip(vec, self.lower_bounds, self.upper_bounds)\n\n    def update_archive(self, individual, fitness):\n        if fitness < np.max(self.archive_fitness) and fitness < self.min_archive_fitness:\n            worst_index = np.argmax(self.archive_fitness)\n            self.archive[worst_index] = individual\n            self.archive_fitness[worst_index] = fitness\n            self.min_archive_fitness = np.min(self.archive_fitness)\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        if self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n        else:\n            self.best_solution_overall = np.array([])\n        self.best_fitness_overall = float('inf')\n\n        # Initialize population and fitness\n        fitness_values = objective_function(self.population)\n        self.eval_count += self.population_size\n        self.fitness = fitness_values.copy()\n\n        for i in range(self.population_size):\n            if self.fitness[i] < self.best_fitness_overall:\n                self.best_fitness_overall = self.fitness[i]\n                self.best_solution_overall = self.population[i].copy()\n\n        # Initialize Archive with initial population\n        self.archive[:self.population_size] = self.population.copy()\n        self.archive_fitness[:self.population_size] = self.fitness.copy()\n        self.min_archive_fitness = np.max(self.archive_fitness) #initialize min_archive_fitness\n        self.archive_idx = self.population_size\n\n        while self.eval_count < self.budget and self.dim > 0:\n            for i in range(self.population_size):\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                if len(indices) >= 3: #Ensure we have at least 3 distinct indices from pop\n                    a, b, c = random.sample(indices, 3)\n                else:\n                    a, b, c = random.choices(indices, k = 3) #Allows replacement to proceed if len(indices) < 3\n\n                #Potentially use an archive member\n                if random.random() < 0.1: #10% chance of pulling a member from the archive\n                    arc_idx = random.randint(0, self.archive_size - 1)\n                    mutant = self.population[a] + self.mutation_factor * (self.archive[arc_idx] - self.population[b]) + self.mutation_factor * (self.population[c] - self.population[i])\n                else:\n                    mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c]) + self.mutation_factor * (self.best_solution_overall - self.population[i]) #Best solution guided mutation\n\n                mutant = self.ensure_bounds(mutant)\n                \n                # Crossover\n                trial_vector = np.zeros(self.dim)\n                for j in range(self.dim):\n                    if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):\n                        trial_vector[j] = mutant[j]\n                    else:\n                        trial_vector[j] = self.population[i][j]\n\n                trial_vector = self.ensure_bounds(trial_vector)\n\n                # Selection\n                trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector.copy()\n                    self.fitness[i] = trial_fitness\n\n                    # Update best solution\n                    if trial_fitness < self.best_fitness_overall:\n                        self.best_fitness_overall = trial_fitness\n                        self.best_solution_overall = trial_vector.copy()\n\n                    #Update Archive\n                    self.update_archive(trial_vector, trial_fitness)\n\n                    #Adaptive strategy: if improvement, increase mutation and crossover\n                    self.mutation_factor = min(1.0, self.mutation_factor * 1.1)\n                    self.crossover_rate = min(1.0, self.crossover_rate * 1.1)\n\n                else:\n                    #Decrease mutation and crossover if no improvement\n                    self.mutation_factor = max(0.1, self.mutation_factor * 0.9)\n                    self.crossover_rate = max(0.1, self.crossover_rate * 0.9)\n\n                self.mutation_factor_history.append(self.mutation_factor)\n                self.crossover_rate_history.append(self.crossover_rate)\n            worst_index = np.argmax(self.fitness)\n            fitness_diff = self.fitness[worst_index] - self.best_fitness_overall\n            self.mutation_factor = max(0.1, min(1.0, self.mutation_factor * (1 + 0.1 * fitness_diff / (np.abs(self.best_fitness_overall) + 1e-8))))\n\n        if self.best_solution_overall is None and self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall,\n            'mutation_factor_history': self.mutation_factor_history,\n            'crossover_rate_history': self.crossover_rate_history\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info", "configspace": "", "generation": 7, "feedback": "The algorithm HybridDEArchiveAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["b1d3c47e-9a51-4fe6-a970-af46cd0c63d2"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.0717087843972115]}}
{"id": "63e64a6a-051b-4421-a701-c4c0f6c11546", "fitness": 0.023256757154706945, "name": "HybridDEArchiveAdaptive", "description": "Refines archive update by adding diversity pressure, accepting only sufficiently different individuals.", "code": "import numpy as np\nimport random\n\nclass HybridDEArchiveAdaptive:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n\n        self.population_size = int(5 + np.ceil(np.log(self.dim))) # Population scaling with dimension\n        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, float('inf'))\n\n        self.archive_size = self.population_size * 2  # Archive is larger than the population\n        self.archive = np.zeros((self.archive_size, self.dim))\n        self.archive_fitness = np.full(self.archive_size, float('inf'))\n        self.archive_idx = 0\n\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7 # Initial crossover rate\n        self.mutation_factor_history = [self.mutation_factor]\n        self.crossover_rate_history = [self.crossover_rate]\n        self.min_archive_fitness = float('inf')  #ADDED: Minimum acceptable fitness for archive entry\n\n    def ensure_bounds(self, vec):\n        return np.clip(vec, self.lower_bounds, self.upper_bounds)\n\n    def update_archive(self, individual, fitness):\n        if fitness < np.max(self.archive_fitness) and fitness < self.min_archive_fitness:\n            worst_index = np.argmax(self.archive_fitness)\n            if np.linalg.norm(individual - self.archive[worst_index]) > 0.01: #Diversity check\n                self.archive[worst_index] = individual\n                self.archive_fitness[worst_index] = fitness\n                self.min_archive_fitness = np.min(self.archive_fitness)\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        if self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n        else:\n            self.best_solution_overall = np.array([])\n        self.best_fitness_overall = float('inf')\n\n        # Initialize population and fitness\n        fitness_values = objective_function(self.population)\n        self.eval_count += self.population_size\n        self.fitness = fitness_values.copy()\n\n        for i in range(self.population_size):\n            if self.fitness[i] < self.best_fitness_overall:\n                self.best_fitness_overall = self.fitness[i]\n                self.best_solution_overall = self.population[i].copy()\n\n        # Initialize Archive with initial population\n        self.archive[:self.population_size] = self.population.copy()\n        self.archive_fitness[:self.population_size] = self.fitness.copy()\n        self.min_archive_fitness = np.max(self.archive_fitness) #initialize min_archive_fitness\n        self.archive_idx = self.population_size\n\n        while self.eval_count < self.budget and self.dim > 0:\n            for i in range(self.population_size):\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                if len(indices) >= 3: #Ensure we have at least 3 distinct indices from pop\n                    a, b, c = random.sample(indices, 3)\n                else:\n                    a, b, c = random.choices(indices, k = 3) #Allows replacement to proceed if len(indices) < 3\n\n                #Potentially use an archive member\n                if random.random() < 0.1: #10% chance of pulling a member from the archive\n                    arc_idx = random.randint(0, self.archive_size - 1)\n                    mutant = self.population[a] + self.mutation_factor * (self.archive[arc_idx] - self.population[b]) + self.mutation_factor * (self.population[c] - self.population[i])\n                else:\n                    mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c]) + self.mutation_factor * (self.best_solution_overall - self.population[i]) #Best solution guided mutation\n\n                mutant = self.ensure_bounds(mutant)\n                \n                # Crossover\n                trial_vector = np.zeros(self.dim)\n                for j in range(self.dim):\n                    if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):\n                        trial_vector[j] = mutant[j]\n                    else:\n                        trial_vector[j] = self.population[i][j]\n\n                trial_vector = self.ensure_bounds(trial_vector)\n\n                # Selection\n                trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector.copy()\n                    self.fitness[i] = trial_fitness\n\n                    # Update best solution\n                    if trial_fitness < self.best_fitness_overall:\n                        self.best_fitness_overall = trial_fitness\n                        self.best_solution_overall = trial_vector.copy()\n\n                    #Update Archive\n                    self.update_archive(trial_vector, trial_fitness)\n\n                    #Adaptive strategy: if improvement, increase mutation and crossover\n                    self.mutation_factor = min(1.0, self.mutation_factor * 1.1)\n                    self.crossover_rate = min(1.0, self.crossover_rate * 1.1)\n\n                else:\n                    #Decrease mutation and crossover if no improvement\n                    self.mutation_factor = max(0.1, self.mutation_factor * 0.9)\n                    self.crossover_rate = max(0.1, self.crossover_rate * 0.9)\n\n                self.mutation_factor_history.append(self.mutation_factor)\n                self.crossover_rate_history.append(self.crossover_rate)\n            worst_index = np.argmax(self.fitness)\n            self.mutation_factor = max(0.1, min(1.0, self.mutation_factor * (1 + 0.1 * np.std(self.fitness) / (self.fitness[worst_index] + 1e-8))))\n\n        if self.best_solution_overall is None and self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall,\n            'mutation_factor_history': self.mutation_factor_history,\n            'crossover_rate_history': self.crossover_rate_history\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info", "configspace": "", "generation": 8, "feedback": "The algorithm HybridDEArchiveAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["b1d3c47e-9a51-4fe6-a970-af46cd0c63d2"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.06977027146412083]}}
{"id": "7411c18e-2b14-407f-a63b-18b965887f0b", "fitness": 0.023010363031757828, "name": "HybridDEArchiveAdaptive", "description": "Adaptive DE with archive and dynamic parameter adjustment, using a scaled mutation based on rank.", "code": "import numpy as np\nimport random\n\nclass HybridDEArchiveAdaptive:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n\n        self.population_size = int(5 + np.ceil(np.log(self.dim))) # Population scaling with dimension\n        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, float('inf'))\n\n        self.archive_size = self.population_size * 2  # Archive is larger than the population\n        self.archive = np.zeros((self.archive_size, self.dim))\n        self.archive_fitness = np.full(self.archive_size, float('inf'))\n        self.archive_idx = 0\n\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7 # Initial crossover rate\n        self.mutation_factor_history = [self.mutation_factor]\n        self.crossover_rate_history = [self.crossover_rate]\n        self.min_archive_fitness = float('inf')  #ADDED: Minimum acceptable fitness for archive entry\n\n    def ensure_bounds(self, vec):\n        return np.clip(vec, self.lower_bounds, self.upper_bounds)\n\n    def update_archive(self, individual, fitness):\n        if fitness < np.max(self.archive_fitness) and fitness < self.min_archive_fitness:\n            worst_index = np.argmax(self.archive_fitness)\n            self.archive[worst_index] = individual\n            self.archive_fitness[worst_index] = fitness\n            self.min_archive_fitness = np.min(self.archive_fitness)\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        if self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n        else:\n            self.best_solution_overall = np.array([])\n        self.best_fitness_overall = float('inf')\n\n        # Initialize population and fitness\n        fitness_values = objective_function(self.population)\n        self.eval_count += self.population_size\n        self.fitness = fitness_values.copy()\n\n        for i in range(self.population_size):\n            if self.fitness[i] < self.best_fitness_overall:\n                self.best_fitness_overall = self.fitness[i]\n                self.best_solution_overall = self.population[i].copy()\n\n        # Initialize Archive with initial population\n        self.archive[:self.population_size] = self.population.copy()\n        self.archive_fitness[:self.population_size] = self.fitness.copy()\n        self.min_archive_fitness = np.max(self.archive_fitness) #initialize min_archive_fitness\n        self.archive_idx = self.population_size\n\n        while self.eval_count < self.budget and self.dim > 0:\n            #Sort by fitness\n            ranked_indices = np.argsort(self.fitness)\n\n            for i in range(self.population_size):\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                if len(indices) >= 3: #Ensure we have at least 3 distinct indices from pop\n                    a, b, c = random.sample(indices, 3)\n                else:\n                    a, b, c = random.choices(indices, k = 3) #Allows replacement to proceed if len(indices) < 3\n\n                #Potentially use an archive member\n                if random.random() < 0.1: #10% chance of pulling a member from the archive\n                    arc_idx = random.randint(0, self.archive_size - 1)\n                    mutant = self.population[a] + self.mutation_factor * (self.archive[arc_idx] - self.population[b]) + self.mutation_factor * (self.population[c] - self.population[i])\n                else:\n                    #Best solution guided mutation with scaling\n                    scale = (ranked_indices[i] + 1) / self.population_size #Scaling factor based on rank\n                    mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c]) + self.mutation_factor * scale * (self.best_solution_overall - self.population[i])\n\n                mutant = self.ensure_bounds(mutant)\n                \n                # Crossover\n                trial_vector = np.zeros(self.dim)\n                for j in range(self.dim):\n                    if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):\n                        trial_vector[j] = mutant[j]\n                    else:\n                        trial_vector[j] = self.population[i][j]\n\n                trial_vector = self.ensure_bounds(trial_vector)\n\n                # Selection\n                trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector.copy()\n                    self.fitness[i] = trial_fitness\n\n                    # Update best solution\n                    if trial_fitness < self.best_fitness_overall:\n                        self.best_fitness_overall = trial_fitness\n                        self.best_solution_overall = trial_vector.copy()\n\n                    #Update Archive\n                    self.update_archive(trial_vector, trial_fitness)\n\n                    #Adaptive strategy: if improvement, increase mutation and crossover\n                    self.mutation_factor = min(1.0, self.mutation_factor * 1.1)\n                    self.crossover_rate = min(1.0, self.crossover_rate * 1.1)\n\n                else:\n                    #Decrease mutation and crossover if no improvement\n                    self.mutation_factor = max(0.1, self.mutation_factor * 0.9)\n                    self.crossover_rate = max(0.1, self.crossover_rate * 0.9)\n\n                self.mutation_factor_history.append(self.mutation_factor)\n                self.crossover_rate_history.append(self.crossover_rate)\n            worst_index = np.argmax(self.fitness)\n            self.mutation_factor = max(0.1, min(1.0, self.mutation_factor * (1 + 0.1 * np.std(self.fitness) / (self.fitness[worst_index] + 1e-8))))\n\n        if self.best_solution_overall is None and self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall,\n            'mutation_factor_history': self.mutation_factor_history,\n            'crossover_rate_history': self.crossover_rate_history\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info", "configspace": "", "generation": 9, "feedback": "The algorithm HybridDEArchiveAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["b1d3c47e-9a51-4fe6-a970-af46cd0c63d2"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.06903108909527349]}}
{"id": "94c1ecb7-7519-4f59-80a8-f2fc945b083b", "fitness": -Infinity, "name": "HybridDEArchiveAdaptive", "description": "Adaptive DE with archive and dynamic parameter adjustment, focusing mutation adaptation on worst performers.", "code": "import numpy as np\nimport random\n\nclass HybridDEArchiveAdaptive:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n\n        self.population_size = int(5 + np.ceil(np.log(self.dim))) # Population scaling with dimension\n        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, float('inf'))\n\n        self.archive_size = self.population_size * 2  # Archive is larger than the population\n        self.archive = np.zeros((self.archive_size, self.dim))\n        self.archive_fitness = np.full(self.archive_size, float('inf'))\n        self.archive_idx = 0\n\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7 # Initial crossover rate\n        self.mutation_factor_history = [self.mutation_factor]\n        self.crossover_rate_history = [self.crossover_rate]\n        self.min_archive_fitness = float('inf')  #ADDED: Minimum acceptable fitness for archive entry\n\n    def ensure_bounds(self, vec):\n        return np.clip(vec, self.lower_bounds, self.upper_bounds)\n\n    def update_archive(self, individual, fitness):\n        if fitness < np.max(self.archive_fitness) and fitness < self.min_archive_fitness:\n            worst_index = np.argmax(self.archive_fitness)\n            self.archive[worst_index] = individual\n            self.archive_fitness[worst_index] = fitness\n            self.min_archive_fitness = np.min(self.archive_fitness)\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        if self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n        else:\n            self.best_solution_overall = np.array([])\n        self.best_fitness_overall = float('inf')\n\n        # Initialize population and fitness\n        fitness_values = objective_function(self.population)\n        self.eval_count += self.population_size\n        self.fitness = fitness_values.copy()\n\n        for i in range(self.population_size):\n            if self.fitness[i] < self.best_fitness_overall:\n                self.best_fitness_overall = self.fitness[i]\n                self.best_solution_overall = self.population[i].copy()\n\n        # Initialize Archive with initial population\n        self.archive[:self.population_size] = self.population.copy()\n        self.archive_fitness[:self.population_size] = self.fitness.copy()\n        self.min_archive_fitness = np.max(self.archive_fitness) #initialize min_archive_fitness\n        self.archive_idx = self.population_size\n\n        while self.eval_count < self.budget and self.dim > 0:\n            for i in range(self.population_size):\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                if len(indices) >= 3: #Ensure we have at least 3 distinct indices from pop\n                    a, b, c = random.sample(indices, 3)\n                else:\n                    a, b, c = random.choices(indices, k = 3) #Allows replacement to proceed if len(indices) < 3\n\n                #Potentially use an archive member\n                if random.random() < 0.1: #10% chance of pulling a member from the archive\n                    arc_idx = random.randint(0, self.archive_size - 1)\n                    mutant = self.population[a] + self.mutation_factor * (self.archive[arc_idx] - self.population[b]) + self.mutation_factor * (self.population[c] - self.population[i])\n                else:\n                    mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c]) + self.mutation_factor * (self.best_solution_overall - self.population[i]) #Best solution guided mutation\n\n                mutant = self.ensure_bounds(mutant)\n                \n                # Crossover\n                trial_vector = np.zeros(self.dim)\n                for j in range(self.dim):\n                    if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):\n                        trial_vector[j] = mutant[j]\n                    else:\n                        trial_vector[j] = self.population[i][j]\n\n                trial_vector = self.ensure_bounds(trial_vector)\n\n                # Selection\n                trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector.copy()\n                    self.fitness[i] = trial_fitness\n\n                    # Update best solution\n                    if trial_fitness < self.best_fitness_overall:\n                        self.best_fitness_overall = trial_fitness\n                        self.best_solution_overall = trial_vector.copy()\n\n                    #Update Archive\n                    self.update_archive(trial_vector, trial_fitness)\n\n                    #Adaptive strategy: if improvement, increase mutation and crossover\n                    self.mutation_factor = min(1.0, self.mutation_factor * 1.1)\n                    self.crossover_rate = min(1.0, self.crossover_rate * 1.1)\n\n                else:\n                    #Decrease mutation and crossover if no improvement\n                    self.mutation_factor = max(0.1, self.mutation_factor * 0.9)\n                    self.crossover_rate = max(0.1, self.crossover_rate * 0.9)\n\n                self.mutation_factor_history.append(self.mutation_factor)\n                self.crossover_rate_history.append(self.crossover_rate)\n            worst_index = np.argmax(self.fitness)\n            self.mutation_factor = max(0.1, min(1.0, self.mutation_factor * (1 + 0.1 * np.std(self.fitness) / (self.fitness[worst_index] + 1e-8))))\n\n        if self.best_solution_overall is None and self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall,\n            'mutation_factor_history': self.mutation_factor_history,\n            'crossover_rate_history': self.crossover_rate_history\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info", "configspace": "", "generation": 6, "feedback": "An exception occurred: DeadlineExceeded('Deadline Exceeded').", "error": "DeadlineExceeded('Deadline Exceeded')", "parent_ids": ["b1d3c47e-9a51-4fe6-a970-af46cd0c63d2"], "operator": "Refine the strategy of the selected solution to improve it. \nMake sure you only change 0.8% of the code, which means if the code has 100 lines, you can only change 0.7575757575757576 lines, and the rest of the lines should remain unchanged. \nThis input code has 132 lines, so you can only change 1 lines, the rest 131 lines should remain unchanged. \nThis changing rate 0.8% is a mandatory requirement, you cannot change more or less than this rate.\n", "metadata": {"aucs": [0.0, 0.0, 0.07681031609690307]}}
{"id": "f05a721c-7674-471b-9944-e743cacb2639", "fitness": 0.02320611975210304, "name": "HybridDEArchiveAdaptive", "description": "Adaptive DE with archive, dynamic parameter adjustment, and a tournament selection to further exploit promising regions.", "code": "import numpy as np\nimport random\n\nclass HybridDEArchiveAdaptive:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n\n        self.population_size = int(5 + np.ceil(np.log(self.dim))) # Population scaling with dimension\n        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, float('inf'))\n\n        self.archive_size = self.population_size * 2  # Archive is larger than the population\n        self.archive = np.zeros((self.archive_size, self.dim))\n        self.archive_fitness = np.full(self.archive_size, float('inf'))\n        self.archive_idx = 0\n\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7 # Initial crossover rate\n        self.mutation_factor_history = [self.mutation_factor]\n        self.crossover_rate_history = [self.crossover_rate]\n        self.min_archive_fitness = float('inf')  #ADDED: Minimum acceptable fitness for archive entry\n\n    def ensure_bounds(self, vec):\n        return np.clip(vec, self.lower_bounds, self.upper_bounds)\n\n    def update_archive(self, individual, fitness):\n        if fitness < np.max(self.archive_fitness) and fitness < self.min_archive_fitness:\n            worst_index = np.argmax(self.archive_fitness)\n            self.archive[worst_index] = individual\n            self.archive_fitness[worst_index] = fitness\n            self.min_archive_fitness = np.min(self.archive_fitness)\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        if self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n        else:\n            self.best_solution_overall = np.array([])\n        self.best_fitness_overall = float('inf')\n\n        # Initialize population and fitness\n        fitness_values = objective_function(self.population)\n        self.eval_count += self.population_size\n        self.fitness = fitness_values.copy()\n\n        for i in range(self.population_size):\n            if self.fitness[i] < self.best_fitness_overall:\n                self.best_fitness_overall = self.fitness[i]\n                self.best_solution_overall = self.population[i].copy()\n\n        # Initialize Archive with initial population\n        self.archive[:self.population_size] = self.population.copy()\n        self.archive_fitness[:self.population_size] = self.fitness.copy()\n        self.min_archive_fitness = np.max(self.archive_fitness) #initialize min_archive_fitness\n        self.archive_idx = self.population_size\n\n        while self.eval_count < self.budget and self.dim > 0:\n            for i in range(self.population_size):\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                if len(indices) >= 3: #Ensure we have at least 3 distinct indices from pop\n                    a, b, c = random.sample(indices, 3)\n                else:\n                    a, b, c = random.choices(indices, k = 3) #Allows replacement to proceed if len(indices) < 3\n\n                #Potentially use an archive member\n                if random.random() < 0.1: #10% chance of pulling a member from the archive\n                    arc_idx = random.randint(0, self.archive_size - 1)\n                    mutant = self.population[a] + self.mutation_factor * (self.archive[arc_idx] - self.population[b]) + self.mutation_factor * (self.population[c] - self.population[i])\n                else:\n                    mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c]) + self.mutation_factor * (self.best_solution_overall - self.population[i]) #Best solution guided mutation\n\n                mutant = self.ensure_bounds(mutant)\n                \n                # Crossover\n                trial_vector = np.zeros(self.dim)\n                for j in range(self.dim):\n                    if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):\n                        trial_vector[j] = mutant[j]\n                    else:\n                        trial_vector[j] = self.population[i][j]\n\n                trial_vector = self.ensure_bounds(trial_vector)\n\n                # Selection\n                trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    # Tournament Selection: Further exploit promising regions\n                    competitor_idx = random.randint(0, self.population_size -1)\n                    if trial_fitness < self.fitness[competitor_idx]:\n                        self.population[i] = trial_vector.copy()\n                        self.fitness[i] = trial_fitness\n\n                    # Update best solution\n                    if trial_fitness < self.best_fitness_overall:\n                        self.best_fitness_overall = trial_fitness\n                        self.best_solution_overall = trial_vector.copy()\n\n                    #Update Archive\n                    self.update_archive(trial_vector, trial_fitness)\n\n                    #Adaptive strategy: if improvement, increase mutation and crossover\n                    self.mutation_factor = min(1.0, self.mutation_factor * 1.1)\n                    self.crossover_rate = min(1.0, self.crossover_rate * 1.1)\n\n                else:\n                    #Decrease mutation and crossover if no improvement\n                    self.mutation_factor = max(0.1, self.mutation_factor * 0.9)\n                    self.crossover_rate = max(0.1, self.crossover_rate * 0.9)\n\n                self.mutation_factor_history.append(self.mutation_factor)\n                self.crossover_rate_history.append(self.crossover_rate)\n            worst_index = np.argmax(self.fitness)\n            self.mutation_factor = max(0.1, min(1.0, self.mutation_factor * (1 + 0.1 * np.std(self.fitness) / (self.fitness[worst_index] + 1e-8))))\n\n        if self.best_solution_overall is None and self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall,\n            'mutation_factor_history': self.mutation_factor_history,\n            'crossover_rate_history': self.crossover_rate_history\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info", "configspace": "", "generation": 11, "feedback": "The algorithm HybridDEArchiveAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["b1d3c47e-9a51-4fe6-a970-af46cd0c63d2"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.06961835925630912]}}
{"id": "2577201e-ad45-4dc5-ab71-c35a96362781", "fitness": 0.02515025596298651, "name": "HybridDEArchiveAdaptive", "description": "Adaptive DE with archive, dynamic parameter adjustment, and periodic archive flushing to maintain diversity.", "code": "import numpy as np\nimport random\n\nclass HybridDEArchiveAdaptive:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n\n        self.population_size = int(5 + np.ceil(np.log(self.dim))) # Population scaling with dimension\n        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, float('inf'))\n\n        self.archive_size = self.population_size * 2  # Archive is larger than the population\n        self.archive = np.zeros((self.archive_size, self.dim))\n        self.archive_fitness = np.full(self.archive_size, float('inf'))\n        self.archive_idx = 0\n\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7 # Initial crossover rate\n        self.mutation_factor_history = [self.mutation_factor]\n        self.crossover_rate_history = [self.crossover_rate]\n        self.min_archive_fitness = float('inf')  #ADDED: Minimum acceptable fitness for archive entry\n        self.archive_flush_interval = 50 # Flush archive every 50 iterations.\n\n    def ensure_bounds(self, vec):\n        return np.clip(vec, self.lower_bounds, self.upper_bounds)\n\n    def update_archive(self, individual, fitness):\n        if fitness < np.max(self.archive_fitness) and fitness < self.min_archive_fitness:\n            worst_index = np.argmax(self.archive_fitness)\n            self.archive[worst_index] = individual\n            self.archive_fitness[worst_index] = fitness\n            self.min_archive_fitness = np.min(self.archive_fitness)\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        if self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n        else:\n            self.best_solution_overall = np.array([])\n        self.best_fitness_overall = float('inf')\n\n        # Initialize population and fitness\n        fitness_values = objective_function(self.population)\n        self.eval_count += self.population_size\n        self.fitness = fitness_values.copy()\n\n        for i in range(self.population_size):\n            if self.fitness[i] < self.best_fitness_overall:\n                self.best_fitness_overall = self.fitness[i]\n                self.best_solution_overall = self.population[i].copy()\n\n        # Initialize Archive with initial population\n        self.archive[:self.population_size] = self.population.copy()\n        self.archive_fitness[:self.population_size] = self.fitness.copy()\n        self.min_archive_fitness = np.max(self.archive_fitness) #initialize min_archive_fitness\n        self.archive_idx = self.population_size\n        iteration = 0\n\n        while self.eval_count < self.budget and self.dim > 0:\n            for i in range(self.population_size):\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                if len(indices) >= 3: #Ensure we have at least 3 distinct indices from pop\n                    a, b, c = random.sample(indices, 3)\n                else:\n                    a, b, c = random.choices(indices, k = 3) #Allows replacement to proceed if len(indices) < 3\n\n                #Potentially use an archive member\n                if random.random() < 0.1: #10% chance of pulling a member from the archive\n                    arc_idx = random.randint(0, self.archive_size - 1)\n                    mutant = self.population[a] + self.mutation_factor * (self.archive[arc_idx] - self.population[b]) + self.mutation_factor * (self.population[c] - self.population[i])\n                else:\n                    mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c]) + self.mutation_factor * (self.best_solution_overall - self.population[i]) #Best solution guided mutation\n\n                mutant = self.ensure_bounds(mutant)\n                \n                # Crossover\n                trial_vector = np.zeros(self.dim)\n                for j in range(self.dim):\n                    if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):\n                        trial_vector[j] = mutant[j]\n                    else:\n                        trial_vector[j] = self.population[i][j]\n\n                trial_vector = self.ensure_bounds(trial_vector)\n\n                # Selection\n                trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector.copy()\n                    self.fitness[i] = trial_fitness\n\n                    # Update best solution\n                    if trial_fitness < self.best_fitness_overall:\n                        self.best_fitness_overall = trial_fitness\n                        self.best_solution_overall = trial_vector.copy()\n\n                    #Update Archive\n                    self.update_archive(trial_vector, trial_fitness)\n\n                    #Adaptive strategy: if improvement, increase mutation and crossover\n                    self.mutation_factor = min(1.0, self.mutation_factor * 1.1)\n                    self.crossover_rate = min(1.0, self.crossover_rate * 1.1)\n\n                else:\n                    #Decrease mutation and crossover if no improvement\n                    self.mutation_factor = max(0.1, self.mutation_factor * 0.9)\n                    self.crossover_rate = max(0.1, self.crossover_rate * 0.9)\n\n                self.mutation_factor_history.append(self.mutation_factor)\n                self.crossover_rate_history.append(self.crossover_rate)\n            worst_index = np.argmax(self.fitness)\n            self.mutation_factor = max(0.1, min(1.0, self.mutation_factor * (1 + 0.1 * np.std(self.fitness) / (self.fitness[worst_index] + 1e-8))))\n            \n            iteration += 1\n            if iteration % self.archive_flush_interval == 0:\n                self.archive[:self.population_size] = self.population.copy()\n                self.archive_fitness[:self.population_size] = self.fitness.copy()\n                self.archive_idx = self.population_size\n                self.min_archive_fitness = np.max(self.archive_fitness)\n\n\n        if self.best_solution_overall is None and self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall,\n            'mutation_factor_history': self.mutation_factor_history,\n            'crossover_rate_history': self.crossover_rate_history\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info", "configspace": "", "generation": 12, "feedback": "The algorithm HybridDEArchiveAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03 with standard deviation 0.04.", "error": "", "parent_ids": ["b1d3c47e-9a51-4fe6-a970-af46cd0c63d2"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.07545076788895953]}}
{"id": "8062a1a3-1740-4b3d-bc5d-8cbed19b4357", "fitness": 0.024776599154121823, "name": "HybridDEArchiveAdaptive", "description": "Adaptive DE with archive, dynamic parameter adjustment, and enhanced archive update strategy based on population diversity.", "code": "import numpy as np\nimport random\n\nclass HybridDEArchiveAdaptive:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n\n        self.population_size = int(5 + np.ceil(np.log(self.dim))) # Population scaling with dimension\n        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, float('inf'))\n\n        self.archive_size = self.population_size * 2  # Archive is larger than the population\n        self.archive = np.zeros((self.archive_size, self.dim))\n        self.archive_fitness = np.full(self.archive_size, float('inf'))\n        self.archive_idx = 0\n\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7 # Initial crossover rate\n        self.mutation_factor_history = [self.mutation_factor]\n        self.crossover_rate_history = [self.crossover_rate]\n        self.min_archive_fitness = float('inf')  #ADDED: Minimum acceptable fitness for archive entry\n\n    def ensure_bounds(self, vec):\n        return np.clip(vec, self.lower_bounds, self.upper_bounds)\n\n    def update_archive(self, individual, fitness):\n        if fitness < np.max(self.archive_fitness) and fitness < self.min_archive_fitness:\n            worst_index = np.argmax(self.archive_fitness)\n            self.archive[worst_index] = individual\n            self.archive_fitness[worst_index] = fitness\n            self.min_archive_fitness = np.min(self.archive_fitness)\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        if self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n        else:\n            self.best_solution_overall = np.array([])\n        self.best_fitness_overall = float('inf')\n\n        # Initialize population and fitness\n        fitness_values = objective_function(self.population)\n        self.eval_count += self.population_size\n        self.fitness = fitness_values.copy()\n\n        for i in range(self.population_size):\n            if self.fitness[i] < self.best_fitness_overall:\n                self.best_fitness_overall = self.fitness[i]\n                self.best_solution_overall = self.population[i].copy()\n\n        # Initialize Archive with initial population\n        self.archive[:self.population_size] = self.population.copy()\n        self.archive_fitness[:self.population_size] = self.fitness.copy()\n        self.min_archive_fitness = np.max(self.archive_fitness) #initialize min_archive_fitness\n        self.archive_idx = self.population_size\n\n        while self.eval_count < self.budget and self.dim > 0:\n            for i in range(self.population_size):\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                if len(indices) >= 3: #Ensure we have at least 3 distinct indices from pop\n                    a, b, c = random.sample(indices, 3)\n                else:\n                    a, b, c = random.choices(indices, k = 3) #Allows replacement to proceed if len(indices) < 3\n\n                #Potentially use an archive member\n                if random.random() < 0.1: #10% chance of pulling a member from the archive\n                    arc_idx = random.randint(0, self.archive_size - 1)\n                    mutant = self.population[a] + self.mutation_factor * (self.archive[arc_idx] - self.population[b]) + self.mutation_factor * (self.population[c] - self.population[i])\n                else:\n                    mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c]) + self.mutation_factor * (self.best_solution_overall - self.population[i]) #Best solution guided mutation\n\n                mutant = self.ensure_bounds(mutant)\n                \n                # Crossover\n                trial_vector = np.zeros(self.dim)\n                for j in range(self.dim):\n                    if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):\n                        trial_vector[j] = mutant[j]\n                    else:\n                        trial_vector[j] = self.population[i][j]\n\n                trial_vector = self.ensure_bounds(trial_vector)\n\n                # Selection\n                trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector.copy()\n                    self.fitness[i] = trial_fitness\n\n                    # Update best solution\n                    if trial_fitness < self.best_fitness_overall:\n                        self.best_fitness_overall = trial_fitness\n                        self.best_solution_overall = trial_vector.copy()\n\n                    #Update Archive\n                    self.update_archive(trial_vector, trial_fitness)\n\n                    #Adaptive strategy: if improvement, increase mutation and crossover\n                    self.mutation_factor = min(1.0, self.mutation_factor * 1.1)\n                    self.crossover_rate = min(1.0, self.crossover_rate * 1.1)\n\n                else:\n                    #Decrease mutation and crossover if no improvement\n                    self.mutation_factor = max(0.1, self.mutation_factor * 0.9)\n                    self.crossover_rate = max(0.1, self.crossover_rate * 0.9)\n\n                self.mutation_factor_history.append(self.mutation_factor)\n                self.crossover_rate_history.append(self.crossover_rate)\n            worst_index = np.argmax(self.fitness)\n            self.mutation_factor = max(0.1, min(1.0, self.mutation_factor * (1 + 0.1 * np.std(self.fitness) / (self.fitness[worst_index] + 1e-8))))\n\n        if self.best_solution_overall is None and self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall,\n            'mutation_factor_history': self.mutation_factor_history,\n            'crossover_rate_history': self.crossover_rate_history\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info", "configspace": "", "generation": 13, "feedback": "The algorithm HybridDEArchiveAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.04.", "error": "", "parent_ids": ["b1d3c47e-9a51-4fe6-a970-af46cd0c63d2"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.07432979746236547]}}
{"id": "d2b22a72-b374-4bc9-b07b-15184b9f5ad1", "fitness": 0.0246609591250647, "name": "HybridDEArchiveAdaptive", "description": "Adaptive DE with archive, dynamic parameter adjustment, and a more robust mutation strategy using best-worst individual differences.", "code": "import numpy as np\nimport random\n\nclass HybridDEArchiveAdaptive:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n\n        self.population_size = int(5 + np.ceil(np.log(self.dim))) # Population scaling with dimension\n        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, float('inf'))\n\n        self.archive_size = self.population_size * 2  # Archive is larger than the population\n        self.archive = np.zeros((self.archive_size, self.dim))\n        self.archive_fitness = np.full(self.archive_size, float('inf'))\n        self.archive_idx = 0\n\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7 # Initial crossover rate\n        self.mutation_factor_history = [self.mutation_factor]\n        self.crossover_rate_history = [self.crossover_rate]\n        self.min_archive_fitness = float('inf')  #ADDED: Minimum acceptable fitness for archive entry\n\n    def ensure_bounds(self, vec):\n        return np.clip(vec, self.lower_bounds, self.upper_bounds)\n\n    def update_archive(self, individual, fitness):\n        if fitness < np.max(self.archive_fitness) and fitness < self.min_archive_fitness:\n            worst_index = np.argmax(self.archive_fitness)\n            self.archive[worst_index] = individual\n            self.archive_fitness[worst_index] = fitness\n            self.min_archive_fitness = np.min(self.archive_fitness)\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        if self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n        else:\n            self.best_solution_overall = np.array([])\n        self.best_fitness_overall = float('inf')\n\n        # Initialize population and fitness\n        fitness_values = objective_function(self.population)\n        self.eval_count += self.population_size\n        self.fitness = fitness_values.copy()\n\n        for i in range(self.population_size):\n            if self.fitness[i] < self.best_fitness_overall:\n                self.best_fitness_overall = self.fitness[i]\n                self.best_solution_overall = self.population[i].copy()\n\n        # Initialize Archive with initial population\n        self.archive[:self.population_size] = self.population.copy()\n        self.archive_fitness[:self.population_size] = self.fitness.copy()\n        self.min_archive_fitness = np.max(self.archive_fitness) #initialize min_archive_fitness\n        self.archive_idx = self.population_size\n\n        while self.eval_count < self.budget and self.dim > 0:\n            worst_index = np.argmax(self.fitness)\n            for i in range(self.population_size):\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                if len(indices) >= 3: #Ensure we have at least 3 distinct indices from pop\n                    a, b, c = random.sample(indices, 3)\n                else:\n                    a, b, c = random.choices(indices, k = 3) #Allows replacement to proceed if len(indices) < 3\n\n                #Potentially use an archive member\n                if random.random() < 0.1: #10% chance of pulling a member from the archive\n                    arc_idx = random.randint(0, self.archive_size - 1)\n                    mutant = self.population[a] + self.mutation_factor * (self.archive[arc_idx] - self.population[b]) + self.mutation_factor * (self.population[c] - self.population[i])\n                else:\n                    #mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c]) + self.mutation_factor * (self.best_solution_overall - self.population[i]) #Best solution guided mutation\n                    mutant = self.population[a] + self.mutation_factor * (self.best_solution_overall - self.population[worst_index]) + self.mutation_factor * (self.population[b] - self.population[c])\n\n                mutant = self.ensure_bounds(mutant)\n                \n                # Crossover\n                trial_vector = np.zeros(self.dim)\n                for j in range(self.dim):\n                    if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):\n                        trial_vector[j] = mutant[j]\n                    else:\n                        trial_vector[j] = self.population[i][j]\n\n                trial_vector = self.ensure_bounds(trial_vector)\n\n                # Selection\n                trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector.copy()\n                    self.fitness[i] = trial_fitness\n\n                    # Update best solution\n                    if trial_fitness < self.best_fitness_overall:\n                        self.best_fitness_overall = trial_fitness\n                        self.best_solution_overall = trial_vector.copy()\n\n                    #Update Archive\n                    self.update_archive(trial_vector, trial_fitness)\n\n                    #Adaptive strategy: if improvement, increase mutation and crossover\n                    self.mutation_factor = min(1.0, self.mutation_factor * 1.1)\n                    self.crossover_rate = min(1.0, self.crossover_rate * 1.1)\n\n                else:\n                    #Decrease mutation and crossover if no improvement\n                    self.mutation_factor = max(0.1, self.mutation_factor * 0.9)\n                    self.crossover_rate = max(0.1, self.crossover_rate * 0.9)\n\n                self.mutation_factor_history.append(self.mutation_factor)\n                self.crossover_rate_history.append(self.crossover_rate)\n            \n            self.mutation_factor = max(0.1, min(1.0, self.mutation_factor * (1 + 0.1 * np.std(self.fitness) / (self.fitness[worst_index] + 1e-8))))\n\n        if self.best_solution_overall is None and self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall,\n            'mutation_factor_history': self.mutation_factor_history,\n            'crossover_rate_history': self.crossover_rate_history\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info", "configspace": "", "generation": 14, "feedback": "The algorithm HybridDEArchiveAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["b1d3c47e-9a51-4fe6-a970-af46cd0c63d2"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.0739828773751941]}}
{"id": "30f01202-6321-4a68-b0a8-b1a558b79ab2", "fitness": 0.0239295982408053, "name": "HybridDEArchiveAdaptive", "description": "Adaptive DE with archive, dynamic parameter adjustment, and probabilistic mutation factor update based on population diversity.", "code": "import numpy as np\nimport random\n\nclass HybridDEArchiveAdaptive:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n\n        self.population_size = int(5 + np.ceil(np.log(self.dim))) # Population scaling with dimension\n        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, float('inf'))\n\n        self.archive_size = self.population_size * 2  # Archive is larger than the population\n        self.archive = np.zeros((self.archive_size, self.dim))\n        self.archive_fitness = np.full(self.archive_size, float('inf'))\n        self.archive_idx = 0\n\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7 # Initial crossover rate\n        self.mutation_factor_history = [self.mutation_factor]\n        self.crossover_rate_history = [self.crossover_rate]\n        self.min_archive_fitness = float('inf')  #ADDED: Minimum acceptable fitness for archive entry\n\n    def ensure_bounds(self, vec):\n        return np.clip(vec, self.lower_bounds, self.upper_bounds)\n\n    def update_archive(self, individual, fitness):\n        if fitness < np.max(self.archive_fitness) and fitness < self.min_archive_fitness:\n            worst_index = np.argmax(self.archive_fitness)\n            self.archive[worst_index] = individual\n            self.archive_fitness[worst_index] = fitness\n            self.min_archive_fitness = np.min(self.archive_fitness)\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        if self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n        else:\n            self.best_solution_overall = np.array([])\n        self.best_fitness_overall = float('inf')\n\n        # Initialize population and fitness\n        fitness_values = objective_function(self.population)\n        self.eval_count += self.population_size\n        self.fitness = fitness_values.copy()\n\n        for i in range(self.population_size):\n            if self.fitness[i] < self.best_fitness_overall:\n                self.best_fitness_overall = self.fitness[i]\n                self.best_solution_overall = self.population[i].copy()\n\n        # Initialize Archive with initial population\n        self.archive[:self.population_size] = self.population.copy()\n        self.archive_fitness[:self.population_size] = self.fitness.copy()\n        self.min_archive_fitness = np.max(self.archive_fitness) #initialize min_archive_fitness\n        self.archive_idx = self.population_size\n\n        while self.eval_count < self.budget and self.dim > 0:\n            for i in range(self.population_size):\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                if len(indices) >= 3: #Ensure we have at least 3 distinct indices from pop\n                    a, b, c = random.sample(indices, 3)\n                else:\n                    a, b, c = random.choices(indices, k = 3) #Allows replacement to proceed if len(indices) < 3\n\n                #Potentially use an archive member\n                if random.random() < 0.1: #10% chance of pulling a member from the archive\n                    arc_idx = random.randint(0, self.archive_size - 1)\n                    mutant = self.population[a] + self.mutation_factor * (self.archive[arc_idx] - self.population[b]) + self.mutation_factor * (self.population[c] - self.population[i])\n                else:\n                    mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c]) + self.mutation_factor * (self.best_solution_overall - self.population[i]) #Best solution guided mutation\n\n                mutant = self.ensure_bounds(mutant)\n                \n                # Crossover\n                trial_vector = np.zeros(self.dim)\n                for j in range(self.dim):\n                    if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):\n                        trial_vector[j] = mutant[j]\n                    else:\n                        trial_vector[j] = self.population[i][j]\n\n                trial_vector = self.ensure_bounds(trial_vector)\n\n                # Selection\n                trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector.copy()\n                    self.fitness[i] = trial_fitness\n\n                    # Update best solution\n                    if trial_fitness < self.best_fitness_overall:\n                        self.best_fitness_overall = trial_fitness\n                        self.best_solution_overall = trial_vector.copy()\n\n                    #Update Archive\n                    self.update_archive(trial_vector, trial_fitness)\n\n                    #Adaptive strategy: if improvement, increase mutation and crossover\n                    self.mutation_factor = min(1.0, self.mutation_factor * 1.1)\n                    self.crossover_rate = min(1.0, self.crossover_rate * 1.1)\n\n                else:\n                    #Decrease mutation and crossover if no improvement\n                    self.mutation_factor = max(0.1, self.mutation_factor * 0.9)\n                    self.crossover_rate = max(0.1, self.crossover_rate * 0.9)\n\n                self.mutation_factor_history.append(self.mutation_factor)\n                self.crossover_rate_history.append(self.crossover_rate)\n            \n            if random.random() < 0.2: #Probabilistic update of mutation factor based on diversity\n                self.mutation_factor = max(0.1, min(1.0, self.mutation_factor * (1 + 0.1 * np.std(self.fitness) / (np.mean(self.fitness) + 1e-8))))\n\n        if self.best_solution_overall is None and self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall,\n            'mutation_factor_history': self.mutation_factor_history,\n            'crossover_rate_history': self.crossover_rate_history\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info", "configspace": "", "generation": 15, "feedback": "The algorithm HybridDEArchiveAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["b1d3c47e-9a51-4fe6-a970-af46cd0c63d2"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.0717887947224159]}}
{"id": "667934e1-150d-4a13-999d-321c16f20a60", "fitness": 0.024361802942406658, "name": "HybridDEArchiveAdaptive", "description": "Adaptive DE with archive and orthogonal learning, dynamically adjusts parameters and incorporates orthogonal design for enhanced exploration.", "code": "import numpy as np\nimport random\n\nclass HybridDEArchiveAdaptive:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n\n        self.population_size = int(5 + np.ceil(np.log(self.dim))) # Population scaling with dimension\n        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, float('inf'))\n\n        self.archive_size = self.population_size * 2  # Archive is larger than the population\n        self.archive = np.zeros((self.archive_size, self.dim))\n        self.archive_fitness = np.full(self.archive_size, float('inf'))\n        self.archive_idx = 0\n\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7 # Initial crossover rate\n        self.mutation_factor_history = [self.mutation_factor]\n        self.crossover_rate_history = [self.crossover_rate]\n        self.min_archive_fitness = float('inf')  #ADDED: Minimum acceptable fitness for archive entry\n\n    def ensure_bounds(self, vec):\n        return np.clip(vec, self.lower_bounds, self.upper_bounds)\n\n    def update_archive(self, individual, fitness):\n        if fitness < np.max(self.archive_fitness) and fitness < self.min_archive_fitness:\n            worst_index = np.argmax(self.archive_fitness)\n            self.archive[worst_index] = individual\n            self.archive_fitness[worst_index] = fitness\n            self.min_archive_fitness = np.min(self.archive_fitness)\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        if self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n        else:\n            self.best_solution_overall = np.array([])\n        self.best_fitness_overall = float('inf')\n\n        # Initialize population and fitness\n        fitness_values = objective_function(self.population)\n        self.eval_count += self.population_size\n        self.fitness = fitness_values.copy()\n\n        for i in range(self.population_size):\n            if self.fitness[i] < self.best_fitness_overall:\n                self.best_fitness_overall = self.fitness[i]\n                self.best_solution_overall = self.population[i].copy()\n\n        # Initialize Archive with initial population\n        self.archive[:self.population_size] = self.population.copy()\n        self.archive_fitness[:self.population_size] = self.fitness.copy()\n        self.min_archive_fitness = np.max(self.archive_fitness) #initialize min_archive_fitness\n        self.archive_idx = self.population_size\n\n        while self.eval_count < self.budget and self.dim > 0:\n            for i in range(self.population_size):\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                if len(indices) >= 3: #Ensure we have at least 3 distinct indices from pop\n                    a, b, c = random.sample(indices, 3)\n                else:\n                    a, b, c = random.choices(indices, k = 3) #Allows replacement to proceed if len(indices) < 3\n\n                #Potentially use an archive member\n                if random.random() < 0.1: #10% chance of pulling a member from the archive\n                    arc_idx = random.randint(0, self.archive_size - 1)\n                    mutant = self.population[a] + self.mutation_factor * (self.archive[arc_idx] - self.population[b]) + self.mutation_factor * (self.population[c] - self.population[i])\n                else:\n                    mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c]) + self.mutation_factor * (self.best_solution_overall - self.population[i]) #Best solution guided mutation\n\n                mutant = self.ensure_bounds(mutant)\n                \n                # Crossover\n                trial_vector = np.zeros(self.dim)\n                for j in range(self.dim):\n                    if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):\n                        trial_vector[j] = mutant[j]\n                    else:\n                        trial_vector[j] = self.population[i][j]\n\n                trial_vector = self.ensure_bounds(trial_vector)\n\n                # Selection\n                trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector.copy()\n                    self.fitness[i] = trial_fitness\n\n                    # Update best solution\n                    if trial_fitness < self.best_fitness_overall:\n                        self.best_fitness_overall = trial_fitness\n                        self.best_solution_overall = trial_vector.copy()\n\n                    #Update Archive\n                    self.update_archive(trial_vector, trial_fitness)\n\n                    #Adaptive strategy: if improvement, increase mutation and crossover\n                    self.mutation_factor = min(1.0, self.mutation_factor * 1.1)\n                    self.crossover_rate = min(1.0, self.crossover_rate * 1.1)\n\n                else:\n                    #Decrease mutation and crossover if no improvement\n                    self.mutation_factor = max(0.1, self.mutation_factor * 0.9)\n                    self.crossover_rate = max(0.1, self.crossover_rate * 0.9)\n\n                self.mutation_factor_history.append(self.mutation_factor)\n                self.crossover_rate_history.append(self.crossover_rate)\n            worst_index = np.argmax(self.fitness)\n            self.mutation_factor = max(0.1, min(1.0, self.mutation_factor * (1 + 0.1 * np.std(self.fitness) / (self.fitness[worst_index] + 1e-8))))\n\n        if self.best_solution_overall is None and self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall,\n            'mutation_factor_history': self.mutation_factor_history,\n            'crossover_rate_history': self.crossover_rate_history\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info", "configspace": "", "generation": 16, "feedback": "The algorithm HybridDEArchiveAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["b1d3c47e-9a51-4fe6-a970-af46cd0c63d2"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.07308540882721998]}}
{"id": "f75f4ed2-c7cb-4887-89d7-07d2ad3b9ee1", "fitness": 0.022745422435239648, "name": "HybridDEArchiveAdaptive", "description": "Implements DE with archive, adaptive mutation and crossover rates, focusing on adjusting mutation based on overall population fitness standard deviation.", "code": "import numpy as np\nimport random\n\nclass HybridDEArchiveAdaptive:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n\n        self.population_size = int(5 + np.ceil(np.log(self.dim))) # Population scaling with dimension\n        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, float('inf'))\n\n        self.archive_size = self.population_size * 2  # Archive is larger than the population\n        self.archive = np.zeros((self.archive_size, self.dim))\n        self.archive_fitness = np.full(self.archive_size, float('inf'))\n        self.archive_idx = 0\n\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7 # Initial crossover rate\n        self.mutation_factor_history = [self.mutation_factor]\n        self.crossover_rate_history = [self.crossover_rate]\n        self.min_archive_fitness = float('inf')  #ADDED: Minimum acceptable fitness for archive entry\n\n    def ensure_bounds(self, vec):\n        return np.clip(vec, self.lower_bounds, self.upper_bounds)\n\n    def update_archive(self, individual, fitness):\n        if fitness < np.max(self.archive_fitness) and fitness < self.min_archive_fitness:\n            worst_index = np.argmax(self.archive_fitness)\n            self.archive[worst_index] = individual\n            self.archive_fitness[worst_index] = fitness\n            self.min_archive_fitness = np.min(self.archive_fitness)\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        if self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n        else:\n            self.best_solution_overall = np.array([])\n        self.best_fitness_overall = float('inf')\n\n        # Initialize population and fitness\n        fitness_values = objective_function(self.population)\n        self.eval_count += self.population_size\n        self.fitness = fitness_values.copy()\n\n        for i in range(self.population_size):\n            if self.fitness[i] < self.best_fitness_overall:\n                self.best_fitness_overall = self.fitness[i]\n                self.best_solution_overall = self.population[i].copy()\n\n        # Initialize Archive with initial population\n        self.archive[:self.population_size] = self.population.copy()\n        self.archive_fitness[:self.population_size] = self.fitness.copy()\n        self.min_archive_fitness = np.max(self.archive_fitness) #initialize min_archive_fitness\n        self.archive_idx = self.population_size\n\n        while self.eval_count < self.budget and self.dim > 0:\n            for i in range(self.population_size):\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                if len(indices) >= 3: #Ensure we have at least 3 distinct indices from pop\n                    a, b, c = random.sample(indices, 3)\n                else:\n                    a, b, c = random.choices(indices, k = 3) #Allows replacement to proceed if len(indices) < 3\n\n                #Potentially use an archive member\n                if random.random() < 0.1: #10% chance of pulling a member from the archive\n                    arc_idx = random.randint(0, self.archive_size - 1)\n                    mutant = self.population[a] + self.mutation_factor * (self.archive[arc_idx] - self.population[b]) + self.mutation_factor * (self.population[c] - self.population[i])\n                else:\n                    mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c]) + self.mutation_factor * (self.best_solution_overall - self.population[i]) #Best solution guided mutation\n\n                mutant = self.ensure_bounds(mutant)\n                \n                # Crossover\n                trial_vector = np.zeros(self.dim)\n                for j in range(self.dim):\n                    if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):\n                        trial_vector[j] = mutant[j]\n                    else:\n                        trial_vector[j] = self.population[i][j]\n\n                trial_vector = self.ensure_bounds(trial_vector)\n\n                # Selection\n                trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector.copy()\n                    self.fitness[i] = trial_fitness\n\n                    # Update best solution\n                    if trial_fitness < self.best_fitness_overall:\n                        self.best_fitness_overall = trial_fitness\n                        self.best_solution_overall = trial_vector.copy()\n\n                    #Update Archive\n                    self.update_archive(trial_vector, trial_fitness)\n\n                    #Adaptive strategy: if improvement, increase mutation and crossover\n                    self.mutation_factor = min(1.0, self.mutation_factor * 1.1)\n                    self.crossover_rate = min(1.0, self.crossover_rate * 1.1)\n\n                else:\n                    #Decrease mutation and crossover if no improvement\n                    self.mutation_factor = max(0.1, self.mutation_factor * 0.9)\n                    self.crossover_rate = max(0.1, self.crossover_rate * 0.9)\n\n                self.mutation_factor_history.append(self.mutation_factor)\n                self.crossover_rate_history.append(self.crossover_rate)\n            \n            self.mutation_factor = max(0.1, min(1.0, self.mutation_factor * (1 + 0.1 * np.std(self.fitness) / (np.mean(self.fitness) + 1e-8))))\n\n        if self.best_solution_overall is None and self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall,\n            'mutation_factor_history': self.mutation_factor_history,\n            'crossover_rate_history': self.crossover_rate_history\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info", "configspace": "", "generation": 17, "feedback": "The algorithm HybridDEArchiveAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02 with standard deviation 0.03.", "error": "", "parent_ids": ["b1d3c47e-9a51-4fe6-a970-af46cd0c63d2"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.06823626730571894]}}
{"id": "45a4a09c-a96a-46e6-97ab-6a87130e6643", "fitness": -Infinity, "name": "HybridDEArchiveAdaptive", "description": "Adaptive DE with archive and dynamic parameter adjustment, focusing mutation adaptation on worst performers.", "code": "import numpy as np\nimport random\n\nclass HybridDEArchiveAdaptive:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n\n        self.population_size = int(5 + np.ceil(np.log(self.dim))) # Population scaling with dimension\n        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, float('inf'))\n\n        self.archive_size = self.population_size * 2  # Archive is larger than the population\n        self.archive = np.zeros((self.archive_size, self.dim))\n        self.archive_fitness = np.full(self.archive_size, float('inf'))\n        self.archive_idx = 0\n\n        self.mutation_factor = 0.5  # Initial mutation factor\n        self.crossover_rate = 0.7 # Initial crossover rate\n        self.mutation_factor_history = [self.mutation_factor]\n        self.crossover_rate_history = [self.crossover_rate]\n        self.min_archive_fitness = float('inf')  #ADDED: Minimum acceptable fitness for archive entry\n\n    def ensure_bounds(self, vec):\n        return np.clip(vec, self.lower_bounds, self.upper_bounds)\n\n    def update_archive(self, individual, fitness):\n        if fitness < np.max(self.archive_fitness) and fitness < self.min_archive_fitness:\n            worst_index = np.argmax(self.archive_fitness)\n            self.archive[worst_index] = individual\n            self.archive_fitness[worst_index] = fitness\n            self.min_archive_fitness = np.min(self.archive_fitness)\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        if self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n        else:\n            self.best_solution_overall = np.array([])\n        self.best_fitness_overall = float('inf')\n\n        # Initialize population and fitness\n        fitness_values = objective_function(self.population)\n        self.eval_count += self.population_size\n        self.fitness = fitness_values.copy()\n\n        for i in range(self.population_size):\n            if self.fitness[i] < self.best_fitness_overall:\n                self.best_fitness_overall = self.fitness[i]\n                self.best_solution_overall = self.population[i].copy()\n\n        # Initialize Archive with initial population\n        self.archive[:self.population_size] = self.population.copy()\n        self.archive_fitness[:self.population_size] = self.fitness.copy()\n        self.min_archive_fitness = np.max(self.archive_fitness) #initialize min_archive_fitness\n        self.archive_idx = self.population_size\n\n        while self.eval_count < self.budget and self.dim > 0:\n            for i in range(self.population_size):\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                if len(indices) >= 3: #Ensure we have at least 3 distinct indices from pop\n                    a, b, c = random.sample(indices, 3)\n                else:\n                    a, b, c = random.choices(indices, k = 3) #Allows replacement to proceed if len(indices) < 3\n\n                #Potentially use an archive member\n                if random.random() < 0.1: #10% chance of pulling a member from the archive\n                    arc_idx = random.randint(0, self.archive_size - 1)\n                    mutant = self.population[a] + self.mutation_factor * (self.archive[arc_idx] - self.population[b]) + self.mutation_factor * (self.population[c] - self.population[i])\n                else:\n                    mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c]) + self.mutation_factor * (self.best_solution_overall - self.population[i]) #Best solution guided mutation\n\n                mutant = self.ensure_bounds(mutant)\n                \n                # Crossover\n                trial_vector = np.zeros(self.dim)\n                for j in range(self.dim):\n                    if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):\n                        trial_vector[j] = mutant[j]\n                    else:\n                        trial_vector[j] = self.population[i][j]\n\n                trial_vector = self.ensure_bounds(trial_vector)\n\n                # Selection\n                trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector.copy()\n                    self.fitness[i] = trial_fitness\n\n                    # Update best solution\n                    if trial_fitness < self.best_fitness_overall:\n                        self.best_fitness_overall = trial_fitness\n                        self.best_solution_overall = trial_vector.copy()\n\n                    #Update Archive\n                    self.update_archive(trial_vector, trial_fitness)\n\n                    #Adaptive strategy: if improvement, increase mutation and crossover\n                    self.mutation_factor = min(1.0, self.mutation_factor * 1.1)\n                    self.crossover_rate = min(1.0, self.crossover_rate * 1.1)\n\n                else:\n                    #Decrease mutation and crossover if no improvement\n                    self.mutation_factor = max(0.1, self.mutation_factor * 0.9)\n                    self.crossover_rate = max(0.1, self.crossover_rate * 0.9)\n\n                self.mutation_factor_history.append(self.mutation_factor)\n                self.crossover_rate_history.append(self.crossover_rate)\n            worst_index = np.argmax(self.fitness)\n            self.mutation_factor = max(0.1, min(1.0, self.mutation_factor * (1 + 0.1 * np.std(self.fitness) / (self.fitness[worst_index] + 1e-8))))\n\n        if self.best_solution_overall is None and self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall,\n            'mutation_factor_history': self.mutation_factor_history,\n            'crossover_rate_history': self.crossover_rate_history\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info", "configspace": "", "generation": 6, "feedback": "An exception occurred: NoCodeException().", "error": "NoCodeException()", "parent_ids": ["b1d3c47e-9a51-4fe6-a970-af46cd0c63d2"], "operator": "Refine the strategy of the selected solution to improve it. \nMake sure you only change 1.5% of the code, which means if the code has 100 lines, you can only change 1.5151515151515151 lines, and the rest of the lines should remain unchanged. \nThis input code has 132 lines, so you can only change 2 lines, the rest 130 lines should remain unchanged. \nThis changing rate 1.5% is a mandatory requirement, you cannot change more or less than this rate.\n", "metadata": {"aucs": [0.0, 0.0, 0.07681031609690307]}}
