2025-06-25 10:52:50 INFO Initializing first population
2025-06-25 10:52:50 INFO Initializing population from 4 seed files...
2025-06-25 11:30:49 INFO Started evolutionary loop, best so far: 0.09552206708307738
2025-06-25 11:30:49 INFO Population length is: 15
2025-06-25 11:30:49 INFO --- Performing Long-Term Reflection at Generation 1 ---
2025-06-25 11:30:49 INFO Reflection Prompt: ### Problem Description
**(CR: Capacity and Role)**
Act as an expert in designing algorithms for deceptive, multi-component landscapes. Your specialty is creating strategies that use multi-population or island models to perform aggressive global exploration.

**(I: Insight)**
Your objective is to design a novel optimization algorithm for the GNBG benchmark. The most difficult functions (f16-f24) have multiple, separate basins of attraction where the global optimum can be hidden. An algorithm must be able to discover and explore these competing regions to succeed.

**(S: Statement & P: Personality)**
Provide a complete, novel Python class that implements a multi-population or island-based search strategy to solve this challenge. The class must have an `__init__(...)` and `optimize(...)` method as specified in the main task description.

### List heuristics
Below is a list of design heuristics ranked from best to worst based on their AOCC score on group function 3 of GNBG benchmark, where higher is better. To enable a detailed analysis of their specializations, the performance breakdown on each of the three GNBG function groups is also provided.
### Rank 1 (Overall AOCC Score on Multimodal instances with multiple components: 9.5522e-02# Name: IslandModelDifferentialEvolution
# Description: Uses an island model with differential evolution to explore separate basins of attraction aggressively.
# Code:
```python
import numpy as np
import random

# Name: IslandModelDifferentialEvolution
# Description: Uses an island model with differential evolution to explore separate basins of attraction aggressively.
# Code:
class IslandModelDifferentialEvolution:
    """
    A multi-population (island model) differential evolution algorithm.
    Designed to handle deceptive, multi-component landscapes by independently
    exploring multiple regions and periodically exchanging information.
    """

    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 500, migration_size: int = 2):
        """
        Initializes the IslandModelDifferentialEvolution optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values


    def migrate(self):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants
            # Re-evaluate the fitness of the new solutions on the destination island (important!)
            new_fitness = []
            for j in range(len(worst_indices)):
              migrant_reshaped = migrants[j].reshape(1,-1)
              new_fitness.append(float(objective_function(migrant_reshaped)))
              self.eval_count += 1

            dest_island_fitness[worst_indices] = new_fitness
            self.fitness_values[dest_island] = dest_island_fitness
             # Update best fitness, if needed
            for fit, sol in zip(new_fitness, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol




    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate()



        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

if __name__ == '__main__':
    # Example usage (replace with your actual objective function and problem setup)
    def objective_function(X: np.ndarray) -> np.ndarray:
        """A sample objective function (sphere function)."""
        return np.sum(X**2, axis=1)

    budget = 10000
    dim = 30
    lower_bounds = [-100.0] * dim
    upper_bounds = [100.0] * dim

    optimizer = IslandModelDifferentialEvolution(budget=budget, dim=dim, lower_bounds=lower_bounds,
                                                  upper_bounds=upper_bounds, num_islands=5)
    best_solution, best_fitness, optimization_info = optimizer.optimize(objective_function)

    print("Best Solution:", best_solution)
    print("Best Fitness:", best_fitness)
    print("Optimization Info:", optimization_info)
```

### Rank 2 (Overall AOCC Score on Multimodal instances with multiple components: 8.7202e-02# Name: IslandBasedDifferentialEvolution
# Description: Uses an island model with Differential Evolution on each island, and periodically migrates the best individuals between islands to encourage global exploration.
# Code:
```python
import numpy as np
import random

# Name: IslandBasedDifferentialEvolution
# Description: Uses an island model with Differential Evolution on each island, and periodically migrates the best individuals between islands to encourage global exploration.
# Code:
class IslandBasedDifferentialEvolution:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float], num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7, mutation_factor: float = 0.5, migration_interval: int = 500, migration_size: int = 2):
        """
        Initializes the IslandBasedDifferentialEvolution algorithm.

        Args:
            budget: Maximum number of function evaluations.
            dim: Problem dimensionality.
            lower_bounds: List of lower bounds for each dimension.
            upper_bounds: List of upper bounds for each dimension.
            num_islands: Number of islands in the archipelago.
            population_size: Number of individuals in each island's population.
            crossover_rate: Crossover rate for Differential Evolution.
            mutation_factor: Mutation factor for Differential Evolution.
            migration_interval: Number of evaluations between migrations.
            migration_size: Number of individuals to migrate between islands.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_factor = mutation_factor
        self.migration_interval = migration_interval
        self.migration_size = migration_size

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize islands and their populations
        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            self.islands.append(population)

        # Island specific best solutions
        self.island_best_solutions = [None] * self.num_islands
        self.island_best_fitness = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable) -> None:
        """
        Performs one step of Differential Evolution on a given island.

        Args:
            island_index: Index of the island to perform DE on.
            objective_function: The objective function to be minimized.
        """
        population = self.islands[island_index]
        fitness_values = objective_function(population)
        self.eval_count += self.population_size

        if np.min(fitness_values) < self.island_best_fitness[island_index]:
            best_index = np.argmin(fitness_values)
            self.island_best_fitness[island_index] = fitness_values[best_index]
            self.island_best_solutions[island_index] = population[best_index].copy()

            if self.island_best_fitness[island_index] < self.best_fitness_overall:
                self.best_fitness_overall = self.island_best_fitness[island_index]
                self.best_solution_overall = self.island_best_solutions[island_index].copy()

        for i in range(self.population_size):
            # Choose three random individuals, distinct from each other and the current individual
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)

            # Mutation
            mutant = population[a] + self.mutation_factor * (population[b] - population[c])

            # Ensure the mutant stays within bounds
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

            # Crossover
            crossover_mask = np.random.rand(self.dim) < self.crossover_rate
            trial_vector = np.where(crossover_mask, mutant, population[i])

            # Evaluate the trial vector
            trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]
            self.eval_count += 1  # Increment eval_count for the single evaluation

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                if trial_fitness < self.island_best_fitness[island_index]:
                    self.island_best_fitness[island_index] = trial_fitness
                    self.island_best_solutions[island_index] = trial_vector.copy()

                    if trial_fitness < self.best_fitness_overall:
                        self.best_fitness_overall = trial_fitness
                        self.best_solution_overall = trial_vector.copy()


        self.islands[island_index] = population  # Update population

    def migrate_individuals(self) -> None:
        """
        Migrates the best individuals between islands.
        """
        # Find the best individuals on each island
        best_indices = np.argsort(self.island_best_fitness)

        # For each island, migrate some of the best individuals to other random islands
        for i in range(self.num_islands):
            # Select random target islands (excluding the current island)
            possible_targets = list(range(self.num_islands))
            possible_targets.remove(i)
            if not possible_targets:
              continue # no islands to migrate to

            target_islands = random.sample(possible_targets, min(len(possible_targets), self.migration_size))

            # Migrate the best solution from current island to target islands
            for target_island in target_islands:
                # Replace a random individual in the target island with the best from the current island
                replace_index = random.randint(0, self.population_size - 1)
                self.islands[target_island][replace_index] = self.island_best_solutions[i].copy()

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the objective function using Island-based Differential Evolution.

        Args:
            objective_function: The objective function to be minimized.
            acceptance_threshold: Threshold for early stopping (not used in this implementation).

        Returns:
            A tuple containing the best solution, best fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run

        # Initialize islands
        for i in range(self.num_islands):
          fitness_values = objective_function(self.islands[i])
          self.eval_count += self.population_size

          best_index = np.argmin(fitness_values)
          self.island_best_fitness[i] = fitness_values[best_index]
          self.island_best_solutions[i] = self.islands[i][best_index].copy()

          if self.island_best_fitness[i] < self.best_fitness_overall:
              self.best_fitness_overall = self.island_best_fitness[i]
              self.best_solution_overall = self.island_best_solutions[i].copy()



        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            # Migrate individuals between islands periodically
            if self.eval_count % self.migration_interval == 0 and self.eval_count > 0:
                self.migrate_individuals()

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 3 (Overall AOCC Score on Multimodal instances with multiple components: 2.9901e-02# Name: IslandModelDifferentialEvolution
# Description: Implements an island model DE with migration and restarts for aggressive global exploration.
# Code:
```python
import numpy as np
import random

# Name: IslandModelDifferentialEvolution
# Description: Implements an island model DE with migration and restarts for aggressive global exploration.
# Code:
class IslandModelDifferentialEvolution:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float], num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7, differential_weight: float = 0.5, migration_interval: int = 5000, migration_size: int = 2):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.differential_weight = differential_weight
        self.migration_interval = migration_interval #Function evaluation intervals
        self.migration_size = migration_size

        self.islands = []
        self.island_best_solutions = []
        self.island_best_fitnesses = []

        for _ in range(self.num_islands):
            population = np.random.uniform(low=self.lower_bounds, high=self.upper_bounds, size=(self.population_size, self.dim))
            self.islands.append(population)
            self.island_best_solutions.append(None)
            self.island_best_fitnesses.append(float('inf'))
    

    def differential_evolution_step(self, island_index: int, objective_function: callable):
        population = self.islands[island_index]
        new_population = np.copy(population)  # Avoid modifying original population directly
        
        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)

            mutant = population[a] + self.differential_weight * (population[b] - population[c])
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

            # Crossover
            crossover_mask = np.random.rand(self.dim) < self.crossover_rate
            trial_vector = np.where(crossover_mask, mutant, population[i])

            # Evaluation
            fitness_trial = objective_function(trial_vector.reshape(1, -1))[0]
            self.eval_count += 1

            if fitness_trial < self.island_best_fitnesses[island_index]:
                self.island_best_fitnesses[island_index] = fitness_trial
                self.island_best_solutions[island_index] = trial_vector
                
                if fitness_trial < self.best_fitness_overall:
                    self.best_fitness_overall = fitness_trial
                    self.best_solution_overall = trial_vector.copy()
            
            fitness_individual = objective_function(population[i].reshape(1, -1))[0]  # Recalculate fitness
            self.eval_count += 1
           

            # Selection
            if fitness_trial < fitness_individual:
                new_population[i] = trial_vector
                
            else:
                 new_population[i] = population[i]

        self.islands[island_index] = new_population
        return


    def migrate(self):
        #Simple migration: exchange best solutions between random islands
        island_indices = list(range(self.num_islands))
        random.shuffle(island_indices)

        for i in range(0, self.num_islands, 2):
            if i + 1 < self.num_islands:
                island1_idx = island_indices[i]
                island2_idx = island_indices[i+1]

                #Exchange migration_size best solutions from island1 to island2 and vice versa
                sorted_indices_island1 = np.argsort(self.island_best_fitnesses[island1_idx])
                sorted_indices_island2 = np.argsort(self.island_best_fitnesses[island2_idx])


                self.islands[island1_idx][:self.migration_size] = np.array([self.best_solution_overall])  
                self.islands[island2_idx][:self.migration_size] = np.array([self.best_solution_overall]) #Simplification since it's difficult to access current populations

                #Update also best fitness and best solution
                fitness_island1 = objective_function(self.islands[island1_idx][0:1])[0]
                self.eval_count += 1

                fitness_island2 = objective_function(self.islands[island2_idx][0:1])[0]
                self.eval_count += 1

                self.island_best_solutions[island1_idx] = self.islands[island1_idx][0]
                self.island_best_fitnesses[island1_idx] = fitness_island1
                
                self.island_best_solutions[island2_idx] = self.islands[island2_idx][0]
                self.island_best_fitnesses[island2_idx] = fitness_island2



    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0 # Reset for this run
        self.best_fitness_overall = float('inf')
        self.best_solution_overall = np.random.uniform(low=self.lower_bounds, high=self.upper_bounds, size=self.dim)

        #Initialize island bests
        for island_index in range(self.num_islands):
             island_fitnesses = objective_function(self.islands[island_index])
             self.eval_count += self.population_size # Evaluate each island once.
             best_index = np.argmin(island_fitnesses)
             self.island_best_fitnesses[island_index] = island_fitnesses[best_index]
             self.island_best_solutions[island_index] = self.islands[island_index][best_index]

             if self.island_best_fitnesses[island_index] < self.best_fitness_overall:
                 self.best_fitness_overall = self.island_best_fitnesses[island_index]
                 self.best_solution_overall = self.island_best_solutions[island_index].copy()
           

        while self.eval_count < self.budget:
            for island_index in range(self.num_islands):
                self.differential_evolution_step(island_index, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate()

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * 0.95:  # Restart towards the end
                for island_index in range(self.num_islands):
                    self.islands[island_index] = np.random.uniform(low=self.lower_bounds, high=self.upper_bounds, size=(self.population_size, self.dim))
                    island_fitnesses = objective_function(self.islands[island_index])
                    self.eval_count += self.population_size
                    best_index = np.argmin(island_fitnesses)
                    self.island_best_fitnesses[island_index] = island_fitnesses[best_index]
                    self.island_best_solutions[island_index] = self.islands[island_index][best_index]
                    if self.island_best_fitnesses[island_index] < self.best_fitness_overall:
                        self.best_fitness_overall = self.island_best_fitnesses[island_index]
                        self.best_solution_overall = self.islands[island_index][best_index].copy()

                
        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 4 (Overall AOCC Score on Multimodal instances with multiple components: 2.3947e-02# Name: IslandModelDifferentialEvolution
# Description: Explores multimodal landscapes by using multiple isolated populations (islands) that evolve independently with periodic migration.
# Code:
```python
import numpy as np
import random


class IslandModelDifferentialEvolution:
    """
    A multi-island differential evolution algorithm designed to explore multimodal landscapes
    by evolving separate populations with periodic migration to share information between islands.
    """

    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 5000, migration_size: int = 2):
        """
        Initializes the IslandModelDifferentialEvolution algorithm.

        Args:
            budget (int): The total function evaluation budget.
            dim (int): The dimensionality of the problem.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): The number of isolated populations (islands).
            population_size (int): The number of individuals within each island.
            crossover_rate (float): The probability of crossover between individuals.
            mutation_rate (float): The mutation scaling factor (F) in DE.
            migration_interval (int): Number of evaluations between migration events.
            migration_size (int): Number of individuals to migrate between islands.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution.

        Args:
            objective_function (callable): The objective function to minimize.  Takes a 2D NumPy array of shape (N, dim) as input,
                                           where each row represents a solution vector, and returns a 1D NumPy array of N fitness values.
            acceptance_threshold (float): An optional threshold for early stopping.

        Returns:
            tuple: A tuple containing the best solution found (1D numpy array), its fitness (float),
                   and a dictionary containing optimization information.
        """
        self.eval_count = 0
        best_solution_overall = None
        best_fitness_overall = float('inf')

        # Initial evaluation of populations
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size

            # Update overall best
            best_index = np.argmin(self.fitness_values[i])
            if self.fitness_values[i][best_index] < best_fitness_overall:
                best_fitness_overall = self.fitness_values[i][best_index]
                best_solution_overall = self.populations[i][best_index].copy()

        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                # Differential Evolution loop for each island
                for j in range(self.population_size):
                    # Mutation
                    indices = list(range(self.population_size))
                    indices.remove(j)
                    a, b, c = random.sample(indices, 3)
                    mutant = self.populations[i][a] + self.mutation_rate * (self.populations[i][b] - self.populations[i][c])
                    mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)  # Keep within bounds

                    # Crossover
                    trial_vector = np.copy(self.populations[i][j])
                    for k in range(self.dim):
                        if random.random() < self.crossover_rate or k == random.randint(0, self.dim - 1):
                            trial_vector[k] = mutant[k]

                    # Evaluation
                    trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]
                    self.eval_count += 1

                    # Selection
                    if trial_fitness < self.fitness_values[i][j]:
                        self.fitness_values[i][j] = trial_fitness
                        self.populations[i][j] = trial_vector

                        # Update overall best
                        if trial_fitness < best_fitness_overall:
                            best_fitness_overall = trial_fitness
                            best_solution_overall = trial_vector.copy()
                            #Early stopping check
                            if abs(best_fitness_overall) <= acceptance_threshold:
                                optimization_info = {
                                    'function_evaluations_used': self.eval_count,
                                    'final_best_fitness': best_fitness_overall
                                }
                                return best_solution_overall, best_fitness_overall, optimization_info

            # Migration
            if self.eval_count // self.migration_interval > (self.eval_count - self.population_size * self.num_islands) // self.migration_interval:  # Only migrate once per interval
                self.migrate()

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': best_fitness_overall
        }
        return best_solution_overall, best_fitness_overall, optimization_info

    def migrate(self):
        """
        Implements the migration of individuals between islands.
        Selects the best individuals from each island and exchanges them with random individuals from other islands.
        """
        for i in range(self.num_islands):
            # Select the best individuals from each island
            best_indices = np.argsort(self.fitness_values[i])[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()

            # Choose a random destination island (excluding the current island)
            destination_island = random.choice([x for x in range(self.num_islands) if x != i])

            # Replace randomly selected individuals in the destination island with the migrants
            random_indices = random.sample(range(self.population_size), self.migration_size)
            self.populations[destination_island][random_indices] = migrants


# Example Usage (with dummy objective function)
if __name__ == '__main__':
    def dummy_objective(X):
        """A simple dummy objective function for testing."""
        return np.sum(X**2, axis=1)

    budget = 10000
    dim = 30
    lower_bounds = [-100.0] * dim
    upper_bounds = [100.0] * dim

    optimizer = IslandModelDifferentialEvolution(budget=budget, dim=dim, lower_bounds=lower_bounds, upper_bounds=upper_bounds, num_islands=5)

    best_solution, best_fitness, optimization_info = optimizer.optimize(dummy_objective)

    print("Best Solution:", best_solution)
    print("Best Fitness:", best_fitness)
    print("Function Evaluations Used:", optimization_info['function_evaluations_used'])
```

### Rank 5 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptivePopulationDE
# Description: Seed from AdaptivePopulationDE
# Code:
```python
import numpy as np
import random
# f18 aocc 0.8
# f20 aocc 0.5
# not so good again, get stuck in local optima
class AdaptivePopulationDE: 
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.population_size = 10 * self.dim
        self.min_population_size = 5 * self.dim
        self.max_population_size = 20 * self.dim
        self.population_adaptation_rate = 0.1

        self.F = 0.5  # Mutation factor
        self.Cr = 0.7 # Crossover rate

        self.stagnation_counter = 0
        self.stagnation_threshold = 5000

        self.archive = []
        self.archive_size = 100

        self.population = None
        self.fitness = None

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.stagnation_counter = 0

        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        self.fitness = objective_function(self.population)
        self.eval_count += self.population_size

        best_index = np.argmin(self.fitness)
        self.best_solution_overall = self.population[best_index]
        self.best_fitness_overall = self.fitness[best_index]

        while self.eval_count < self.budget:
            offspring = self.generate_offspring(objective_function)
            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            self.update_archive(offspring, offspring_fitness)

            for i in range(self.population_size):
                if offspring_fitness[i] < self.fitness[i]:
                    self.population[i] = offspring[i]
                    self.fitness[i] = offspring_fitness[i]

            best_index = np.argmin(self.fitness)
            if self.fitness[best_index] < self.best_fitness_overall:
                self.best_solution_overall = self.population[best_index]
                self.best_fitness_overall = self.fitness[best_index]
                self.stagnation_counter = 0
            else:
                self.stagnation_counter += len(offspring)

            self.adjust_population_size(objective_function)

            if self.stagnation_counter > self.stagnation_threshold:
                self.restart_population(objective_function)
                self.stagnation_counter = 0

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'population_size': self.population_size
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def generate_offspring(self, objective_function):
        offspring = np.zeros((self.population_size, self.dim))

        for i in range(self.population_size):
            indices = list(range(self.population_size))
            indices.remove(i)
            if len(indices) < 2:
                continue  # Skip if not enough individuals

            a, b = random.sample(indices, 2)

            if self.archive and random.random() < 0.5:
                pbest = self.archive[random.randint(0, len(self.archive) - 1)][0]
            else:
                pbest = self.population[np.argmin(self.fitness)]

            mutant = self.population[i] + self.F * (pbest - self.population[i] + self.population[a] - self.population[b])

            for j in range(self.dim):
                if random.random() > self.Cr:
                    mutant[j] = self.population[i][j]

            offspring[i] = np.clip(mutant, self.lower_bounds, self.upper_bounds)

        return offspring

    def update_archive(self, offspring, offspring_fitness):
        for i in range(len(offspring)):
            if len(self.archive) < self.archive_size:
                self.archive.append((offspring[i], offspring_fitness[i]))
            else:
                worst_index = np.argmax([f for _, f in self.archive])
                if offspring_fitness[i] < self.archive[worst_index][1] or len(self.archive) < self.archive_size * 0.8:
                    self.archive[worst_index] = (offspring[i], offspring_fitness[i])

    def adjust_population_size(self, objective_function):
        if random.random() < self.population_adaptation_rate:
            if self.stagnation_counter > self.stagnation_threshold / 2:
                new_size = min(int(self.population_size * 1.1), self.max_population_size)
            else:
                new_size = max(int(self.population_size * 0.9), self.min_population_size)

            new_size = int(new_size)
            if new_size > self.population_size:
                additional = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(new_size - self.population_size, self.dim))
                additional_fitness = objective_function(additional)
                self.population = np.vstack((self.population, additional))
                self.fitness = np.concatenate((self.fitness, additional_fitness))
                self.eval_count += len(additional)
            elif new_size < self.population_size:
                best_indices = np.argsort(self.fitness)[:new_size]
                self.population = self.population[best_indices]
                self.fitness = self.fitness[best_indices]

            self.population_size = new_size

    def restart_population(self, objective_function):
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        self.fitness = objective_function(self.population)
        self.eval_count += self.population_size
        best_index = np.argmin(self.fitness)
        if self.fitness[best_index] < self.best_fitness_overall:
            self.best_solution_overall = self.population[best_index]
            self.best_fitness_overall = self.fitness[best_index]
```

### Rank 6 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptiveGaussianSamplingEA
# Description: Seed from AdaptiveGaussianSamplingEA
# Code:
```python
import numpy as np

class AdaptiveGaussianSamplingEA:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        self.population_size = 100  # Adjust as needed
        self.population = None
        self.sigma = 0.2 * (self.upper_bounds - self.lower_bounds)  # Initial Standard Deviation for Gaussian Sampling

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        fitness_values = objective_function(self.population)
        self.eval_count += self.population_size

        self.best_solution_overall = self.population[np.argmin(fitness_values)]
        self.best_fitness_overall = np.min(fitness_values)

        while self.eval_count < self.budget:
            # Adaptive Gaussian Sampling
            parents = self.tournament_selection(fitness_values, k=5)  # Tournament Selection
            offspring = self.gaussian_mutation(parents, self.sigma)

            # Bounds handling
            offspring = np.clip(offspring, self.lower_bounds, self.upper_bounds)

            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            # Update population and best solution
            self.population = np.concatenate((self.population, offspring))
            fitness_values = np.concatenate((fitness_values, offspring_fitness))

            best_index = np.argmin(fitness_values)
            if fitness_values[best_index] < self.best_fitness_overall:
                self.best_solution_overall = self.population[best_index]
                self.best_fitness_overall = fitness_values[best_index]

            # Adaptive Sigma
            self.sigma *= 0.99  # Gradually reduce sigma for finer search later.

            # Elitism
            sorted_pop = self.population[np.argsort(fitness_values)]
            self.population = sorted_pop[:self.population_size]
            fitness_values = fitness_values[np.argsort(fitness_values)][:self.population_size]

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def tournament_selection(self, fitnesses, k):
        num_parents = len(fitnesses) // 2  # Select half the population as parents
        parents = np.zeros((num_parents, self.dim))
        for i in range(num_parents):
            tournament = np.random.choice(len(fitnesses), size=k, replace=False)
            winner_index = tournament[np.argmin(fitnesses[tournament])]
            parents[i] = self.population[winner_index]
        return parents

    def gaussian_mutation(self, parents, sigma):
        offspring = parents + np.random.normal(0, sigma, parents.shape)
        return offspring

```

### Rank 7 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptiveGaussianArchiveEA
# Description: Seed from AdaptiveGaussianArchiveEA
# Code:
```python
import numpy as np
class AdaptiveGaussianArchiveEA:
    """
    Combines adaptive Gaussian sampling with an archive to enhance exploration and exploitation in multimodal landscapes.  Employs a simple Gaussian mutation strategy and tournament selection for efficiency.
    """
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        self.population_size = 100
        self.archive_size = 200  #Increased archive size for better diversity
        self.sigma = 0.5 * (self.upper_bounds - self.lower_bounds) #Increased initial sigma
        self.sigma_decay = 0.98 # Slightly faster decay
        self.archive = []

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        if self.dim > 0:
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        else:
            self.best_solution_overall = np.array([])
        self.best_fitness_overall = objective_function(self.best_solution_overall.reshape(1, -1))[0]
        self.eval_count += 1

        population = self._initialize_population()
        fitness_values = objective_function(population)
        self.eval_count += self.population_size

        self.archive = self._update_archive(population, fitness_values)

        while self.eval_count < self.budget:
            parents = self._tournament_selection(population, fitness_values)
            offspring = self._gaussian_recombination(parents)
            offspring = self._adaptive_mutation(offspring)
            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            population, fitness_values = self._select_next_generation(
                population, fitness_values, offspring, offspring_fitness
            )

            self.archive = self._update_archive(
                np.vstack((population, offspring)),
                np.concatenate((fitness_values, offspring_fitness))
            )

            self._update_best(offspring, offspring_fitness)
            self.sigma *= self.sigma_decay

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }

        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def _initialize_population(self):
        center = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        population = np.random.normal(center, self.sigma, size=(self.population_size, self.dim))
        return np.clip(population, self.lower_bounds, self.upper_bounds)

    def _tournament_selection(self, population, fitness_values):
        tournament_size = 5
        num_parents = self.population_size // 2
        selected_parents = []

        for _ in range(num_parents):
            tournament = np.random.choice(len(population), tournament_size, replace=False)
            winner_index = tournament[np.argmin(fitness_values[tournament])]
            selected_parents.append(population[winner_index])

        return np.array(selected_parents)

    def _gaussian_recombination(self, parents):
        offspring = []
        for i in range(0, len(parents), 2):
            parent1 = parents[i]
            parent2 = parents[i + 1]
            midpoint = (parent1 + parent2) / 2
            child1 = midpoint + np.random.normal(0, self.sigma / 2, self.dim)
            child2 = midpoint + np.random.normal(0, self.sigma / 2, self.dim)
            offspring.extend([child1, child2])
        return np.clip(np.array(offspring), self.lower_bounds, self.upper_bounds)

    def _adaptive_mutation(self, offspring):
        mutated = offspring + np.random.normal(0, self.sigma, size=offspring.shape)
        return np.clip(mutated, self.lower_bounds, self.upper_bounds)

    def _select_next_generation(self, population, fitness_values, offspring, offspring_fitness):
        combined_pop = np.vstack((population, offspring))
        combined_fit = np.concatenate((fitness_values, offspring_fitness))
        sorted_indices = np.argsort(combined_fit)
        next_gen = combined_pop[sorted_indices[:self.population_size]]
        next_fit = combined_fit[sorted_indices[:self.population_size]]
        return next_gen, next_fit

    def _update_best(self, offspring, offspring_fitness):
        for i, fitness in enumerate(offspring_fitness):
            if fitness < self.best_fitness_overall:
                self.best_fitness_overall = fitness
                self.best_solution_overall = offspring[i]

    def _update_archive(self, population, fitness_values):
        combined = np.column_stack((population, fitness_values))
        new_archive = []
        for sol in combined:
            already_present = any(np.allclose(sol[:-1], arch[:-1], atol=1e-6) for arch in self.archive)
            if not already_present:
                new_archive.append(sol)
        new_archive.sort(key=lambda x: x[-1])
        return np.array(new_archive[:self.archive_size])
```

### Rank 8 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: EnhancedArchiveGuidedDE
# Description: Seed from EnhancedArchiveGuidedDE
# Code:
```python
import numpy as np
import random

class EnhancedArchiveGuidedDE: #aocc 0.15
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 population_size_factor: float = 8.82865217019506, archive_size: int = 165.22481375900153, initial_F_scale: float = 0.3544373580018585):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.population_size = int(population_size_factor * self.dim)  # common heuristic
        self.archive_size = archive_size
        self.archive = []
        self.population = None
        self.F_scale = initial_F_scale  # initial scaling factor

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8,
                 F_scale_variation: float = 0.3, archive_update_threshold: float = 0.8) -> tuple:
        self.eval_count = 0
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        fitness = objective_function(self.population)
        self.eval_count += self.population_size

        self.best_solution_overall = self.population[np.argmin(fitness)]
        self.best_fitness_overall = np.min(fitness)

        while self.eval_count < self.budget:
            offspring = self.generate_offspring(self.population, fitness, F_scale_variation)
            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            # Update archive
            self.update_archive(offspring, offspring_fitness, archive_update_threshold)

            # Select best solutions for next generation
            combined_population = np.concatenate((self.population, offspring))
            combined_fitness = np.concatenate((fitness, offspring_fitness))
            indices = np.argsort(combined_fitness)
            self.population = combined_population[indices[:self.population_size]]
            fitness = combined_fitness[indices[:self.population_size]]

            # Update best solution
            self.best_solution_overall = self.population[np.argmin(fitness)]
            self.best_fitness_overall = np.min(fitness)

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'archive_size': len(self.archive)
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def generate_offspring(self, population, fitness, F_scale_variation):
        offspring = np.zeros((self.population_size, self.dim))
        # Adaptive scaling factor
        self.F_scale = 0.5 + F_scale_variation * np.random.rand()  # scale factor with slight variation

        for i in range(self.population_size):
            # Select pbest from archive (if available)
            if self.archive:
                pbest_index = np.random.choice(len(self.archive))
                pbest = self.archive[pbest_index][0]
            else:
                pbest = population[np.argmin(fitness)]

            a, b, c = random.sample(range(self.population_size), 3)
            while a == i or b == i or c == i:
                a, b, c = random.sample(range(self.population_size), 3)

            offspring[i] = population[i] + self.F_scale * (pbest - population[i] + population[a] - population[b])
            offspring[i] = np.clip(offspring[i], self.lower_bounds, self.upper_bounds)  # Boundary handling

        return offspring

    def update_archive(self, offspring, offspring_fitness, archive_update_threshold):
        for i in range(len(offspring)):
            if len(self.archive) < self.archive_size:
                self.archive.append((offspring[i], offspring_fitness[i]))
            else:
                # Prioritize diversity in archive
                worst_index = np.argmax([f for _, f in self.archive])
                if offspring_fitness[i] < self.archive[worst_index][1] or len(self.archive) < self.archive_size * archive_update_threshold:
                    self.archive[worst_index] = (offspring[i], offspring_fitness[i])
```

### Rank 9 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: IslandModelDifferentialEvolution
# Description: Implements a multi-island differential evolution with migration to explore multiple basins.
# Code:
```python
import numpy as np
import random


# Name: IslandModelDifferentialEvolution
# Description: Implements a multi-island differential evolution with migration to explore multiple basins.
# Code:
class IslandModelDifferentialEvolution:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, mutation_rate: float = 0.5,
                 crossover_rate: float = 0.7, migration_interval: int = 500, migration_size: int = 2):
        """
        Initializes the IslandModelDifferentialEvolution algorithm.

        Args:
            budget (int): The total function evaluation budget.
            dim (int): The dimensionality of the problem.
            lower_bounds (list[float]): A list of lower bounds for each dimension.
            upper_bounds (list[float]): A list of upper bounds for each dimension.
            num_islands (int): The number of isolated populations (islands).
            population_size (int): The number of individuals in each island.
            mutation_rate (float): The mutation rate (F) for differential evolution.
            crossover_rate (float): The crossover rate (CR) for differential evolution.
            migration_interval (int): The number of evaluations between migration events.
            migration_size (int): The number of individuals to migrate during each event.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.mutation_rate = mutation_rate
        self.crossover_rate = crossover_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize islands
        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            fitness = np.full(self.population_size, float('inf'))  # Initialize fitness to infinity
            self.islands.append({
                'population': population,
                'fitness': fitness,
                'best_solution': None,
                'best_fitness': float('inf')
            })

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Performs the optimization using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to minimize.  Must accept a 2D numpy array of points and return 1D array of their fitnesses
            acceptance_threshold (float):  Not used.

        Returns:
            tuple: A tuple containing the best solution, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset the evaluation count for this optimization run
        for island in self.islands:
            island['best_solution'] = None # Reset for this run
            island['best_fitness'] = float('inf')

        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.evolve_island(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate_individuals()

            # Update overall best solution
            for island in self.islands:
                if island['best_fitness'] < self.best_fitness_overall:
                    self.best_fitness_overall = island['best_fitness']
                    self.best_solution_overall = island['best_solution'].copy()

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def evolve_island(self, island_index: int, objective_function: callable):
        """
        Evolves a single island for one generation using differential evolution.

        Args:
            island_index (int): The index of the island to evolve.
            objective_function (callable): The objective function to minimize.
        """
        island = self.islands[island_index]
        population = island['population']
        fitness = island['fitness']

        # Evaluate fitness of the initial population if fitness is still the initial value (infinity)
        if np.isinf(fitness).any():
           fitness = objective_function(population)
           self.eval_count += self.population_size
           island['fitness'] = fitness

        for i in range(self.population_size):
            # Differential Evolution Mutation and Crossover
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3) # Sample distinct random indices

            mutant = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.zeros(self.dim)
            for j in range(self.dim):
                if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):
                    trial_vector[j] = mutant[j]
                else:
                    trial_vector[j] = population[i][j]

            # Evaluation
            trial_vector = trial_vector.reshape(1, -1) # Make sure its (1,dim) for evaluation function
            trial_fitness = objective_function(trial_vector)[0]
            self.eval_count += 1 # increment before checking total budget so last generation still is valid for updating overall and island bests

            if trial_fitness < fitness[i] and self.eval_count <= self.budget : # budget exceeded after fitness eval, so no update. This is important.
                population[i] = trial_vector.flatten() # replace population individual with flattened trial vector.
                fitness[i] = trial_fitness

        island['population'] = population
        island['fitness'] = fitness

        # Update island best solution
        best_index = np.argmin(fitness)
        if fitness[best_index] < island['best_fitness']:
            island['best_fitness'] = fitness[best_index]
            island['best_solution'] = population[best_index].copy()

    def migrate_individuals(self):
        """
        Migrates individuals between islands based on a ring topology.
        """
        for i in range(self.num_islands):
            # Determine sender and receiver island indices using ring topology
            sender_index = (i - 1) % self.num_islands
            receiver_index = i

            # Select individuals to migrate from sender island (worst individuals)
            sender_fitness = self.islands[sender_index]['fitness']
            migrant_indices = np.argsort(sender_fitness)[-self.migration_size:]
            migrants = self.islands[sender_index]['population'][migrant_indices].copy() # Copy necessary so islands aren't modifying same locations!

            # Replace individuals in receiver island (best individuals)
            receiver_fitness = self.islands[receiver_index]['fitness']
            replace_indices = np.argsort(receiver_fitness)[:self.migration_size]

            self.islands[receiver_index]['population'][replace_indices] = migrants
            # Set new fitness for migrated in individuals to infinity and it will be handled in `evolve_island` 
            # to make algorithm deterministic
            self.islands[receiver_index]['fitness'][replace_indices] = np.full(self.migration_size, float('inf'))
```

### Rank 10 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: MultiPopulationDifferentialEvolution
# Description: Implements differential evolution with multiple isolated populations and periodic migration to aggressively explore multimodal landscapes.
# Code:
```python
import numpy as np
import random


class MultiPopulationDifferentialEvolution:
    """
    A multi-population differential evolution algorithm designed for multimodal optimization.
    It uses multiple, relatively isolated subpopulations with periodic migration to promote diversity
    and escape local optima. Crossover and mutation parameters vary slightly between populations.
    """

    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_populations: int = 5, population_size: int = 20,
                 mutation_rate: float = 0.5, crossover_rate: float = 0.7,
                 migration_interval: int = 500, migration_amount: int = 2):

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_populations = num_populations
        self.population_size = population_size
        self.mutation_rate = mutation_rate
        self.crossover_rate = crossover_rate
        self.migration_interval = migration_interval
        self.migration_amount = migration_amount

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations
        self.populations = []
        self.fitnesses = []  # Keep track of the fitness for each population
        for _ in range(self.num_populations):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            self.populations.append(population)
            self.fitnesses.append(np.full(self.population_size, float('inf')))  # Initialize fitness to infinity


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        self.best_fitness_overall = float('inf')
        
        # Evaluate initial populations
        for i in range(self.num_populations):
            fitness_values = objective_function(self.populations[i])
            self.eval_count += self.population_size
            self.fitnesses[i] = fitness_values  # Store fitness values for each population
        
        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_populations):
                # Differential Evolution within each population
                for j in range(self.population_size):
                    # Mutation
                    indices = list(range(self.population_size))
                    indices.remove(j)
                    a, b, c = random.sample(indices, 3)  # Ensure indices are different and exclude current index j

                    mutated_vector = self.populations[i][a] + self.mutation_rate * (self.populations[i][b] - self.populations[i][c])
                    mutated_vector = np.clip(mutated_vector, self.lower_bounds, self.upper_bounds)

                    # Crossover
                    crossover_mask = np.random.rand(self.dim) < self.crossover_rate
                    trial_vector = np.where(crossover_mask, mutated_vector, self.populations[i][j])

                    # Evaluation
                    trial_fitness = objective_function(np.array([trial_vector]))[0]  # Evaluate one solution at a time
                    self.eval_count += 1
                    
                    # Selection
                    if trial_fitness < self.fitnesses[i][j]:
                        self.populations[i][j] = trial_vector
                        self.fitnesses[i][j] = trial_fitness
                        
                        # Update overall best
                        if trial_fitness < self.best_fitness_overall:
                            self.best_fitness_overall = trial_fitness
                            self.best_solution_overall = trial_vector

            # Migration
            if self.eval_count % self.migration_interval == 0:
                self.migrate_individuals()


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info


    def migrate_individuals(self):
        """
        Selects and migrates individuals between populations to enhance diversity.
        Migration happens from the best to other populations (ring topology).
        """
        # Determine the best individuals in each population
        best_indices = [np.argmin(fitness) for fitness in self.fitnesses]

        # Ring migration pattern: Each population sends individuals to the next population.
        for i in range(self.num_populations):
            # Find the target population, ensuring circularity.
            target_population_index = (i + 1) % self.num_populations
            
            # Indices of individuals to be replaced in the target population (randomly chosen)
            replace_indices = np.random.choice(self.population_size, self.migration_amount, replace=False)
                
            # The individual to be migrated from source population
            migrant = self.populations[i][best_indices[i]]
                
            # Migrate individuals
            for j in range(self.migration_amount):
                self.populations[target_population_index][replace_indices[j]] = migrant
                self.fitnesses[target_population_index][replace_indices[j]] = float('inf')  # Invalidate fitness



# Example usage (you would need to define a dummy objective function for testing)
if __name__ == '__main__':
    def dummy_objective_function(X: np.ndarray) -> np.ndarray:
        """A simple objective function for testing."""
        return np.sum(X**2, axis=1)  # A simple sphere function
        
    budget = 1000
    dim = 30
    lower_bounds = [-100.0] * dim
    upper_bounds = [100.0] * dim

    mpde = MultiPopulationDifferentialEvolution(budget=budget, dim=dim, lower_bounds=lower_bounds, upper_bounds=upper_bounds, num_populations = 4)
    
    best_solution, best_fitness, optimization_info = mpde.optimize(dummy_objective_function)

    print("Best solution:", best_solution)
    print("Best fitness:", best_fitness)
    print("Optimization info:", optimization_info)
```

### Rank 11 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: IslandBasedDifferentialEvolution
# Description: Employs an island model with differential evolution and periodic migration to explore multiple basins.
# Code:
```python
import numpy as np
import random

# Name: IslandBasedDifferentialEvolution
# Description: Employs an island model with differential evolution and periodic migration to explore multiple basins.
# Code:
class IslandBasedDifferentialEvolution:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float], num_islands: int = 5, pop_size: int = 20, crossover_rate: float = 0.7, mutation_factor: float = 0.5, migration_interval: int = 500, migration_size: int = 2):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.num_islands = num_islands
        self.pop_size = pop_size
        self.crossover_rate = crossover_rate
        self.mutation_factor = mutation_factor
        self.migration_interval = migration_interval
        self.migration_size = migration_size

        self.islands = []
        self.island_fitness = []

        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.pop_size, self.dim))
            self.islands.append(population)
            self.island_fitness.append(np.full(self.pop_size, float('inf'))) # Initialize fitness
            
    def differential_evolution(self, island_index: int, objective_function: callable) -> None:
        """Performs a single generation of differential evolution on a given island."""
        population = self.islands[island_index]
        fitness = self.island_fitness[island_index]
        new_population = np.copy(population)
        new_fitness = np.copy(fitness)

        for i in range(self.pop_size):
            # Mutation
            indices = [idx for idx in range(self.pop_size) if idx != i]
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_factor * (population[b] - population[c])

            # Ensure bounds are respected
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):  # Ensure at least one parameter is inherited from the mutant
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1) # Reshape for objective function
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness[i]:
                new_population[i] = trial_vector
                new_fitness[i] = trial_fitness

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = np.copy(trial_vector)


        self.islands[island_index] = new_population
        self.island_fitness[island_index] = new_fitness
        

    def migrate_individuals(self) -> None:
        """Migrates individuals between islands."""
        # Select random islands to exchange individuals.
        island_indices = list(range(self.num_islands))
        random.shuffle(island_indices)

        for i in range(0, self.num_islands, 2):
            # Ensure there's a pair of islands.
            if i + 1 < self.num_islands:
                island1_index = island_indices[i]
                island2_index = island_indices[i + 1]

                # Select the best individuals from island1
                best_indices_island1 = np.argsort(self.island_fitness[island1_index])[:self.migration_size]
                migrants_island1 = self.islands[island1_index][best_indices_island1]

                #Select the worst individuals from island2 (to be replaced)
                worst_indices_island2 = np.argsort(self.island_fitness[island2_index])[-self.migration_size:]

                # Replace the worst individuals in island2 with the migrants
                self.islands[island2_index][worst_indices_island2] = migrants_island1
                #Reevaluate fitness (essential after migration)
                to_reevaluate = self.islands[island2_index][worst_indices_island2]
                reshaped_reevaluate = to_reevaluate.reshape(self.migration_size,-1)
                reevaluated_fitness =  objective_function(reshaped_reevaluate)
                self.eval_count +=self.migration_size
                self.island_fitness[island2_index][worst_indices_island2] = reevaluated_fitness
                # update overall best, if needed
                for fitness, solution in zip(reevaluated_fitness, to_reevaluate):
                    if fitness < self.best_fitness_overall:
                        self.best_fitness_overall = fitness
                        self.best_solution_overall = np.copy(solution)

                # Repeat the process in the opposite direction

                # Select the best individuals from island2
                best_indices_island2 = np.argsort(self.island_fitness[island2_index])[:self.migration_size]
                migrants_island2 = self.islands[island2_index][best_indices_island2]

                #Select the worst individuals from island1 (to be replaced)
                worst_indices_island1 = np.argsort(self.island_fitness[island1_index])[-self.migration_size:]

                # Replace the worst individuals in island1 with the migrants
                self.islands[island1_index][worst_indices_island1] = migrants_island2
                #Reevaluate fitness (essential after migration)
                to_reevaluate = self.islands[island1_index][worst_indices_island1]
                reshaped_reevaluate = to_reevaluate.reshape(self.migration_size,-1)
                reevaluated_fitness =  objective_function(reshaped_reevaluate)
                self.eval_count +=self.migration_size
                self.island_fitness[island1_index][worst_indices_island1] = reevaluated_fitness

                # update overall best, if needed
                for fitness, solution in zip(reevaluated_fitness, to_reevaluate):
                    if fitness < self.best_fitness_overall:
                        self.best_fitness_overall = fitness
                        self.best_solution_overall = np.copy(solution)



    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0  # Reset for this run
        if self.dim > 0:
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        else:
            self.best_solution_overall = np.array([])
        self.best_fitness_overall = float('inf')

        # Initialize fitnesses using the objective function
        for i in range(self.num_islands):
            fitnesses = objective_function(self.islands[i])
            self.eval_count += self.pop_size
            self.island_fitness[i] = fitnesses
            best_index = np.argmin(fitnesses)
            if fitnesses[best_index] < self.best_fitness_overall:
                self.best_fitness_overall = fitnesses[best_index]
                self.best_solution_overall = np.copy(self.islands[i][best_index])


        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution(i, objective_function)

            if self.eval_count // self.migration_interval != (self.eval_count - self.pop_size*self.num_islands) // self.migration_interval and self.eval_count > self.num_islands*self.pop_size :
                self.migrate_individuals() # Migrate

            # Early stopping criterion - based on a tiny function budget
            if self.best_fitness_overall <= acceptance_threshold:
                break;

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 12 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: IslandModelDifferentialEvolution
# Description: A multi-island differential evolution algorithm that periodically migrates individuals between islands to enhance global exploration in multimodal landscapes.
# Code:
```python
import numpy as np
import random

# Name: IslandModelDifferentialEvolution
# Description: A multi-island differential evolution algorithm that periodically migrates individuals between islands to enhance global exploration in multimodal landscapes.

class IslandModelDifferentialEvolution:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 500, migration_size: int = 2):

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.populations = []
        self.fitness_values = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            self.populations.append(population)
            self.fitness_values.append(np.full(self.population_size, float('inf')))  # Initialize fitness values
        
        self.island_best_solutions = [None] * self.num_islands
        self.island_best_fitnesses = [float('inf')] * self.num_islands
        

    def differential_evolution(self, objective_function: callable, island_index: int):
        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]
        
        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)

            mutant = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):
                    trial_vector[j] = mutant[j]
                    
            trial_vector = np.clip(trial_vector, self.lower_bounds, self.upper_bounds)
            
            # Selection
            trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]
            self.eval_count += 1

            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness
                
                if trial_fitness < self.island_best_fitnesses[island_index]:
                    self.island_best_fitnesses[island_index] = trial_fitness
                    self.island_best_solutions[island_index] = trial_vector
                    

                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector

        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values


    def migrate_individuals(self):
        # Choose islands for migration
        source_island = random.randint(0, self.num_islands - 1)
        destination_island = random.randint(0, self.num_islands - 1)
        while destination_island == source_island:
            destination_island = random.randint(0, self.num_islands - 1)
        

        # Select individuals for migration (best individuals from source)
        sorted_indices = np.argsort(self.fitness_values[source_island])
        migrants_indices = sorted_indices[:self.migration_size]
        migrants = self.populations[source_island][migrants_indices]

        # Replace worst individuals on destination with incoming migrants
        sorted_indices_dest = np.argsort(self.fitness_values[destination_island])[::-1]
        replace_indices = sorted_indices_dest[:self.migration_size]

        self.populations[destination_island][replace_indices] = migrants
        
        # Recalculate fitness values for replaced individuals in the destination population
        for i in replace_indices:
            self.fitness_values[destination_island][i] = float('inf') # Reset to high value
        new_fitnesses = objective_function(self.populations[destination_island][replace_indices])
        self.eval_count += len(replace_indices)
        
        self.fitness_values[destination_island][replace_indices] = new_fitnesses


        # Update best island solutions if necessary.  Note, *only* update based on the *new* individuals to avoid biasing migration
        # against the source.
        for i, index in enumerate(replace_indices):
            fitness = self.fitness_values[destination_island][index]

            if fitness < self.island_best_fitnesses[destination_island]:
                self.island_best_fitnesses[destination_island] = fitness
                self.island_best_solutions[destination_island] = self.populations[destination_island][index]
                
            if fitness < self.best_fitness_overall:
                self.best_fitness_overall = fitness
                self.best_solution_overall = self.populations[destination_island][index]



    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.best_fitness_overall = float('inf')
        if self.dim > 0:
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        else:
            self.best_solution_overall = np.array([])

        # Initialize populations and fitnesses, and per island best solutions
        for i in range(self.num_islands):
            fitnesses = objective_function(self.populations[i])
            self.eval_count += self.population_size
            self.fitness_values[i] = fitnesses

            best_index = np.argmin(fitnesses)
            self.island_best_fitnesses[i] = fitnesses[best_index]
            self.island_best_solutions[i] = self.populations[i][best_index]
            
            if fitnesses[best_index] < self.best_fitness_overall:
                self.best_fitness_overall = fitnesses[best_index]
                self.best_solution_overall = self.populations[i][best_index]


        generation = 0
        while self.eval_count < self.budget:
            generation += 1

            # Evolve each island independently
            for i in range(self.num_islands):
                self.differential_evolution(objective_function, i)

            # Migration
            if generation % (self.migration_interval // self.population_size) == 0:
                self.migrate_individuals()

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'num_islands': self.num_islands,
            'population_size': self.population_size,
            'crossover_rate': self.crossover_rate,
            'mutation_rate': self.mutation_rate,
            'migration_interval': self.migration_interval,
            'migration_size': self.migration_size
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 13 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: IslandDifferentialEvolution
# Description: Uses an island model with differential evolution to explore different basins in deceptive landscapes.
# Code:
```python
import numpy as np
import random

# Name: IslandDifferentialEvolution
# Description: Uses an island model with differential evolution to explore different basins in deceptive landscapes.
# Code:
class IslandDifferentialEvolution:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float], num_islands: int = 5, population_size: int = 50, migration_interval: int = 1000, migration_size: int = 5):
        """
        Initializes the Island Differential Evolution algorithm.

        Args:
            budget (int): The maximum number of function evaluations.
            dim (int): The dimensionality of the problem.
            lower_bounds (list[float]): A list of the lower bounds for each dimension.
            upper_bounds (list[float]): A list of the upper bounds for each dimension.
            num_islands (int): The number of islands in the island model.
            population_size (int): The population size for each island.
            migration_interval (int): The number of evaluations between migrations.
            migration_size (int): The number of individuals to migrate between islands.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = int(num_islands)
        self.population_size = int(population_size)
        self.migration_interval = int(migration_interval)
        self.migration_size = int(migration_size)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = []
        self.fitnesses = []
        self.best_solutions = []
        self.best_fitnesses = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            self.populations.append(population)
            self.fitnesses.append(np.full(self.population_size, float('inf')))  # Initialize fitnesses to infinity
            self.best_solutions.append(None)
            self.best_fitnesses.append(float('inf'))

    def differential_evolution(self, population, fitnesses, objective_function):
        """
        Performs differential evolution on a single population.

        Args:
            population (np.ndarray): The current population.
            fitnesses (np.ndarray): The fitness values of the current population.
            objective_function (callable): The objective function to evaluate.

        Returns:
            tuple: A tuple containing the updated population, fitnesses, best solution, and best fitness.
        """
        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant = population[a] + 0.5 * (population[b] - population[c])  # DE/rand/1

            # Crossover
            crossover_mask = np.random.rand(self.dim) < 0.9  # Crossover rate (CR)
            trial_vector = np.where(crossover_mask, mutant, population[i])

            # Ensure bounds are respected
            trial_vector = np.clip(trial_vector, self.lower_bounds, self.upper_bounds)

            # Evaluation
            trial_vector = trial_vector.reshape(1, -1) #Ensure input is (1, dim)
            trial_fitness = objective_function(trial_vector)[0]
            self.eval_count += 1
            
            # Selection
            if trial_fitness < fitnesses[i]:
                population[i] = trial_vector.flatten()
                fitnesses[i] = trial_fitness
                if trial_fitness < self.best_fitness_overall:
                     self.best_fitness_overall = trial_fitness
                     self.best_solution_overall = trial_vector.flatten()
        
        best_index = np.argmin(fitnesses)
        best_solution = population[best_index]
        best_fitness = fitnesses[best_index]
        
        return population, fitnesses, best_solution, best_fitness

    def migrate_individuals(self):
        """
        Migrates individuals between islands.
        """
        # For each island, send migration_size best individuals to a randomly chosen other island.
        for i in range(self.num_islands):
            # Select a random destination island that is not the current island.
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best individuals on the current island.
            best_indices = np.argsort(self.fitnesses[i])[:self.migration_size]

            # Transfer the best individuals to the destination island, replacing the worst individuals there.
            worst_indices = np.argsort(self.fitnesses[dest_island])[-self.migration_size:]
            self.populations[dest_island][worst_indices] = self.populations[i][best_indices].copy()
           
            #Reevaluate fitnesses of these copied individuals
            X = self.populations[dest_island][worst_indices]
            self.fitnesses[dest_island][worst_indices] = objective_function(X)
            self.eval_count += len(worst_indices)
    

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the objective function using an island model with differential evolution.

        Args:
            objective_function (callable): The objective function to evaluate.
            acceptance_threshold (float): The acceptance threshold for early stopping.

        Returns:
            tuple: A tuple containing the best solution, best fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        if self.dim > 0:
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        else:
            self.best_solution_overall = np.array([])
        self.best_fitness_overall = float('inf')

        generation = 0 #Add a generation count
        while self.eval_count < self.budget:

            for i in range(self.num_islands):
                # Evaluate the initial population
                if generation == 0:
                    X = self.populations[i]
                    self.fitnesses[i] = objective_function(X)
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitnesses[i])
                    self.best_solutions[i] = self.populations[i][best_index]
                    self.best_fitnesses[i] = self.fitnesses[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]

                # Perform differential evolution on each island
                self.populations[i], self.fitnesses[i], best_solution_island, best_fitness_island = self.differential_evolution(
                    self.populations[i], self.fitnesses[i], objective_function)

                # Update best solution for the island
                if best_fitness_island < self.best_fitnesses[i]:
                    self.best_fitnesses[i] = best_fitness_island
                    self.best_solutions[i] = best_solution_island

                # Update the overall best solution
                if best_fitness_island < self.best_fitness_overall:
                    self.best_fitness_overall = best_fitness_island
                    self.best_solution_overall = best_solution_island
            
            # Perform migration
            if (self.eval_count // self.population_size) % (self.migration_interval // self.population_size) == 0 and self.eval_count > 0 : # migrate only every n generations
                self.migrate_individuals()
                
            generation +=1

        if self.best_solution_overall is None and self.dim > 0:  # Fallback
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 14 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: IslandGradientDescent
# Description: Uses an island model with gradient descent on each island, promoting exploration and exploitation of local optima.
# Code:
```python
import numpy as np
import random

# Name: IslandGradientDescent
# Description: Uses an island model with gradient descent on each island, promoting exploration and exploitation of local optima.
# Code:
class IslandGradientDescent:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float], num_islands: int = 5, population_size: int = 20, learning_rate: float = 0.1, migration_interval: int = 500, migration_size: int = 2, local_search_iterations: int = 10):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.num_islands = num_islands
        self.population_size = population_size
        self.learning_rate = learning_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.islands = []

        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            self.islands.append({'population': population, 'fitness': np.full(self.population_size, float('inf'))})

    def local_search(self, objective_function: callable, island: dict):
        for i in range(self.population_size):
            x = island['population'][i].copy()
            fitness = island['fitness'][i]

            for _ in range(self.local_search_iterations):
                gradient = np.random.uniform(-1, 1, self.dim)  # Approximate gradient
                x_new = x - self.learning_rate * gradient
                x_new = np.clip(x_new, self.lower_bounds, self.upper_bounds)

                fitness_new = objective_function(x_new.reshape(1, -1))[0]
                self.eval_count += 1

                if fitness_new < fitness:
                    x = x_new
                    fitness = fitness_new
                
                if fitness < self.best_fitness_overall:
                   self.best_fitness_overall = fitness
                   self.best_solution_overall = x

                if self.eval_count >= self.budget:
                   break   # Budget check inside inner-loop for performance
            island['population'][i] = x
            island['fitness'][i] = fitness
            if self.eval_count >= self.budget:
                break # and for outer loop
                

    def migrate(self):
        # Select a random island as the donor
        donor_island_index = random.randint(0, self.num_islands - 1)
        donor_island = self.islands[donor_island_index]

        # Select recipient islands (excluding the donor)
        recipient_indices = list(range(self.num_islands))
        recipient_indices.remove(donor_island_index)
        random.shuffle(recipient_indices)
        recipient_indices = recipient_indices[:self.migration_size] # Pick 1 or 2

        # Select migrants from the donor island (best solutions)
        sorted_indices = np.argsort(donor_island['fitness'])
        migrants = donor_island['population'][sorted_indices[:self.migration_size]]

        # Replace worst individuals on recipient islands with migrants
        for recipient_index in recipient_indices:
            recipient_island = self.islands[recipient_index]
            worst_indices = np.argsort(recipient_island['fitness'])[::-1] # Worst first
            recipient_island['population'][worst_indices[:self.migration_size]] = migrants.copy()  #Important to copy.
            recipient_island['fitness'][worst_indices[:self.migration_size]] = np.full(self.migration_size, float('inf')) # Fitness needs to be re-evaluated on the recipient island (important). Don't transfer donor fitness.

            #Mark for re-eval
            
    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        if self.dim > 0:
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        else:
            self.best_solution_overall = np.array([])
        self.best_fitness_overall = float('inf')

        generation = 0

        while self.eval_count < self.budget:
            generation+=1
            for island in self.islands:
                #evaluate population whose fitness is infinite... these are the initial ones, or newly migrated solutions.
                needs_eval = np.isinf(island['fitness'])
                num_to_eval = np.sum(needs_eval)

                if num_to_eval > 0:

                    X = island['population'][needs_eval].reshape(num_to_eval,-1)  #This is tricky, so take care on reshaping.
                    fitness_vals = objective_function(X) #Evaluate only those needing evaluation

                    island['fitness'][needs_eval] = fitness_vals #assign them back

                    self.eval_count += num_to_eval
                    
                    #Update global best
                    best_in_batch_idx = np.argmin(fitness_vals)

                    if fitness_vals[best_in_batch_idx] < self.best_fitness_overall:
                        self.best_fitness_overall = fitness_vals[best_in_batch_idx]
                        self.best_solution_overall = island['population'][needs_eval][best_in_batch_idx].copy()  #critical to copy


                self.local_search(objective_function, island)
                if self.eval_count >= self.budget:
                    break

            if generation * self.population_size * self.num_islands > self.migration_interval:

                self.migrate()
                generation = 0   #reset counter

            if self.eval_count >= self.budget:
                break


        if self.best_solution_overall is None and self.dim > 0:
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
            self.best_fitness_overall = objective_function(self.best_solution_overall.reshape(1,-1))[0]  #Ensure valid fitness.

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'islands': self.islands  # Save islands for debugging/analysis
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 15 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: MultiPopulationDifferentialEvolution
# Description: A multi-population differential evolution algorithm using migration to tackle deceptive landscapes.
# Code:
```python
import numpy as np
import random


# Name: MultiPopulationDifferentialEvolution
# Description: A multi-population differential evolution algorithm using migration to tackle deceptive landscapes.
# Code:
class MultiPopulationDifferentialEvolution:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float], num_populations: int = 5, population_size: int = 50, F: float = 0.7, Cr: float = 0.9, migration_interval: int = 2000, migration_size: int = 5):
        """
        Initializes the MultiPopulationDifferentialEvolution algorithm.

        Args:
            budget (int): The maximum number of function evaluations.
            dim (int): The dimensionality of the problem.
            lower_bounds (list[float]): The lower bounds for each dimension.
            upper_bounds (list[float]): The upper bounds for each dimension.
            num_populations (int, optional): The number of subpopulations. Defaults to 5.
            population_size (int, optional): The size of each population. Defaults to 50.
            F (float, optional): The scaling factor for differential evolution. Defaults to 0.7.
            Cr (float, optional): The crossover probability for differential evolution. Defaults to 0.9.
            migration_interval (int, optional): The interval (in function evaluations) at which migration occurs. Defaults to 2000.
            migration_size (int, optional): The number of individuals to migrate between populations. Defaults to 5.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_populations = num_populations
        self.population_size = population_size
        self.F = F
        self.Cr = Cr
        self.migration_interval = migration_interval
        self.migration_size = migration_size

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations
        self.populations = []
        self.fitnesses = []
        for _ in range(self.num_populations):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            self.populations.append(population)
            self.fitnesses.append(np.full(self.population_size, float('inf')))  # Initialize fitnesses to infinity

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the objective function using multi-population differential evolution.

        Args:
            objective_function (callable): The objective function to optimize.  Accepts a 2D NumPy array `X` (shape `(N, dim)`) and returns a 1D NumPy array of `N` fitness values.
            acceptance_threshold (float, optional):  Not used, added for compliance. Defaults to 1e-8.

        Returns:
            tuple: A tuple containing the best solution, its fitness, and optimization information.
        """
        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Evaluate initial populations
        for i in range(self.num_populations):
            fitness_values = objective_function(self.populations[i])
            self.fitnesses[i] = fitness_values
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitnesses[i])
            if self.fitnesses[i][best_index] < self.best_fitness_overall:
                self.best_fitness_overall = self.fitnesses[i][best_index]
                self.best_solution_overall = self.populations[i][best_index].copy()


        while self.eval_count < self.budget:
            for i in range(self.num_populations):
                # Differential Evolution
                for j in range(self.population_size):
                    # Mutation
                    indices = list(range(self.population_size))
                    indices.remove(j)
                    a, b, c = random.sample(indices, 3)
                    mutant = self.populations[i][a] + self.F * (self.populations[i][b] - self.populations[i][c])

                    # Ensure bounds
                    mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

                    # Crossover
                    trial = np.copy(self.populations[i][j])
                    for k in range(self.dim):
                        if random.random() < self.Cr:
                            trial[k] = mutant[k]

                    # Evaluation
                    trial = trial.reshape(1, -1)  # Reshape to 2D array for objective function

                    fitness = objective_function(trial)[0]  # Extract scalar fitness value

                    self.eval_count += 1

                    # Selection
                    if fitness < self.fitnesses[i][j]:
                        self.fitnesses[i][j] = fitness
                        self.populations[i][j] = trial.flatten() # store flattened

                        if fitness < self.best_fitness_overall:
                            self.best_fitness_overall = fitness
                            self.best_solution_overall = trial.flatten().copy()


            # Migration
            if self.eval_count % self.migration_interval == 0 and self.eval_count > 0:
                self.migrate()



        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def migrate(self):
        """
        Implements migration between subpopulations.  The best individuals from each subpopulation
        are exchanged with the worst individuals from other subpopulations.
        """
        # Identify best and worst individuals in each population
        best_indices = [np.argmin(fitness) for fitness in self.fitnesses]
        worst_indices = [np.argmax(fitness) for fitness in self.fitnesses]

        # Create a list of population indices
        population_indices = list(range(self.num_populations))


        for i in range(self.num_populations):
            # Choose a different population to migrate to
            recipient_index = random.choice([idx for idx in population_indices if idx != i])

            # Migrate the best individuals from population i to the worst individuals in population recipient_index
            for _ in range(self.migration_size):
                # find the current best in sending population and worst in receiving population, since ranks may have shifted
                best_index_source = np.argmin(self.fitnesses[i])
                worst_index_dest = np.argmax(self.fitnesses[recipient_index])

                self.populations[recipient_index][worst_index_dest] = self.populations[i][best_index_source].copy()
                self.fitnesses[recipient_index][worst_index_dest] = self.fitnesses[i][best_index_source]

                # Invalidate used best so it isn't selected multiple times. Invariant: the mean fitness changes slightly, but is always >= original.
                self.fitnesses[i][best_index_source] = float('inf')
```



### Guide
Keep in mind, this is a list of design heuristics ranked from best to worst. The first algorithm in the list is the best performing on average, and the last is the worst.
Your response must be in Markdown format and contain nothing else. It must have the following structure:

"**Analysis:**
**Experience:**"

In there:
+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.
Example: "Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:"

+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).

I'm going to tip $999K for a better heuristics! Let's think step by step.
2025-06-25 11:30:56 INFO Full response text: **Analysis:**
Comparing (Rank 1) vs (Rank 15), we see: Rank 1 employs a more explicit `migrate` function for information exchange, while Rank 15 focuses on within-population DE steps first, then migration. Rank 1's `migrate` function intelligently chooses islands to send its best to, replacing worst on destination, recalculating destination fitness, and handles best fitness overall, while Rank 15's migration swaps "best" from one population with the "worst" from another, immediately after differential evolution step and *also* sets the fitness of old best to infinity.
Comparing (Rank 2) vs (Rank 14), we see: Rank 2 incorporates both `differential_evolution_step` and `migrate_individuals` for iterative improvement and information sharing. Contrastingly, Rank 14 uses a more complex scheme, including `local_search` within `optimize`, `migrate` and also re-evaluate after solutions have already been adapted to that environment; furthermore rank 14 used a simplified "gradient" which is just random and does little to improve results.
Comparing (Rank 1) vs (Rank 2), we see: Rank 1, IslandModelDifferentialEvolution is characterized by a clearer separation of concerns, modular functions (e.g., `differential_evolution_step`, `migrate`), and explicit migration procedures. These features likely allow for improved maintainability, readability, and customization. Rank 2,IslandBasedDifferentialEvolution performs a more straightforward migration strategy.
Comparing (Rank 3) vs (Rank 4), we see: Rank 3 uses an actual "DE" step whereas Rank 4's "DE" is performed as a subset of the optimization loop leading to a significantly less effective DE optimization.

Comparing (Rank 14) vs (Rank 15), we see: Rank 14 applies gradient descent locally within islands, migrating fully adapted individuals to new locations, and then *leaving them*. Rank 15 *immediately* mutates the solutions which are placed, without waiting. The gradient descent as implemented is inefficient, whereas rank 15 immediately continues to optimize placed values for faster environment adaptation.

Overall: Modularity (with distinct functions like `differential_evolution_step` and `migrate`), explicit migration strategies that carefully exchange the *right* individuals between populations, bound handling, and fitness recalculation after migration is important. DE should be implemented with mutations which improve search, and gradient descent should be more sophisticated, not randomly chosen.

**Experience:**
Employ modular functions for DE and migration.  Migrate best individuals and reassess fitness in the new environment. Ensure proper bound handling. During migration, transfer useful fitness information while promoting re-evaluation and local adaptation as quickly as possible once transplanted. Don't leave already evolved transplants without further optimization.

2025-06-25 11:30:57 INFO Full response text: Okay, I understand. We need to refine the current self-reflection to design better heuristics, steering clear of potential pitfalls. Here's a revised approach:

*   **Keywords:** Modular DE/Migration, Fitness Propagation, Local Adaptation, Continuous Optimization, Bound Handling.
*   **Advice:** Prioritize transferring insightful fitness data alongside individuals during migration. Rapidly re-evaluate transplanted individuals to trigger fast local adaptation. Maintain optimization pressure on migrants post-transplantation.
*   **Avoid:** Stagnation of evolved migrants. Premature termination of optimization.
*   **Explanation:** Optimize data transfer during migration. Quickly integrate migrants into new populations. Fine-tune migrants.

2025-06-25 11:30:57 INFO Generating offspring via Crossover...
2025-06-25 12:18:03 INFO Crossover Prompt: **(CR: Capacity and Role)**
Act as an expert in designing algorithms for deceptive, multi-component landscapes. Your specialty is creating strategies that use multi-population or island models to perform aggressive global exploration.

**(I: Insight)**
Your objective is to design a novel optimization algorithm for the GNBG benchmark. The most difficult functions (f16-f24) have multiple, separate basins of attraction where the global optimum can be hidden. An algorithm must be able to discover and explore these competing regions to succeed.

**(S: Statement & P: Personality)**
Provide a complete, novel Python class that implements a multi-population or island-based search strategy to solve this challenge. The class must have an `__init__(...)` and `optimize(...)` method as specified in the main task description.


### Better code
IslandModelDifferentialEvolution
import numpy as np
import random

# Name: IslandModelDifferentialEvolution
# Description: Implements an island model DE with migration and restarts for aggressive global exploration.
# Code:
class IslandModelDifferentialEvolution:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float], num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7, differential_weight: float = 0.5, migration_interval: int = 5000, migration_size: int = 2):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.differential_weight = differential_weight
        self.migration_interval = migration_interval #Function evaluation intervals
        self.migration_size = migration_size

        self.islands = []
        self.island_best_solutions = []
        self.island_best_fitnesses = []

        for _ in range(self.num_islands):
            population = np.random.uniform(low=self.lower_bounds, high=self.upper_bounds, size=(self.population_size, self.dim))
            self.islands.append(population)
            self.island_best_solutions.append(None)
            self.island_best_fitnesses.append(float('inf'))
    

    def differential_evolution_step(self, island_index: int, objective_function: callable):
        population = self.islands[island_index]
        new_population = np.copy(population)  # Avoid modifying original population directly
        
        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)

            mutant = population[a] + self.differential_weight * (population[b] - population[c])
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

            # Crossover
            crossover_mask = np.random.rand(self.dim) < self.crossover_rate
            trial_vector = np.where(crossover_mask, mutant, population[i])

            # Evaluation
            fitness_trial = objective_function(trial_vector.reshape(1, -1))[0]
            self.eval_count += 1

            if fitness_trial < self.island_best_fitnesses[island_index]:
                self.island_best_fitnesses[island_index] = fitness_trial
                self.island_best_solutions[island_index] = trial_vector
                
                if fitness_trial < self.best_fitness_overall:
                    self.best_fitness_overall = fitness_trial
                    self.best_solution_overall = trial_vector.copy()
            
            fitness_individual = objective_function(population[i].reshape(1, -1))[0]  # Recalculate fitness
            self.eval_count += 1
           

            # Selection
            if fitness_trial < fitness_individual:
                new_population[i] = trial_vector
                
            else:
                 new_population[i] = population[i]

        self.islands[island_index] = new_population
        return


    def migrate(self):
        #Simple migration: exchange best solutions between random islands
        island_indices = list(range(self.num_islands))
        random.shuffle(island_indices)

        for i in range(0, self.num_islands, 2):
            if i + 1 < self.num_islands:
                island1_idx = island_indices[i]
                island2_idx = island_indices[i+1]

                #Exchange migration_size best solutions from island1 to island2 and vice versa
                sorted_indices_island1 = np.argsort(self.island_best_fitnesses[island1_idx])
                sorted_indices_island2 = np.argsort(self.island_best_fitnesses[island2_idx])


                self.islands[island1_idx][:self.migration_size] = np.array([self.best_solution_overall])  
                self.islands[island2_idx][:self.migration_size] = np.array([self.best_solution_overall]) #Simplification since it's difficult to access current populations

                #Update also best fitness and best solution
                fitness_island1 = objective_function(self.islands[island1_idx][0:1])[0]
                self.eval_count += 1

                fitness_island2 = objective_function(self.islands[island2_idx][0:1])[0]
                self.eval_count += 1

                self.island_best_solutions[island1_idx] = self.islands[island1_idx][0]
                self.island_best_fitnesses[island1_idx] = fitness_island1
                
                self.island_best_solutions[island2_idx] = self.islands[island2_idx][0]
                self.island_best_fitnesses[island2_idx] = fitness_island2



    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0 # Reset for this run
        self.best_fitness_overall = float('inf')
        self.best_solution_overall = np.random.uniform(low=self.lower_bounds, high=self.upper_bounds, size=self.dim)

        #Initialize island bests
        for island_index in range(self.num_islands):
             island_fitnesses = objective_function(self.islands[island_index])
             self.eval_count += self.population_size # Evaluate each island once.
             best_index = np.argmin(island_fitnesses)
             self.island_best_fitnesses[island_index] = island_fitnesses[best_index]
             self.island_best_solutions[island_index] = self.islands[island_index][best_index]

             if self.island_best_fitnesses[island_index] < self.best_fitness_overall:
                 self.best_fitness_overall = self.island_best_fitnesses[island_index]
                 self.best_solution_overall = self.island_best_solutions[island_index].copy()
           

        while self.eval_count < self.budget:
            for island_index in range(self.num_islands):
                self.differential_evolution_step(island_index, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate()

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * 0.95:  # Restart towards the end
                for island_index in range(self.num_islands):
                    self.islands[island_index] = np.random.uniform(low=self.lower_bounds, high=self.upper_bounds, size=(self.population_size, self.dim))
                    island_fitnesses = objective_function(self.islands[island_index])
                    self.eval_count += self.population_size
                    best_index = np.argmin(island_fitnesses)
                    self.island_best_fitnesses[island_index] = island_fitnesses[best_index]
                    self.island_best_solutions[island_index] = self.islands[island_index][best_index]
                    if self.island_best_fitnesses[island_index] < self.best_fitness_overall:
                        self.best_fitness_overall = self.island_best_fitnesses[island_index]
                        self.best_solution_overall = self.islands[island_index][best_index].copy()

                
        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

### Worse code
IslandModelDifferentialEvolution
import numpy as np
import random

# Name: IslandModelDifferentialEvolution
# Description: Uses an island model with differential evolution to explore separate basins of attraction aggressively.
# Code:
class IslandModelDifferentialEvolution:
    """
    A multi-population (island model) differential evolution algorithm.
    Designed to handle deceptive, multi-component landscapes by independently
    exploring multiple regions and periodically exchanging information.
    """

    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 500, migration_size: int = 2):
        """
        Initializes the IslandModelDifferentialEvolution optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values


    def migrate(self):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants
            # Re-evaluate the fitness of the new solutions on the destination island (important!)
            new_fitness = []
            for j in range(len(worst_indices)):
              migrant_reshaped = migrants[j].reshape(1,-1)
              new_fitness.append(float(objective_function(migrant_reshaped)))
              self.eval_count += 1

            dest_island_fitness[worst_indices] = new_fitness
            self.fitness_values[dest_island] = dest_island_fitness
             # Update best fitness, if needed
            for fit, sol in zip(new_fitness, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol




    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate()



        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

if __name__ == '__main__':
    # Example usage (replace with your actual objective function and problem setup)
    def objective_function(X: np.ndarray) -> np.ndarray:
        """A sample objective function (sphere function)."""
        return np.sum(X**2, axis=1)

    budget = 10000
    dim = 30
    lower_bounds = [-100.0] * dim
    upper_bounds = [100.0] * dim

    optimizer = IslandModelDifferentialEvolution(budget=budget, dim=dim, lower_bounds=lower_bounds,
                                                  upper_bounds=upper_bounds, num_islands=5)
    best_solution, best_fitness, optimization_info = optimizer.optimize(objective_function)

    print("Best Solution:", best_solution)
    print("Best Fitness:", best_fitness)
    print("Optimization Info:", optimization_info)

### Analyze & experience
- Comparing (Rank 1) vs (Rank 15), we see: Rank 1 employs a more explicit `migrate` function for information exchange, while Rank 15 focuses on within-population DE steps first, then migration. Rank 1's `migrate` function intelligently chooses islands to send its best to, replacing worst on destination, recalculating destination fitness, and handles best fitness overall, while Rank 15's migration swaps "best" from one population with the "worst" from another, immediately after differential evolution step and *also* sets the fitness of old best to infinity.
Comparing (Rank 2) vs (Rank 14), we see: Rank 2 incorporates both `differential_evolution_step` and `migrate_individuals` for iterative improvement and information sharing. Contrastingly, Rank 14 uses a more complex scheme, including `local_search` within `optimize`, `migrate` and also re-evaluate after solutions have already been adapted to that environment; furthermore rank 14 used a simplified "gradient" which is just random and does little to improve results.
Comparing (Rank 1) vs (Rank 2), we see: Rank 1, IslandModelDifferentialEvolution is characterized by a clearer separation of concerns, modular functions (e.g., `differential_evolution_step`, `migrate`), and explicit migration procedures. These features likely allow for improved maintainability, readability, and customization. Rank 2,IslandBasedDifferentialEvolution performs a more straightforward migration strategy.
Comparing (Rank 3) vs (Rank 4), we see: Rank 3 uses an actual "DE" step whereas Rank 4's "DE" is performed as a subset of the optimization loop leading to a significantly less effective DE optimization.

Comparing (Rank 14) vs (Rank 15), we see: Rank 14 applies gradient descent locally within islands, migrating fully adapted individuals to new locations, and then *leaving them*. Rank 15 *immediately* mutates the solutions which are placed, without waiting. The gradient descent as implemented is inefficient, whereas rank 15 immediately continues to optimize placed values for faster environment adaptation.

Overall: Modularity (with distinct functions like `differential_evolution_step` and `migrate`), explicit migration strategies that carefully exchange the *right* individuals between populations, bound handling, and fitness recalculation after migration is important. DE should be implemented with mutations which improve search, and gradient descent should be more sophisticated, not randomly chosen.
- Okay, I understand. We need to refine the current self-reflection to design better heuristics, steering clear of potential pitfalls. Here's a revised approach:

*   **Keywords:** Modular DE/Migration, Fitness Propagation, Local Adaptation, Continuous Optimization, Bound Handling.
*   **Advice:** Prioritize transferring insightful fitness data alongside individuals during migration. Rapidly re-evaluate transplanted individuals to trigger fast local adaptation. Maintain optimization pressure on migrants post-transplantation.
*   **Avoid:** Stagnation of evolved migrants. Premature termination of optimization.
*   **Explanation:** Optimize data transfer during migration. Quickly integrate migrants into new populations. Fine-tune migrants.


Your task is to write an improved function by COMBINING elements of two above heuristics base Analyze & experience.
Output the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.

I'm going to tip $999K for a better heuristics! Let's think step by step.
2025-06-25 12:18:03 INFO Mutation prompt: **(CR: Capacity and Role)**
Act as an expert in designing algorithms for deceptive, multi-component landscapes. Your specialty is creating strategies that use multi-population or island models to perform aggressive global exploration.

**(I: Insight)**
Your objective is to design a novel optimization algorithm for the GNBG benchmark. The most difficult functions (f16-f24) have multiple, separate basins of attraction where the global optimum can be hidden. An algorithm must be able to discover and explore these competing regions to succeed.

**(S: Statement & P: Personality)**
Provide a complete, novel Python class that implements a multi-population or island-based search strategy to solve this challenge. The class must have an `__init__(...)` and `optimize(...)` method as specified in the main task description.


Current heuristics:
AdaptiveIslandDE
import numpy as np
import random

# Name: AdaptiveIslandDE
# Description: An island-based DE with adaptive migration, local search, and restart mechanisms to handle deceptive landscapes.
# Code:
class AdaptiveIslandDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 500, migration_size: int = 2,
                 local_search_iterations: int = 10):
        """
        Initializes the AdaptiveIslandDE optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a simple gradient-based method.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation
            perturbation = np.random.normal(0, 0.1, self.dim) # Scale adjusted from 1 to 0.1
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants
            
            # Re-evaluate the fitness of the new solutions on the destination island (important!) and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                new_fitnesses.append(fitness)
              
            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness
             # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol




    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * 0.95:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

Now, think outside the box write a mutated function better than current version.
You can use some hints below:
- Okay, I understand. We need to refine the current self-reflection to design better heuristics, steering clear of potential pitfalls. Here's a revised approach:

*   **Keywords:** Modular DE/Migration, Fitness Propagation, Local Adaptation, Continuous Optimization, Bound Handling.
*   **Advice:** Prioritize transferring insightful fitness data alongside individuals during migration. Rapidly re-evaluate transplanted individuals to trigger fast local adaptation. Maintain optimization pressure on migrants post-transplantation.
*   **Avoid:** Stagnation of evolved migrants. Premature termination of optimization.
*   **Explanation:** Optimize data transfer during migration. Quickly integrate migrants into new populations. Fine-tune migrants.


Output code only and enclose your code with Python code block: ```python ... ```.
I'm going to tip $999K for a better solution!
2025-06-25 13:06:51 INFO Perform Harmony Search...
2025-06-25 13:07:31 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 13:08:13 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:08:13 INFO FeHistory: [137839.27806396 132240.68898586 162401.23324485 ... 120204.0179751
 154712.77410377 172696.98690129]
2025-06-25 13:08:13 INFO Expected Optimum FE: -5000
2025-06-25 13:08:13 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 13:08:52 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:08:52 INFO FeHistory: [172742.1723433  135260.75893798 166798.83580179 ... 187010.50027622
 148767.51820011 123370.33083697]
2025-06-25 13:08:52 INFO Expected Optimum FE: -5000
2025-06-25 13:08:52 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 13:09:34 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:09:34 INFO FeHistory: [140614.00526398 243527.03332102 161220.62924853 ... 178824.40187368
 158559.0251713  163415.32462066]
2025-06-25 13:09:34 INFO Expected Optimum FE: -5000
2025-06-25 13:09:34 INFO Unimodal AOCC mean: nan
2025-06-25 13:09:34 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 13:09:34 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 13:09:34 INFO AOCC mean: 0.0000
2025-06-25 13:09:34 INFO Weighed AOCC mean: nan
2025-06-25 13:09:34 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 13:10:18 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:10:18 INFO FeHistory: [126667.62616509 144804.28961663 100825.7822798  ... 126720.14571878
 170046.17477618 138144.78697986]
2025-06-25 13:10:18 INFO Expected Optimum FE: -5000
2025-06-25 13:10:18 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 13:10:58 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:10:58 INFO FeHistory: [122378.99384913 109602.28939146 128820.76362227 ... 157239.46117729
 130170.70820827 208620.59386753]
2025-06-25 13:10:58 INFO Expected Optimum FE: -5000
2025-06-25 13:10:58 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 13:11:38 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:11:38 INFO FeHistory: [245306.6493042  155363.88235205 251958.30026181 ...  72629.9714894
 143410.87568735 125578.83303274]
2025-06-25 13:11:38 INFO Expected Optimum FE: -5000
2025-06-25 13:11:38 INFO Unimodal AOCC mean: nan
2025-06-25 13:11:38 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 13:11:38 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 13:11:38 INFO AOCC mean: 0.0000
2025-06-25 13:11:38 INFO Weighed AOCC mean: nan
2025-06-25 13:11:38 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 13:12:21 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:12:21 INFO FeHistory: [135030.33937649 105625.09619743 100613.23161746 ... 146741.36456153
 125515.12273777 128220.93938178]
2025-06-25 13:12:21 INFO Expected Optimum FE: -5000
2025-06-25 13:12:21 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 13:13:01 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:13:01 INFO FeHistory: [ 86743.86143119 127565.67925538 153495.46177769 ...  93601.89173036
 178023.77552417 189948.85007898]
2025-06-25 13:13:01 INFO Expected Optimum FE: -5000
2025-06-25 13:13:01 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 13:13:41 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:13:41 INFO FeHistory: [170804.81477682 203541.60686028 182644.16729356 ... 244890.59415397
 188356.16405648 209037.67101339]
2025-06-25 13:13:41 INFO Expected Optimum FE: -5000
2025-06-25 13:13:41 INFO Unimodal AOCC mean: nan
2025-06-25 13:13:41 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 13:13:41 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 13:13:41 INFO AOCC mean: 0.0000
2025-06-25 13:13:41 INFO Weighed AOCC mean: nan
2025-06-25 13:13:41 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 13:14:23 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:14:23 INFO FeHistory: [119380.07388639 152795.45129119 141977.91280777 ... 134215.03624172
 145573.9247603  122555.55940878]
2025-06-25 13:14:23 INFO Expected Optimum FE: -5000
2025-06-25 13:14:23 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 13:15:03 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:15:03 INFO FeHistory: [129518.03574775 126539.21833949 153391.90030043 ... 115470.96445654
 148574.35353382 179397.87785061]
2025-06-25 13:15:03 INFO Expected Optimum FE: -5000
2025-06-25 13:15:03 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 13:15:45 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:15:45 INFO FeHistory: [174527.15922297 234372.144316   113042.20582439 ... 138249.68167631
 176433.06367987 183808.7310893 ]
2025-06-25 13:15:45 INFO Expected Optimum FE: -5000
2025-06-25 13:15:45 INFO Unimodal AOCC mean: nan
2025-06-25 13:15:45 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 13:15:45 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 13:15:45 INFO AOCC mean: 0.0000
2025-06-25 13:15:45 INFO Weighed AOCC mean: nan
2025-06-25 13:15:45 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 13:16:29 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:16:29 INFO FeHistory: [ 74511.68859656 132245.46605474 204830.26586172 ... 135498.74883962
 132973.84941978 107087.35426869]
2025-06-25 13:16:29 INFO Expected Optimum FE: -5000
2025-06-25 13:16:29 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 13:17:11 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:17:11 INFO FeHistory: [125632.1344449  110086.04626546 130960.35760842 ... 174300.54201673
 173354.90509319 151927.27318876]
2025-06-25 13:17:11 INFO Expected Optimum FE: -5000
2025-06-25 13:17:11 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 13:17:53 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:17:53 INFO FeHistory: [157327.26747491 221456.74986897 143692.48284412 ... 176286.77022624
 180873.55751259 157124.17003691]
2025-06-25 13:17:53 INFO Expected Optimum FE: -5000
2025-06-25 13:17:53 INFO Unimodal AOCC mean: nan
2025-06-25 13:17:53 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 13:17:53 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 13:17:53 INFO AOCC mean: 0.0000
2025-06-25 13:17:53 INFO Weighed AOCC mean: nan
2025-06-25 13:17:53 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 13:18:35 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:18:35 INFO FeHistory: [113152.23896043 148246.4750133  173380.19432603 ... 144355.98153787
 125638.85593324 123624.19885609]
2025-06-25 13:18:35 INFO Expected Optimum FE: -5000
2025-06-25 13:18:35 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 13:19:15 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:19:15 INFO FeHistory: [162064.94715931 178519.38290078 200623.68389177 ... 175580.99567726
 154448.23518293 134249.17259503]
2025-06-25 13:19:15 INFO Expected Optimum FE: -5000
2025-06-25 13:19:15 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 13:19:55 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:19:55 INFO FeHistory: [136390.34347087 192884.46893905 166099.87764352 ... 171734.36308037
 225404.4800879  151645.35802551]
2025-06-25 13:19:55 INFO Expected Optimum FE: -5000
2025-06-25 13:19:55 INFO Unimodal AOCC mean: nan
2025-06-25 13:19:55 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 13:19:55 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 13:19:55 INFO AOCC mean: 0.0000
2025-06-25 13:19:55 INFO Weighed AOCC mean: nan
2025-06-25 13:19:55 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 13:20:37 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:20:37 INFO FeHistory: [154397.37675932 123044.06601369 174759.03956226 ... 148658.00965492
 135176.62183211 122298.86689078]
2025-06-25 13:20:37 INFO Expected Optimum FE: -5000
2025-06-25 13:20:37 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 13:21:18 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:21:18 INFO FeHistory: [144613.30075061 107377.8805588  174575.98866262 ... 124367.18782953
 144952.7146766  148881.91580198]
2025-06-25 13:21:18 INFO Expected Optimum FE: -5000
2025-06-25 13:21:18 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 13:21:57 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:21:57 INFO FeHistory: [159344.28737273 149951.60595232 199932.07568619 ... 100980.33520183
 161600.61333444 198397.52331394]
2025-06-25 13:21:57 INFO Expected Optimum FE: -5000
2025-06-25 13:21:57 INFO Unimodal AOCC mean: nan
2025-06-25 13:21:57 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 13:21:57 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 13:21:57 INFO AOCC mean: 0.0000
2025-06-25 13:21:57 INFO Weighed AOCC mean: nan
2025-06-25 13:21:57 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 13:22:39 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:22:39 INFO FeHistory: [158876.87967154 121551.15064191 140464.57429599 ... 133296.80143348
 118346.84059789 139053.41043501]
2025-06-25 13:22:39 INFO Expected Optimum FE: -5000
2025-06-25 13:22:39 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 13:23:18 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:23:18 INFO FeHistory: [129997.85538833 162729.71274659 153488.7051991  ... 179662.23233962
 165568.38419697 221225.95627517]
2025-06-25 13:23:18 INFO Expected Optimum FE: -5000
2025-06-25 13:23:18 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 13:23:59 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:23:59 INFO FeHistory: [174638.46757573 183988.10373582 176587.95659824 ...  79896.54416651
 245893.7913864  222922.28186595]
2025-06-25 13:23:59 INFO Expected Optimum FE: -5000
2025-06-25 13:23:59 INFO Unimodal AOCC mean: nan
2025-06-25 13:23:59 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 13:23:59 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 13:23:59 INFO AOCC mean: 0.0000
2025-06-25 13:23:59 INFO Weighed AOCC mean: nan
2025-06-25 13:23:59 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 13:24:42 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.7207
2025-06-25 13:24:42 INFO FeHistory: [114528.38672599 116508.66600474 137931.49870536 ... 146329.62343022
 137156.06432598 136543.49325716]
2025-06-25 13:24:42 INFO Expected Optimum FE: -5000
2025-06-25 13:24:42 INFO Good algorithm:
Algorithm Name: AdaptiveIslandDE
import numpy as np
import random

# Name: AdaptiveIslandDE
# Description: An island-based DE with adaptive migration, local search, and restart mechanisms to handle deceptive landscapes.
# Code:
class AdaptiveIslandDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.57133119173864,
                 mutation_rate: float = 0.4757202514505677, migration_interval: int = 712.7635867588241, migration_size: int = 4.761735109898917,
                 local_search_iterations: int = 13.790246754615877, perturbation_scale: float = 0.0962479940319347, restart_threshold: float = 0.9235917093742382):
        """
        Initializes the AdaptiveIslandDE optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search
            perturbation_scale (float): Scale of the random perturbation in local search.
            restart_threshold (float): Fraction of budget after which restart is triggered.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.perturbation_scale = perturbation_scale
        self.restart_threshold = restart_threshold

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a simple gradient-based method.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation
            perturbation = np.random.normal(0, self.perturbation_scale, self.dim) # Scale adjusted from 1 to 0.1
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants

            # Re-evaluate the fitness of the new solutions on the destination island (important!) and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness
             # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol




    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * self.restart_threshold:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
2025-06-25 13:24:42 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 13:25:22 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:25:22 INFO FeHistory: [104765.80951089  99220.42906488 175236.91550393 ... 143365.90176676
 245211.76040938 109401.04578501]
2025-06-25 13:25:22 INFO Expected Optimum FE: -5000
2025-06-25 13:25:22 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 13:26:02 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0598
2025-06-25 13:26:02 INFO FeHistory: [147307.62509659 144395.76952927 129066.67640302 ... 289769.73387423
 208099.00711904 156140.86873272]
2025-06-25 13:26:02 INFO Expected Optimum FE: -5000
2025-06-25 13:26:02 INFO Unimodal AOCC mean: nan
2025-06-25 13:26:02 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 13:26:02 INFO Multimodal (multiple components) AOCC mean: 0.2602
2025-06-25 13:26:02 INFO AOCC mean: 0.2602
2025-06-25 13:26:02 INFO Weighed AOCC mean: nan
2025-06-25 13:26:02 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 13:26:44 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:26:44 INFO FeHistory: [158547.3040511  128137.7816045  131600.64838043 ... 142778.48399434
 111623.89901545 150892.53001122]
2025-06-25 13:26:44 INFO Expected Optimum FE: -5000
2025-06-25 13:26:44 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 13:27:24 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:27:24 INFO FeHistory: [193259.54390215 156250.22322355 208862.64684838 ... 140628.64118627
 121877.29337281 154820.59929725]
2025-06-25 13:27:24 INFO Expected Optimum FE: -5000
2025-06-25 13:27:24 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 13:28:04 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:28:04 INFO FeHistory: [223021.37739401 107832.92053713 201860.05561595 ... 176890.16352824
 284495.68674213 129755.53302603]
2025-06-25 13:28:04 INFO Expected Optimum FE: -5000
2025-06-25 13:28:04 INFO Unimodal AOCC mean: nan
2025-06-25 13:28:04 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 13:28:04 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 13:28:04 INFO AOCC mean: 0.0000
2025-06-25 13:28:04 INFO Weighed AOCC mean: nan
2025-06-25 13:28:04 INFO Generation 1, best so far: 0.2952351239662642
2025-06-25 13:28:04 INFO Population length is: 10
2025-06-25 13:28:04 INFO --- Performing Long-Term Reflection at Generation 2 ---
2025-06-25 13:28:04 INFO Reflection Prompt: ### Problem Description
**(CR: Capacity and Role)**
Act as an expert in designing algorithms for deceptive, multi-component landscapes. Your specialty is creating strategies that use multi-population or island models to perform aggressive global exploration.

**(I: Insight)**
Your objective is to design a novel optimization algorithm for the GNBG benchmark. The most difficult functions (f16-f24) have multiple, separate basins of attraction where the global optimum can be hidden. An algorithm must be able to discover and explore these competing regions to succeed.

**(S: Statement & P: Personality)**
Provide a complete, novel Python class that implements a multi-population or island-based search strategy to solve this challenge. The class must have an `__init__(...)` and `optimize(...)` method as specified in the main task description.

### List heuristics
Below is a list of design heuristics ranked from best to worst based on their AOCC score on group function 3 of GNBG benchmark, where higher is better. To enable a detailed analysis of their specializations, the performance breakdown on each of the three GNBG function groups is also provided.
### Rank 1 (Overall AOCC Score on Multimodal instances with multiple components: 2.6016e-01# Name: AdaptiveIslandDE
# Description: 
# Code:
```python
import numpy as np
import random

# Name: AdaptiveIslandDE
# Description: An island-based DE with adaptive migration, local search, and restart mechanisms to handle deceptive landscapes.
# Code:
class AdaptiveIslandDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.57133119173864,
                 mutation_rate: float = 0.4757202514505677, migration_interval: int = 712.7635867588241, migration_size: int = 4.761735109898917,
                 local_search_iterations: int = 13.790246754615877, perturbation_scale: float = 0.0962479940319347, restart_threshold: float = 0.9235917093742382):
        """
        Initializes the AdaptiveIslandDE optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search
            perturbation_scale (float): Scale of the random perturbation in local search.
            restart_threshold (float): Fraction of budget after which restart is triggered.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.perturbation_scale = perturbation_scale
        self.restart_threshold = restart_threshold

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a simple gradient-based method.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation
            perturbation = np.random.normal(0, self.perturbation_scale, self.dim) # Scale adjusted from 1 to 0.1
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants

            # Re-evaluate the fitness of the new solutions on the destination island (important!) and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness
             # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol




    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * self.restart_threshold:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 2 (Overall AOCC Score on Multimodal instances with multiple components: 9.6527e-02# Name: AdaptiveIslandDE
# Description: An island model DE with adaptive migration and re-evaluation to escape local optima in deceptive landscapes.
# Code:
```python
import numpy as np
import random

# Name: AdaptiveIslandDE
# Description: An island model DE with adaptive migration and re-evaluation to escape local optima in deceptive landscapes.
# Code:
class AdaptiveIslandDE:
    """
    Implements an island model DE with adaptive migration and local search
    to aggressively explore multi-component landscapes.
    """

    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 500, migration_size: int = 2,
                 local_search_probability: float = 0.1):
        """
        Initializes the AdaptiveIslandDE optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_probability (float): Probability of performing local search after migration.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_probability = local_search_probability

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, individual: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs a simple local search around an individual.

        Args:
            individual (np.ndarray): The individual to start the local search from.
            objective_function (callable): The objective function.

        Returns:
            tuple: (Improved individual, improved fitness)
        """
        step_size = 0.01 * (self.upper_bounds - self.lower_bounds)  # Small step size
        best_individual = individual.copy()
        best_fitness = objective_function(best_individual.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(10):  # Limited iterations
            for i in range(self.dim):
                # Try perturbing each dimension
                original_value = best_individual[i]
                
                # Try positive perturbation
                best_individual[i] = min(self.upper_bounds[i], original_value + step_size[i])  # Ensure bounds
                fitness_plus = objective_function(best_individual.reshape(1, -1))[0]
                self.eval_count += 1

                if fitness_plus < best_fitness:
                    best_fitness = fitness_plus
                else:
                    best_individual[i] = original_value  # Reset

                # Try negative perturbation
                best_individual[i] = max(self.lower_bounds[i], original_value - step_size[i])  # Ensure bounds
                fitness_minus = objective_function(best_individual.reshape(1, -1))[0]
                self.eval_count += 1

                if fitness_minus < best_fitness:
                    best_fitness = fitness_minus
                else:
                    best_individual[i] = original_value  # Reset
                
        return best_individual, best_fitness

    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands. Each island sends its best
        individuals to a randomly chosen other island, and replaces
        migrants while applying local adaptation upon arrival.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            best_index = np.argmin(self.fitness_values[i])
            migrant = self.populations[i][best_index].copy()  # Important to copy

            #Select index for immigrants.
            worst_index = np.argmax(self.fitness_values[dest_island])

            # Replace the worst solutions on the destination island with the migrant
            self.populations[dest_island][worst_index] = migrant
            
            # Re-evaluate the fitness of the new solutions on the destination island (important!)
            migrant_reshaped = migrant.reshape(1,-1)
            new_fitness = objective_function(migrant_reshaped)[0]
            self.eval_count += 1
            self.fitness_values[dest_island][worst_index] = new_fitness
            #Perform a local adaptation phase (local search) to improve fitness, with a given probability
            if random.random() < self.local_search_probability:
                  adapted_migrant, adapted_fitness = self.local_search(migrant,objective_function)
                  self.populations[dest_island][worst_index] = adapted_migrant
                  self.fitness_values[dest_island][worst_index] = adapted_fitness

                  new_fitness = adapted_fitness
                  migrant = adapted_migrant

            # Update best fitness, if needed

            if new_fitness < self.best_fitnesses[dest_island]:
                self.best_fitnesses[dest_island] = new_fitness
                self.best_solutions[dest_island] = migrant
            if new_fitness < self.best_fitness_overall:
                self.best_fitness_overall = new_fitness
                self.best_solution_overall = migrant


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)



        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 3 (Overall AOCC Score on Multimodal instances with multiple components: 5.0480e-03# Name: FitnessAdaptiveIslandDE
# Description: Island-based DE with fitness-aware migration and dynamic local search to escape deceptive optima.
# Code:
```python
import numpy as np
import random

# Name: FitnessAdaptiveIslandDE
# Description: Island-based DE with fitness-aware migration and dynamic local search to escape deceptive optima.
# Code:
class FitnessAdaptiveIslandDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 500, migration_size: int = 2,
                 local_search_iterations: int = 10, local_search_probability: float = 0.1):
        """
        Initializes the FitnessAdaptiveIslandDE optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search.
            local_search_probability (float): Probability of performing local search on a new solution.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.local_search_probability = local_search_probability


        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands
        self.stagnation_counters = [0] * self.num_islands # stagnation detection


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]
        island_stagnation_threshold = self.budget // (5 * self.num_islands)  # Adaptive threshold

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Local Search with Probability
            if random.random() < self.local_search_probability:
                trial_vector, trial_fitness = self.local_search(trial_vector, objective_function)


            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness
                self.stagnation_counters[island_index] = 0 # Reset stagnation counter

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector
            else:
                self.stagnation_counters[island_index] += 1  # Increment stagnation counter

            #Restart mechanism when stagnating, adaptive restarts instead of fixed interval
            if self.stagnation_counters[island_index] > island_stagnation_threshold:
                self.populations[island_index] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                self.fitness_values[island_index] = objective_function(self.populations[island_index])
                self.eval_count += self.population_size
                best_index = np.argmin(self.fitness_values[island_index])
                self.best_fitnesses[island_index] = self.fitness_values[island_index][best_index]
                self.best_solutions[island_index] = self.populations[island_index][best_index]
                self.stagnation_counters[island_index] = 0  #reset counter
                if self.best_fitnesses[island_index] < self.best_fitness_overall:
                    self.best_fitness_overall = self.best_fitnesses[island_index]
                    self.best_solution_overall = self.best_solutions[island_index]


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a simple gradient-based method.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        # Adaptive step size
        step_size = 0.1 * (self.upper_bounds[0] - self.lower_bounds[0])  #Adjust step_size based on bound differences.
        
        for _ in range(self.local_search_iterations):
            # Create a small random perturbation
            perturbation = np.random.normal(0, step_size, self.dim)
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness

    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands based on fitness.
        Islands exchange information adaptively to improve convergence.
        """

        # Sort islands based on their best fitness
        island_indices = list(range(self.num_islands))
        island_indices.sort(key=lambda i: self.best_fitnesses[i])

        # Migrate from better islands to worse islands.
        num_migrate_pairs = self.num_islands // 2 #Half sends to the other Half for balance.

        for i in range(num_migrate_pairs):
             source_island = island_indices[i] #Best Half
             dest_island = island_indices[self.num_islands - 1 - i] #Worst Half.

              # Identify the best solutions on the source island
             source_island_fitness = self.fitness_values[source_island]
             best_indices = np.argsort(source_island_fitness)[:self.migration_size]
             migrants = self.populations[source_island][best_indices].copy()  # Important to copy
             migrant_fitnesses = source_island_fitness[best_indices].copy()

            # Identify the worst solutions on the destination island
             dest_island_fitness = self.fitness_values[dest_island]
             worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

              # Replace the worst solutions on the destination island with the migrants
             self.populations[dest_island][worst_indices] = migrants
             
             # Re-evaluate the fitness of the new solutions on the destination island (important!) and perform local search
             new_fitnesses = []
             for j in range(len(worst_indices)):
                 migrant = migrants[j]
                 migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                 new_fitnesses.append(fitness)
               
             dest_island_fitness[worst_indices] = new_fitnesses
             self.fitness_values[dest_island] = dest_island_fitness

              # Update best fitness, if needed
             for fit, sol in zip(new_fitnesses, migrants):
                 if fit < self.best_fitnesses[dest_island]:
                      self.best_fitnesses[dest_island] = fit
                      self.best_solutions[dest_island] = sol
                 if fit < self.best_fitness_overall:
                     self.best_fitness_overall = fit
                     self.best_solution_overall = sol


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 4 (Overall AOCC Score on Multimodal instances with multiple components: 1.7666e-05# Name: ArchipelagoDE
# Description: Island-based DE with fitness-aware migration and periodic population rejuvenation for multimodal landscapes.
# Code:
```python
import numpy as np
import random

# Name: ArchipelagoDE
# Description: Island-based DE with fitness-aware migration and periodic population rejuvenation for multimodal landscapes.
# Code:
class ArchipelagoDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float], num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7, differential_weight: float = 0.5, migration_interval: int = 5000, migration_size: int = 2, rejuvenation_rate: float = 0.05):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.differential_weight = differential_weight
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.rejuvenation_rate = rejuvenation_rate

        self.islands = []
        self.island_best_solutions = []
        self.island_best_fitnesses = []

        for _ in range(self.num_islands):
            population = np.random.uniform(low=self.lower_bounds, high=self.upper_bounds, size=(self.population_size, self.dim))
            self.islands.append(population)
            self.island_best_solutions.append(None)
            self.island_best_fitnesses.append(float('inf'))

    def differential_evolution_step(self, island_index: int, objective_function: callable):
        population = self.islands[island_index]
        new_population = np.copy(population)
        fitness_values = objective_function(population)
        self.eval_count += self.population_size

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)

            mutant = population[a] + self.differential_weight * (population[b] - population[c])
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

            # Crossover
            crossover_mask = np.random.rand(self.dim) < self.crossover_rate
            trial_vector = np.where(crossover_mask, mutant, population[i])

            # Evaluation
            fitness_trial = objective_function(trial_vector.reshape(1, -1))[0]
            self.eval_count += 1

            # Selection
            if fitness_trial < fitness_values[i]:
                new_population[i] = trial_vector
            else:
                new_population[i] = population[i]

        #Re-evaluate entire population with migrated values.
        fitness_values = objective_function(new_population)
        self.eval_count += self.population_size
                
        for i in range(self.population_size):
           
            if fitness_values[i] < self.island_best_fitnesses[island_index]:
                self.island_best_fitnesses[island_index] = fitness_values[i]
                self.island_best_solutions[island_index] = new_population[i]
                    
                if fitness_values[i] < self.best_fitness_overall:
                    self.best_fitness_overall = fitness_values[i]
                    self.best_solution_overall = new_population[i].copy()

        self.islands[island_index] = new_population
        return

    def migrate(self, objective_function: callable):
        # Fitness-aware migration: replace worst with best from other islands
        for i in range(self.num_islands):
            # Find index of worst individual on the current island
            worst_index = np.argmax(objective_function(self.islands[i]))
            self.eval_count += self.population_size

            # Select a random island to receive the migrant (excluding itself)
            possible_targets = list(range(self.num_islands))
            possible_targets.remove(i)
            if not possible_targets:
                continue

            target_island = random.choice(possible_targets)

            # Find index of best individual on the target island
            best_index_target = np.argmin(objective_function(self.islands[target_island]))
            self.eval_count += self.population_size

            # Only migrate if the best on the target is better than the worst on the current
            if objective_function(self.islands[target_island][best_index_target].reshape(1, -1))[0] < objective_function(self.islands[i][worst_index].reshape(1, -1))[0]:
                self.eval_count += 2
                # Replace the worst individual in current with BEST individual from target.
                self.islands[i][worst_index] = self.islands[target_island][best_index_target].copy()
                
                #Re-evaluate changed fitness.
                migrant_fitness = objective_function(self.islands[i][worst_index].reshape(1, -1))[0]
                self.eval_count += 1

                if migrant_fitness < self.island_best_fitnesses[i]:
                  self.island_best_fitnesses[i] = migrant_fitness
                  self.island_best_solutions[i] = self.islands[i][worst_index]
                  if migrant_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = migrant_fitness
                    self.best_solution_overall = self.islands[i][worst_index].copy()
                
    def rejuvenate_population(self, island_index: int):
          # Rejuvenate a portion of the population with random values.
          num_to_rejuvenate = int(self.rejuvenation_rate * self.population_size)
          indices_to_rejuvenate = random.sample(range(self.population_size), num_to_rejuvenate)
          self.islands[island_index][indices_to_rejuvenate] = np.random.uniform(low=self.lower_bounds, high=self.upper_bounds, size=(num_to_rejuvenate, self.dim))
          
    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.best_fitness_overall = float('inf')

        # Initialize island bests
        for island_index in range(self.num_islands):
            fitness_values = objective_function(self.islands[island_index])
            self.eval_count += self.population_size
            best_index = np.argmin(fitness_values)
            self.island_best_fitnesses[island_index] = fitness_values[best_index]
            self.island_best_solutions[island_index] = self.islands[island_index][best_index]

            if self.island_best_fitnesses[island_index] < self.best_fitness_overall:
                self.best_fitness_overall = self.island_best_fitnesses[island_index]
                self.best_solution_overall = self.island_best_solutions[island_index].copy()

        while self.eval_count < self.budget:
            for island_index in range(self.num_islands):
                self.differential_evolution_step(island_index, objective_function)
                
                #Periodic Rejuvenation
                if random.random() < 0.1 :
                    self.rejuvenate_population(island_index)
                    fitness_values = objective_function(self.islands[island_index])
                    self.eval_count += self.population_size
                    best_index = np.argmin(fitness_values)
                    self.island_best_fitnesses[island_index] = fitness_values[best_index]
                    self.island_best_solutions[island_index] = self.islands[island_index][best_index]

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)
                
        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 5 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AggressiveIslandDE
# Description: Island model DE with fitness-proportionate migration and adaptive mutation scaling.
# Code:
```python
import numpy as np
import random

# Name: AggressiveIslandDE
# Description: Island model DE with fitness-proportionate migration and adaptive mutation scaling.
# Code:
class AggressiveIslandDE:
    """
    Island model DE that adaptively scales mutation and migrates based on island fitness, promoting global exploration.
    """
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 initial_mutation_rate: float = 0.5, migration_interval: int = 5000, migration_size: int = 2,
                 mutation_adaptation_rate: float = 0.1):  #Added mutation_adaptation_rate
        """
        Initializes the AggressiveIslandDE optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            initial_mutation_rate (float): Initial DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            mutation_adaptation_rate (float): How quickly mutation rates are tuned
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = initial_mutation_rate  #Initial value
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.mutation_adaptation_rate = mutation_adaptation_rate

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands
        self.island_average_fitnesses = [float('inf')] * self.num_islands # Track island's avg fitness


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island, adapting the mutation rate.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]
        island_fitnesses = objective_function(population)
        self.eval_count += self.population_size #Eval count optimization
        fitness_values[:] = island_fitnesses
        
        #Update island averages
        self.island_average_fitnesses[island_index] = np.mean(fitness_values)


        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_fitness = objective_function(trial_vector.reshape(1, -1))[0] #Evaluate inline one at a time
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector
        # Adaptive mutation (adjust per-island)
        if np.std(fitness_values) > 0: #Avoid zero division
          if self.island_average_fitnesses[island_index] < np.mean(self.island_average_fitnesses):
            self.mutation_rate *= (1 + self.mutation_adaptation_rate)  # Increase mutation for better islands
          else:
            self.mutation_rate *= (1 - self.mutation_adaptation_rate)  # Decrease mutation for worse islands

        self.mutation_rate = np.clip(self.mutation_rate, 0.1, 1.0)
        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands based on a fitness-proportionate scheme.
        """
        # Calculate migration probabilities based on relative fitness of islands
        island_fitnesses = np.array(self.island_average_fitnesses)
        if np.sum(island_fitnesses) == 0:
           migration_probabilities = np.ones(self.num_islands) / self.num_islands
        else:
            migration_probabilities = np.max(island_fitnesses) - island_fitnesses
            migration_probabilities = migration_probabilities / np.sum(migration_probabilities)


        for i in range(self.num_islands):
            # Select a destination island based on probabilities (roulette wheel)
            dest_island = np.random.choice(self.num_islands, p=migration_probabilities) # Proportional Selection

            if dest_island == i:
                dest_island = (i + 1) % self.num_islands #Ensure not same island

            # Select migrants (best on source)
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size] #pick best
            migrants = self.populations[i][best_indices].copy() #Copy the actual populations to not use references

            # Replace worst individuals in dest island (exploitation)
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            self.populations[dest_island][worst_indices] = migrants #Replace WORST with migrant

            # Fast local Adaptation (reevaluate immediate migrants!)
            for k in range(self.migration_size):
                migrant_reshaped = migrants[k].reshape(1,-1)
                new_fitness = objective_function(migrant_reshaped)[0]
                self.eval_count += 1
                self.fitness_values[dest_island][worst_indices[k]] = new_fitness # assign reevaluated

                # Quick Upgrade if needed for island (or global)
                if new_fitness < self.best_fitnesses[dest_island]:
                   self.best_fitnesses[dest_island] = new_fitness
                   self.best_solutions[dest_island] = migrants[k]

                if new_fitness < self.best_fitness_overall:
                   self.best_fitness_overall = new_fitness
                   self.best_solution_overall = migrants[k]



    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
          self.fitness_values[i] = objective_function(self.populations[i])
          self.eval_count += self.population_size # Batch update to optimize eval count
          best_index = np.argmin(self.fitness_values[i])
          self.best_fitnesses[i] = self.fitness_values[i][best_index]
          self.best_solutions[i] = self.populations[i][best_index]
          self.island_average_fitnesses[i] = np.mean(self.fitness_values[i])

          if self.best_fitnesses[i] < self.best_fitness_overall:
            self.best_fitness_overall = self.best_fitnesses[i]
            self.best_solution_overall = self.best_solutions[i]



        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)



        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 6 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: IslandModelAdaptiveDE
# Description: Island model using Adaptive DE with fitness-based migration to balance exploration/exploitation.
# Code:
```python
import numpy as np
import random

# Name: IslandModelAdaptiveDE
# Description: Island model using Adaptive DE with fitness-based migration to balance exploration/exploitation.
# Code:
class IslandModelAdaptiveDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, F: float = 0.5, Cr: float = 0.7,
                 migration_interval: int = 500, migration_size: int = 2, adaptive_pop_rate: float = 0.1):
        """
        Initialize the Island Model Adaptive Differential Evolution algorithm.

        Args:
            budget (int): The maximum number of function evaluations.
            dim (int): The dimensionality of the problem.
            lower_bounds (list[float]): The lower bounds for each dimension.
            upper_bounds (list[float]): The upper bounds for each dimension.
            num_islands (int): The number of islands in the model.
            population_size (int): The population size of each island.
            F (float): The mutation factor for differential evolution.
            Cr (float): The crossover rate for differential evolution.
            migration_interval (int): The interval (in evaluations) at which migration occurs.
            migration_size (int): The number of individuals to migrate between islands.
            adaptive_pop_rate (float): Rate to adjust population size.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.num_islands = num_islands
        self.population_size = population_size
        self.F = F
        self.Cr = Cr
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.adaptive_pop_rate = adaptive_pop_rate

        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            fitness = np.full(self.population_size, float('inf'))  # Initialize fitness to infinity
            self.islands.append({'population': population, 'fitness': fitness})


    def differential_evolution_step(self, island: dict, objective_function: callable):
        """
        Perform a differential evolution step on a single island.
        """
        population = island['population']
        fitness = island['fitness']
        new_population = np.copy(population)
        new_fitness = np.copy(fitness)

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            if len(indices) < 3: #Need at least 3
                continue

            a, b, c = random.sample(indices, 3)
            mutant = population[a] + self.F * (population[b] - population[c])
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

            # Crossover
            crossover_mask = np.random.rand(self.dim) < self.Cr
            trial_vector = np.where(crossover_mask, mutant, population[i])

            # Evaluation

            trial_fitness = objective_function(trial_vector.reshape(1, -1))[0] #Reshape is critical
            self.eval_count += 1
            if trial_fitness < fitness[i]:
                new_population[i] = trial_vector
                new_fitness[i] = trial_fitness

                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector.copy()  # Critical copy
        island['population'] = new_population
        island['fitness'] = new_fitness


    def migrate_individuals(self):
         """
         Migrate individuals between islands based on fitness. The "best" individual from a donor island is sent to a recipient island,
         replacing a "worst" individual. The transplanted individual's fitness is immediately re-evaluated in its new environment.
         """

         # Select a donor island with higher probability based on number of evaluations
         donor_island_index = random.randint(0, self.num_islands-1)
         donor_island = self.islands[donor_island_index]

         # Select recipient islands
         recipient_indices = list(range(self.num_islands))
         recipient_indices.remove(donor_island_index)

         random.shuffle(recipient_indices) # In-place shuffle is preferred for efficiency
         recipient_indices = recipient_indices[:self.migration_size]

         #Select migrants from the donor island
         sorted_indices = np.argsort(donor_island['fitness'])
         migrants = donor_island['population'][sorted_indices[:self.migration_size]]
         migrant_fitnesses = donor_island['fitness'][sorted_indices[:self.migration_size]]

         # Transplant: Send the migrants to selected island:
         for recipient_index in recipient_indices:
             recipient_island = self.islands[recipient_index]
             worst_indices = np.argsort(recipient_island['fitness'])[::-1]  #Reverse sort
             #Replace the worst with migrants.

             recipient_island['population'][worst_indices[:self.migration_size]] = migrants.copy()

             #Fitness re-evaluation critical to determine value within recipient environment.
             needs_eval_indices = worst_indices[:self.migration_size]
             for idx in needs_eval_indices:
                 recipient_island['fitness'][idx] = float('inf')  #Fitness needs eval.

         #Post condition. Fitness should be consistent across all islands after return

    def adjust_population_size(self, island: dict, objective_function: callable, min_pop_size: int, max_pop_size: int):
         """Adjust the population size of an island based on its performance."""

         if random.random() < self.adaptive_pop_rate:
            current_pop_size = len(island['population'])

            # Define stagnation:
            if self.best_fitness_overall == island['fitness'][np.argmin(island['fitness'])]: #Stagnation
                new_size = min(int(current_pop_size * 1.1), max_pop_size) #Increase for exploitation

            else:  #Exploration: Reduction
                new_size = max(int(current_pop_size * 0.9), min_pop_size)

            new_size = int(new_size)

            if new_size > current_pop_size:  #Need more, so expand with random
                additional = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(new_size - current_pop_size, self.dim))
                additional_fitness = objective_function(additional)
                self.eval_count += len(additional) #critical

                island['population'] = np.vstack((island['population'], additional))
                island['fitness'] = np.concatenate((island['fitness'], additional_fitness))
            elif new_size < current_pop_size:   #Need less, reduce population and fitness
                best_indices = np.argsort(island['fitness'])[:new_size]

                island['population'] = island['population'][best_indices] #Reduce down populations, no copies needed.
                island['fitness'] = island['fitness'][best_indices]


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimize the given objective function using the island model adaptive DE algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): The acceptance threshold for convergence (not used here).

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """

        self.eval_count = 0
        self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        self.best_fitness_overall = float('inf')

        generation = 0
        min_pop_size = self.population_size // 2 if self.population_size // 2 > 2 else 3 #Ensure enough sample
        max_pop_size = self.population_size * 2 #Can be larger.
        pop_size_adjust_interval = 250  #Adjust per interval
        while self.eval_count < self.budget:
            generation += 1
            for island in self.islands:
                 #First handle new migrants

                 needs_eval = np.isinf(island['fitness'])
                 num_to_eval = np.sum(needs_eval)
                 if num_to_eval > 0: #Slow fitness computation

                        X = island['population'][needs_eval].reshape(num_to_eval,-1)
                        fitness_vals = objective_function(X) #Eval is costly. Do in batch!
                        island['fitness'][needs_eval] = fitness_vals  #Batch update

                        self.eval_count += num_to_eval  #Record evals

                        best_in_batch_idx = np.argmin(fitness_vals)
                        #Update solution, if it improves
                        if fitness_vals[best_in_batch_idx] < self.best_fitness_overall:

                             self.best_fitness_overall = fitness_vals[best_in_batch_idx]
                             self.best_solution_overall = island['population'][needs_eval][best_in_batch_idx].copy() #Deep copy, as mutation will re-occur.



                 #Run different evolutions to improve population.
                 self.differential_evolution_step(island, objective_function)

                 if (generation * self.num_islands * self.population_size) % pop_size_adjust_interval == 0 :
                     #Check stagnations, which may affect how population size increases to resolve stuck behavior.
                     self.adjust_population_size(island, objective_function, min_pop_size, max_pop_size)

                 if self.eval_count >= self.budget:
                      break #Term

            #Migrate after evolutions is performed.
            if (generation * self.population_size * self.num_islands) > self.migration_interval: #Migration must occur slower. Ensure complete iteration.

                self.migrate_individuals()
                generation = 0

            if self.eval_count >= self.budget: #Check budget frequently for optimization to prevent extra evaluations.
                    break

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }

        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 7 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptiveMigratingIslandsDE
# Description: Combines island model DE with adaptive migration based on island fitness diversity, and immediate migrant adaptation.
# Code:
```python
import numpy as np
import random

# Name: AdaptiveMigratingIslandsDE
# Description: Combines island model DE with adaptive migration based on island fitness diversity, and immediate migrant adaptation.
# Code:
class AdaptiveMigratingIslandsDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float], num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7, mutation_factor: float = 0.5, migration_interval: int = 500, migration_size: int = 2, diversity_threshold: float = 0.01):
        """
        Initializes the AdaptiveMigratingIslandsDE algorithm.

        Args:
            budget: Maximum number of function evaluations.
            dim: Problem dimensionality.
            lower_bounds: List of lower bounds for each dimension.
            upper_bounds: List of upper bounds for each dimension.
            num_islands: Number of islands in the archipelago.
            population_size: Number of individuals in each island's population.
            crossover_rate: Crossover rate for Differential Evolution.
            mutation_factor: Mutation factor for Differential Evolution.
            migration_interval: Number of evaluations between migrations.
            migration_size: Number of individuals to migrate between islands.
            diversity_threshold: Threshold for triggering migration based on fitness diversity.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_factor = mutation_factor
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.diversity_threshold = diversity_threshold

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize islands and their populations
        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            self.islands.append(population)

        # Island specific best solutions and their fitnesses
        self.island_best_solutions = [None] * self.num_islands
        self.island_best_fitness = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable) -> None:
        """
        Performs one step of Differential Evolution on a given island.

        Args:
            island_index: Index of the island to perform DE on.
            objective_function: The objective function to be minimized.
        """
        population = self.islands[island_index]
        fitness_values = objective_function(population)
        self.eval_count += self.population_size

        # Update island best
        best_index = np.argmin(fitness_values)
        if fitness_values[best_index] < self.island_best_fitness[island_index]:
            self.island_best_fitness[island_index] = fitness_values[best_index]
            self.island_best_solutions[island_index] = population[best_index].copy()

            if self.island_best_fitness[island_index] < self.best_fitness_overall:
                self.best_fitness_overall = self.island_best_fitness[island_index]
                self.best_solution_overall = self.island_best_solutions[island_index].copy()

        for i in range(self.population_size):
            # Choose three random individuals, distinct from each other and the current individual
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)

            # Mutation
            mutant = population[a] + self.mutation_factor * (population[b] - population[c])

            # Ensure the mutant stays within bounds
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

            # Crossover
            crossover_mask = np.random.rand(self.dim) < self.crossover_rate
            trial_vector = np.where(crossover_mask, mutant, population[i])

            # Evaluate the trial vector
            trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]
            self.eval_count += 1  # Increment eval_count for the single evaluation

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                if trial_fitness < self.island_best_fitness[island_index]:
                    self.island_best_fitness[island_index] = trial_fitness
                    self.island_best_solutions[island_index] = trial_vector.copy()

                    if trial_fitness < self.best_fitness_overall:
                        self.best_fitness_overall = trial_fitness
                        self.best_solution_overall = trial_vector.copy()

        self.islands[island_index] = population  # Update population


    def migrate_individuals(self, objective_function: callable) -> None:
        """
        Migrates the best individuals between islands based on fitness diversity. Implements immediate adaptation.
        """
        # Calculate fitness diversity among islands. Trigger migration if diversity is high.
        fitness_std = np.std(self.island_best_fitness)
        if fitness_std < self.diversity_threshold:
            return  # Skip migration if islands are too similar.

        # Find the best and worst performing islands.
        best_island_index = np.argmin(self.island_best_fitness)
        worst_island_index = np.argmax(self.island_best_fitness)
        
        # Migrate the best individual from the best island to the worst.
        immigrant = self.island_best_solutions[best_island_index].copy()

        # Replace a random individual in the worst island with the immigrant.
        replace_index = random.randint(0, self.population_size - 1)
        self.islands[worst_island_index][replace_index] = immigrant

        # Immediately adapt the immigrant via a few DE steps within the new island *before* recalculating
        # best fitness metrics for the island, because the immigrant isn't adapted at all.
        for _ in range(3):  # Three DE steps for local adaptation in new environment.
            self.differential_evolution_step(worst_island_index, objective_function)
        
        #Re-evaluate fitness in worst performing island *now*
        population = self.islands[worst_island_index]
        fitness_values = objective_function(population)
        self.eval_count += self.population_size
        best_index = np.argmin(fitness_values)

        if fitness_values[best_index] < self.island_best_fitness[worst_island_index]:
            self.island_best_fitness[worst_island_index] = fitness_values[best_index]
            self.island_best_solutions[worst_island_index] = population[best_index].copy()

            if self.island_best_fitness[worst_island_index] < self.best_fitness_overall:
                self.best_fitness_overall = self.island_best_fitness[worst_island_index]
                self.best_solution_overall = self.island_best_solutions[worst_island_index].copy()


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the objective function using Adaptive Island-based Differential Evolution.

        Args:
            objective_function: The objective function to be minimized.
            acceptance_threshold: Threshold for early stopping (not used in this implementation).

        Returns:
            A tuple containing the best solution, best fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run

        # Initialize islands and find initial best solutions
        for i in range(self.num_islands):
            fitness_values = objective_function(self.islands[i])
            self.eval_count += self.population_size
            best_index = np.argmin(fitness_values)
            self.island_best_fitness[i] = fitness_values[best_index]
            self.island_best_solutions[i] = self.islands[i][best_index].copy()

            if self.island_best_fitness[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.island_best_fitness[i]
                self.best_solution_overall = self.island_best_solutions[i].copy()

        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            # Migrate individuals between islands periodically and adaptively
            if self.eval_count % self.migration_interval == 0 and self.eval_count > 0:
                self.migrate_individuals(objective_function)

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 8 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: IslandAdaptiveDifferentialEvolution
# Description: An island model with adaptive mutation and fitness-recalculated migration for global exploration.
# Code:
```python
import numpy as np
import random

# Name: IslandAdaptiveDifferentialEvolution
# Description: An island model with adaptive mutation and fitness-recalculated migration for global exploration.
# Code:
class IslandAdaptiveDifferentialEvolution:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float], num_islands: int = 5, population_size: int = 50, migration_interval: int = 1000, migration_size: int = 5, crossover_rate: float = 0.9):
        """
        Initializes the Island Differential Evolution algorithm.

        Args:
            budget (int): The maximum number of function evaluations.
            dim (int): The dimensionality of the problem.
            lower_bounds (list[float]): A list of the lower bounds for each dimension.
            upper_bounds (list[float]): A list of the upper bounds for each dimension.
            num_islands (int): The number of islands in the island model.
            population_size (int): The population size for each island.
            migration_interval (int): The number of evaluations between migrations.
            migration_size (int): The number of individuals to migrate between islands.
            crossover_rate (float): Probability of crossover for DE.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = int(num_islands)
        self.population_size = int(population_size)
        self.migration_interval = int(migration_interval)
        self.migration_size = int(migration_size)
        self.crossover_rate = float(crossover_rate)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = []
        self.fitnesses = []
        self.best_solutions = []
        self.best_fitnesses = []
        self.mutation_factors = []  # Adaptive mutation factors for each island
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            self.populations.append(population)
            self.fitnesses.append(np.full(self.population_size, float('inf')))  # Initialize fitnesses to infinity
            self.best_solutions.append(None)
            self.best_fitnesses.append(float('inf'))
            self.mutation_factors.append(0.5)  # Initialize with a default mutation factor

    def differential_evolution(self, population, fitnesses, objective_function, mutation_factor):
        """
        Performs differential evolution on a single population with adaptive mutation.

        Args:
            population (np.ndarray): The current population.
            fitnesses (np.ndarray): The fitness values of the current population.
            objective_function (callable): The objective function to evaluate.
            mutation_factor (float): The mutation factor for the current generation.

        Returns:
            tuple: A tuple containing the updated population, fitnesses, best solution, and best fitness.
        """
        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant = population[a] + mutation_factor * (population[b] - population[c])  # DE/rand/1

            # Crossover
            crossover_mask = np.random.rand(self.dim) < self.crossover_rate
            trial_vector = np.where(crossover_mask, mutant, population[i])

            # Ensure bounds are respected
            trial_vector = np.clip(trial_vector, self.lower_bounds, self.upper_bounds)

            # Evaluation
            trial_vector = trial_vector.reshape(1, -1) #Ensure input is (1, dim)
            trial_fitness = objective_function(trial_vector)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitnesses[i]:
                population[i] = trial_vector.flatten()
                fitnesses[i] = trial_fitness
                if trial_fitness < self.best_fitness_overall:
                     self.best_fitness_overall = trial_fitness
                     self.best_solution_overall = trial_vector.flatten()

        best_index = np.argmin(fitnesses)
        best_solution = population[best_index]
        best_fitness = fitnesses[best_index]

        return population, fitnesses, best_solution, best_fitness

    def migrate_individuals(self, objective_function):
        """
        Migrates individuals between islands, re-evaluating fitness after migration.
        """
        # For each island, send migration_size best individuals to a randomly chosen other island.
        for i in range(self.num_islands):
            # Select a random destination island that is not the current island.
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best individuals on the current island.
            best_indices = np.argsort(self.fitnesses[i])[:self.migration_size]

            # Transfer the best individuals to the destination island, replacing random individuals there. Instead of replacing the WORST, replace random.
            replace_indices = np.random.choice(self.population_size, self.migration_size, replace=False)  # Select random indices for replacement
            self.populations[dest_island][replace_indices] = self.populations[i][best_indices].copy()

            # Reevaluate fitnesses of these copied individuals - IMPORTANT
            X = self.populations[dest_island][replace_indices]
            self.fitnesses[dest_island][replace_indices] = objective_function(X)
            self.eval_count += len(replace_indices)

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the objective function using an island model with differential evolution and migration.

        Args:
            objective_function (callable): The objective function to evaluate.
            acceptance_threshold (float): The acceptance threshold for early stopping (currently not used).

        Returns:
            tuple: A tuple containing the best solution, best fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        if self.dim > 0:
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        else:
            self.best_solution_overall = np.array([])
        self.best_fitness_overall = float('inf')

        generation = 0
        while self.eval_count < self.budget:

            for i in range(self.num_islands):
                # Evaluate the initial population
                if generation == 0:
                    X = self.populations[i]
                    self.fitnesses[i] = objective_function(X)
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitnesses[i])
                    self.best_solutions[i] = self.populations[i][best_index]
                    self.best_fitnesses[i] = self.fitnesses[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]

                # Perform differential evolution on each island
                self.populations[i], self.fitnesses[i], best_solution_island, best_fitness_island = self.differential_evolution(
                    self.populations[i], self.fitnesses[i], objective_function, self.mutation_factors[i])

                # Update best solution for the island
                if best_fitness_island < self.best_fitnesses[i]:
                    self.best_fitnesses[i] = best_fitness_island
                    self.best_solutions[i] = best_solution_island

                # Update the overall best solution
                if best_fitness_island < self.best_fitness_overall:
                    self.best_fitness_overall = best_fitness_island
                    self.best_solution_overall = best_solution_island
                    
                 # Adjust mutation factor - Adaptive strategy (example)
                if generation % 10 == 0: # Tune every n generations
                    if np.std(self.fitnesses[i]) < 1e-6: #Stagnation
                        self.mutation_factors[i] *= 1.2  # Increase mutation
                    else:
                         self.mutation_factors[i] *= 0.9 # Reduce mutation
                    self.mutation_factors[i] = np.clip(self.mutation_factors[i], 0.1, 1.0)


            # Perform migration
            if (self.eval_count // self.population_size) % (self.migration_interval // self.population_size) == 0 and self.eval_count > 0:
                self.migrate_individuals(objective_function)
                

            generation += 1

        if self.best_solution_overall is None and self.dim > 0:  # Fallback
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 9 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: IslandModelAdaptiveDE
# Description: Employs an island model DE with adaptive parameters and fitness-aware migration for multimodal optimization.
# Code:
```python
import numpy as np
import random

# Name: IslandModelAdaptiveDE
# Description: Employs an island model DE with adaptive parameters and fitness-aware migration for multimodal optimization.
# Code:
class IslandModelAdaptiveDE:
    """
    Implements an island model differential evolution algorithm with adaptive
    crossover rate, differential weight, and fitness-aware migration to
    handle deceptive, multi-component landscapes.
    """

    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20,
                 migration_interval: int = 5000, migration_size: int = 2):
        """
        Initializes the IslandModelAdaptiveDE optimizer.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.migration_interval = migration_interval
        self.migration_size = migration_size

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands

        # Adaptive parameters
        self.crossover_rates = [0.7] * self.num_islands  # Initialize crossover rates
        self.differential_weights = [0.5] * self.num_islands  # Initialize differential weights



    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island,
        including adaptive parameter adjustments.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]
        cr = self.crossover_rates[island_index]
        fw = self.differential_weights[island_index]
        
        new_population = np.copy(population)  # Create a copy to avoid modifying directly

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + fw * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)

            # Crossover
            trial_vector = np.copy(population[i])
            crossover_mask = np.random.rand(self.dim) < cr
            trial_vector = np.where(crossover_mask, mutant_vector, population[i])
           
            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                new_population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector.copy()  # Important to copy

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector.copy()

            else:
                 new_population[i] = population[i] # Important in DE to keep old

        self.populations[island_index] = new_population
        self.fitness_values[island_index] = fitness_values # Update values for DE


        # Adapt crossover rate and differential weight (simple adaptation)
        if random.random() < 0.1:  # Adjust parameters probabilistically
           self.crossover_rates[island_index] = np.clip(self.crossover_rates[island_index] + random.uniform(-0.1, 0.1), 0.1, 0.9)
           self.differential_weights[island_index] = np.clip(self.differential_weights[island_index] + random.uniform(-0.1, 0.1), 0.1, 0.9)


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands, focusing on fitness diversity
        and rapid local adaptation.
        """

        # Fitness-aware migration: Islands send their *best* to the *worst* performing
        # islands, to inject diversity and accelerate convergence in those islands.

        source_island_index = np.argmax(self.best_fitnesses) # Worst-performing
        dest_island_index = np.argmin(self.best_fitnesses)  # Best-performing
        
        # Ensure indices are different
        if source_island_index == dest_island_index:
           island_indices = list(range(self.num_islands))
           random.shuffle(island_indices)
           source_island_index = island_indices[0]
           dest_island_index = island_indices[1]

        # Identify the best solutions on the source island
        best_indices = np.argsort(self.fitness_values[source_island_index])[:self.migration_size]
        migrants = self.populations[source_island_index][best_indices].copy()  # Important to copy

        # Identify the *worst* solutions on the destination island
        worst_indices = np.argsort(self.fitness_values[dest_island_index])[-self.migration_size:]

        # Replace the worst solutions on the destination island with the migrants
        self.populations[dest_island_index][worst_indices] = migrants

        # Re-evaluate the fitness of the new solutions on the destination island (crucial!)
        new_fitness = []
        for j in range(len(worst_indices)):
          migrant_reshaped = migrants[j].reshape(1,-1)
          new_fitness.append(float(objective_function(migrant_reshaped)[0]))
          self.eval_count += 1

        self.fitness_values[dest_island_index][worst_indices] = new_fitness

        # Update best fitness of the destination island, if needed
        for fit, sol in zip(new_fitness, migrants):
            if fit < self.best_fitnesses[dest_island_index]:
                self.best_fitnesses[dest_island_index] = fit
                self.best_solutions[dest_island_index] = sol.copy() # Important copy
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol.copy()  #Important copy

        # Local Adaptation: Apply a few DE steps *only* to the migrants after migration
        for _ in range(3): # 3 DE Steps after Migration
           for idx, migrant_idx in enumerate(worst_indices): #Migrant Indices
              # DE Step *on only the migrant* which landed in dest_island_index
              indices = list(range(self.population_size))
              indices.remove(migrant_idx)
              a, b, c = random.sample(indices, 3) #Random Samples - a, b, c indexes

              mutant_vector = self.populations[dest_island_index][a] + self.differential_weights[dest_island_index] * (self.populations[dest_island_index][b] - self.populations[dest_island_index][c])
              mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)

              # Crossover w/ migrant
              trial_vector = np.copy(self.populations[dest_island_index][migrant_idx])
              crossover_mask = np.random.rand(self.dim) < self.crossover_rates[dest_island_index]
              trial_vector = np.where(crossover_mask, mutant_vector, self.populations[dest_island_index][migrant_idx])

              #Evaluation
              trial_vector_reshaped = trial_vector.reshape(1, -1)
              trial_fitness = objective_function(trial_vector_reshaped)[0]
              self.eval_count += 1

              if trial_fitness < self.fitness_values[dest_island_index][migrant_idx]:
                 self.populations[dest_island_index][migrant_idx] = trial_vector
                 self.fitness_values[dest_island_index][migrant_idx] = trial_fitness # Replace Fit Value

                 #Update BEST_SOLUTION in destination ISLAND_INDEX
                 if trial_fitness < self.best_fitnesses[dest_island_index]:
                    self.best_fitnesses[dest_island_index] = trial_fitness
                    self.best_solutions[dest_island_index] = trial_vector

                 #Update BEST_SOLUTION globally
                 if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector #Store solution



    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run


        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i].copy()



        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)



        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```



### Guide
Keep in mind, this is a list of design heuristics ranked from best to worst. The first algorithm in the list is the best performing on average, and the last is the worst.
Your response must be in Markdown format and contain nothing else. It must have the following structure:

"**Analysis:**
**Experience:**"

In there:
+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.
Example: "Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:"

+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).

I'm going to tip $999K for a better heuristics! Let's think step by step.
2025-06-25 13:28:10 INFO Full response text: **Analysis:**
Comparing (Rank 1) vs (Rank 9), we see the top algorithm `AdaptiveIslandDE` leverages local search with perturbation after migration, along with a restart mechanism based on a threshold, whereas Rank 9, `IslandModelAdaptiveDE`, uses fitness-aware migration and simpler adaptive crossover/differential weight adjustments.

(Rank 2) vs (Rank 8): `AdaptiveIslandDE` uses local search and single migrant replacement while Rank 8 includes population re-evaluation and adaptive mutation rates but without targeted local search.

(Rank 1) vs (Rank 2), we see that Rank 1's aggressive exploration uses specific defined, empirically optimized constants, while (Rank 2) exploration focuses on re-evaluating migrants and probabilistic local searches. Rank 1 also has a clear stagnation restart in its optimize function.

(Rank 3) vs (Rank 4):  Rank 3 incorporates island-specific stagnation counters and fitness-aware migration, whereas Rank 4 employs periodic population rejuvenation. Restart mechanism based on counter gives better performance than population rejuvenation which make slower progress.

(Rank 8) vs (Rank 9), we see `IslandAdaptiveDifferentialEvolution` use more simplistic evaluation and mutation strategies, where all fitness needs update. While `IslandModelAdaptiveDE` implement adaptive crossovers for faster improvement. All fitness has initial evaluation to improve better mutation exploration at the start.

Comparing (second worst) vs (worst), we see both performing nearly as good as each other. One use DE step to adapt migrants while other makes periodic rejuvenation by reinitialize worse individual which contributes near same result. Overall: The most effective strategies blend differential evolution with island models and incorporate some form of local search or fine-tuning after migration. More critically, incorporating restart mechanisms when near stagnation improves the efficacy. Further, the fitness reevaluation is vital. Additionally, adaptation of parameters dynamically helps a ton. Further, more computationally cheap evaluations through vector optimizations improve results.

**Experience:**
Island-based DE needs local search after migration, restart mechanisms, and adaptive parameter control for high performance. Fitness reevaluation of each islands improves long-term quality too. Batch calculations over single calculation also improve efficacy too.

2025-06-25 13:28:11 INFO Full response text: Okay, I will refine "Current self-reflection" avoiding common pitfalls to generate heuristics for island-based Differential Evolution (DE).

Here's the revised, targeted self-reflection to design better heuristics:

*   **Keywords:** Adaptation, local search, migration, re-evaluation, modularity, parameter control, bound handling.
*   **Advice:** Design migration strategies that leverage fitness information to seed local search effectively. Prioritize modules for DE operations. Implement fast fitness re-evaluation immediately post-migration.
*   **Avoid:** Neglecting transplanted individual evolution after migration, static parameters, or ineffective bounds handling.
*   **Explanation:** Focus on adaptive local optimization *after* transplant while reusing performance of prior evolution. Avoid stagnancy via parameter adapting.

2025-06-25 13:28:11 INFO Generating offspring via Crossover...
2025-06-25 13:38:34 INFO Crossover Prompt: **(CR: Capacity and Role)**
Act as an expert in designing algorithms for deceptive, multi-component landscapes. Your specialty is creating strategies that use multi-population or island models to perform aggressive global exploration.

**(I: Insight)**
Your objective is to design a novel optimization algorithm for the GNBG benchmark. The most difficult functions (f16-f24) have multiple, separate basins of attraction where the global optimum can be hidden. An algorithm must be able to discover and explore these competing regions to succeed.

**(S: Statement & P: Personality)**
Provide a complete, novel Python class that implements a multi-population or island-based search strategy to solve this challenge. The class must have an `__init__(...)` and `optimize(...)` method as specified in the main task description.


### Better code
AdaptiveMigratingIslandsDE
import numpy as np
import random

# Name: AdaptiveMigratingIslandsDE
# Description: Combines island model DE with adaptive migration based on island fitness diversity, and immediate migrant adaptation.
# Code:
class AdaptiveMigratingIslandsDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float], num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7, mutation_factor: float = 0.5, migration_interval: int = 500, migration_size: int = 2, diversity_threshold: float = 0.01):
        """
        Initializes the AdaptiveMigratingIslandsDE algorithm.

        Args:
            budget: Maximum number of function evaluations.
            dim: Problem dimensionality.
            lower_bounds: List of lower bounds for each dimension.
            upper_bounds: List of upper bounds for each dimension.
            num_islands: Number of islands in the archipelago.
            population_size: Number of individuals in each island's population.
            crossover_rate: Crossover rate for Differential Evolution.
            mutation_factor: Mutation factor for Differential Evolution.
            migration_interval: Number of evaluations between migrations.
            migration_size: Number of individuals to migrate between islands.
            diversity_threshold: Threshold for triggering migration based on fitness diversity.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_factor = mutation_factor
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.diversity_threshold = diversity_threshold

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize islands and their populations
        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            self.islands.append(population)

        # Island specific best solutions and their fitnesses
        self.island_best_solutions = [None] * self.num_islands
        self.island_best_fitness = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable) -> None:
        """
        Performs one step of Differential Evolution on a given island.

        Args:
            island_index: Index of the island to perform DE on.
            objective_function: The objective function to be minimized.
        """
        population = self.islands[island_index]
        fitness_values = objective_function(population)
        self.eval_count += self.population_size

        # Update island best
        best_index = np.argmin(fitness_values)
        if fitness_values[best_index] < self.island_best_fitness[island_index]:
            self.island_best_fitness[island_index] = fitness_values[best_index]
            self.island_best_solutions[island_index] = population[best_index].copy()

            if self.island_best_fitness[island_index] < self.best_fitness_overall:
                self.best_fitness_overall = self.island_best_fitness[island_index]
                self.best_solution_overall = self.island_best_solutions[island_index].copy()

        for i in range(self.population_size):
            # Choose three random individuals, distinct from each other and the current individual
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)

            # Mutation
            mutant = population[a] + self.mutation_factor * (population[b] - population[c])

            # Ensure the mutant stays within bounds
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

            # Crossover
            crossover_mask = np.random.rand(self.dim) < self.crossover_rate
            trial_vector = np.where(crossover_mask, mutant, population[i])

            # Evaluate the trial vector
            trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]
            self.eval_count += 1  # Increment eval_count for the single evaluation

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                if trial_fitness < self.island_best_fitness[island_index]:
                    self.island_best_fitness[island_index] = trial_fitness
                    self.island_best_solutions[island_index] = trial_vector.copy()

                    if trial_fitness < self.best_fitness_overall:
                        self.best_fitness_overall = trial_fitness
                        self.best_solution_overall = trial_vector.copy()

        self.islands[island_index] = population  # Update population


    def migrate_individuals(self, objective_function: callable) -> None:
        """
        Migrates the best individuals between islands based on fitness diversity. Implements immediate adaptation.
        """
        # Calculate fitness diversity among islands. Trigger migration if diversity is high.
        fitness_std = np.std(self.island_best_fitness)
        if fitness_std < self.diversity_threshold:
            return  # Skip migration if islands are too similar.

        # Find the best and worst performing islands.
        best_island_index = np.argmin(self.island_best_fitness)
        worst_island_index = np.argmax(self.island_best_fitness)
        
        # Migrate the best individual from the best island to the worst.
        immigrant = self.island_best_solutions[best_island_index].copy()

        # Replace a random individual in the worst island with the immigrant.
        replace_index = random.randint(0, self.population_size - 1)
        self.islands[worst_island_index][replace_index] = immigrant

        # Immediately adapt the immigrant via a few DE steps within the new island *before* recalculating
        # best fitness metrics for the island, because the immigrant isn't adapted at all.
        for _ in range(3):  # Three DE steps for local adaptation in new environment.
            self.differential_evolution_step(worst_island_index, objective_function)
        
        #Re-evaluate fitness in worst performing island *now*
        population = self.islands[worst_island_index]
        fitness_values = objective_function(population)
        self.eval_count += self.population_size
        best_index = np.argmin(fitness_values)

        if fitness_values[best_index] < self.island_best_fitness[worst_island_index]:
            self.island_best_fitness[worst_island_index] = fitness_values[best_index]
            self.island_best_solutions[worst_island_index] = population[best_index].copy()

            if self.island_best_fitness[worst_island_index] < self.best_fitness_overall:
                self.best_fitness_overall = self.island_best_fitness[worst_island_index]
                self.best_solution_overall = self.island_best_solutions[worst_island_index].copy()


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the objective function using Adaptive Island-based Differential Evolution.

        Args:
            objective_function: The objective function to be minimized.
            acceptance_threshold: Threshold for early stopping (not used in this implementation).

        Returns:
            A tuple containing the best solution, best fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run

        # Initialize islands and find initial best solutions
        for i in range(self.num_islands):
            fitness_values = objective_function(self.islands[i])
            self.eval_count += self.population_size
            best_index = np.argmin(fitness_values)
            self.island_best_fitness[i] = fitness_values[best_index]
            self.island_best_solutions[i] = self.islands[i][best_index].copy()

            if self.island_best_fitness[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.island_best_fitness[i]
                self.best_solution_overall = self.island_best_solutions[i].copy()

        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            # Migrate individuals between islands periodically and adaptively
            if self.eval_count % self.migration_interval == 0 and self.eval_count > 0:
                self.migrate_individuals(objective_function)

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

### Worse code
AdaptiveIslandDE
import numpy as np
import random

# Name: AdaptiveIslandDE
# Description: An island-based DE with adaptive migration, local search, and restart mechanisms to handle deceptive landscapes.
# Code:
class AdaptiveIslandDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 500, migration_size: int = 2,
                 local_search_iterations: int = 10):
        """
        Initializes the AdaptiveIslandDE optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a simple gradient-based method.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation
            perturbation = np.random.normal(0, 0.1, self.dim) # Scale adjusted from 1 to 0.1
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants
            
            # Re-evaluate the fitness of the new solutions on the destination island (important!) and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                new_fitnesses.append(fitness)
              
            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness
             # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol




    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * 0.95:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

### Analyze & experience
- Comparing (Rank 1) vs (Rank 9), we see the top algorithm `AdaptiveIslandDE` leverages local search with perturbation after migration, along with a restart mechanism based on a threshold, whereas Rank 9, `IslandModelAdaptiveDE`, uses fitness-aware migration and simpler adaptive crossover/differential weight adjustments.

(Rank 2) vs (Rank 8): `AdaptiveIslandDE` uses local search and single migrant replacement while Rank 8 includes population re-evaluation and adaptive mutation rates but without targeted local search.

(Rank 1) vs (Rank 2), we see that Rank 1's aggressive exploration uses specific defined, empirically optimized constants, while (Rank 2) exploration focuses on re-evaluating migrants and probabilistic local searches. Rank 1 also has a clear stagnation restart in its optimize function.

(Rank 3) vs (Rank 4):  Rank 3 incorporates island-specific stagnation counters and fitness-aware migration, whereas Rank 4 employs periodic population rejuvenation. Restart mechanism based on counter gives better performance than population rejuvenation which make slower progress.

(Rank 8) vs (Rank 9), we see `IslandAdaptiveDifferentialEvolution` use more simplistic evaluation and mutation strategies, where all fitness needs update. While `IslandModelAdaptiveDE` implement adaptive crossovers for faster improvement. All fitness has initial evaluation to improve better mutation exploration at the start.

Comparing (second worst) vs (worst), we see both performing nearly as good as each other. One use DE step to adapt migrants while other makes periodic rejuvenation by reinitialize worse individual which contributes near same result. Overall: The most effective strategies blend differential evolution with island models and incorporate some form of local search or fine-tuning after migration. More critically, incorporating restart mechanisms when near stagnation improves the efficacy. Further, the fitness reevaluation is vital. Additionally, adaptation of parameters dynamically helps a ton. Further, more computationally cheap evaluations through vector optimizations improve results.
- Okay, I will refine "Current self-reflection" avoiding common pitfalls to generate heuristics for island-based Differential Evolution (DE).

Here's the revised, targeted self-reflection to design better heuristics:

*   **Keywords:** Adaptation, local search, migration, re-evaluation, modularity, parameter control, bound handling.
*   **Advice:** Design migration strategies that leverage fitness information to seed local search effectively. Prioritize modules for DE operations. Implement fast fitness re-evaluation immediately post-migration.
*   **Avoid:** Neglecting transplanted individual evolution after migration, static parameters, or ineffective bounds handling.
*   **Explanation:** Focus on adaptive local optimization *after* transplant while reusing performance of prior evolution. Avoid stagnancy via parameter adapting.


Your task is to write an improved function by COMBINING elements of two above heuristics base Analyze & experience.
Output the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.

I'm going to tip $999K for a better heuristics! Let's think step by step.
2025-06-25 13:38:34 INFO Mutation prompt: **(CR: Capacity and Role)**
Act as an expert in designing algorithms for deceptive, multi-component landscapes. Your specialty is creating strategies that use multi-population or island models to perform aggressive global exploration.

**(I: Insight)**
Your objective is to design a novel optimization algorithm for the GNBG benchmark. The most difficult functions (f16-f24) have multiple, separate basins of attraction where the global optimum can be hidden. An algorithm must be able to discover and explore these competing regions to succeed.

**(S: Statement & P: Personality)**
Provide a complete, novel Python class that implements a multi-population or island-based search strategy to solve this challenge. The class must have an `__init__(...)` and `optimize(...)` method as specified in the main task description.


Current heuristics:
AdaptiveIslandDE
import numpy as np
import random

# Name: AdaptiveIslandDE
# Description: An island-based DE with adaptive migration, local search, and restart mechanisms to handle deceptive landscapes.
# Code:
class AdaptiveIslandDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 500, migration_size: int = 2,
                 local_search_iterations: int = 10):
        """
        Initializes the AdaptiveIslandDE optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a simple gradient-based method.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation
            perturbation = np.random.normal(0, 0.1, self.dim) # Scale adjusted from 1 to 0.1
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants
            
            # Re-evaluate the fitness of the new solutions on the destination island (important!) and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                new_fitnesses.append(fitness)
              
            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness
             # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol




    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * 0.95:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

Now, think outside the box write a mutated function better than current version.
You can use some hints below:
- Okay, I will refine "Current self-reflection" avoiding common pitfalls to generate heuristics for island-based Differential Evolution (DE).

Here's the revised, targeted self-reflection to design better heuristics:

*   **Keywords:** Adaptation, local search, migration, re-evaluation, modularity, parameter control, bound handling.
*   **Advice:** Design migration strategies that leverage fitness information to seed local search effectively. Prioritize modules for DE operations. Implement fast fitness re-evaluation immediately post-migration.
*   **Avoid:** Neglecting transplanted individual evolution after migration, static parameters, or ineffective bounds handling.
*   **Explanation:** Focus on adaptive local optimization *after* transplant while reusing performance of prior evolution. Avoid stagnancy via parameter adapting.


Output code only and enclose your code with Python code block: ```python ... ```.
I'm going to tip $999K for a better solution!
2025-06-25 13:41:12 INFO Perform Harmony Search...
2025-06-25 13:41:26 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 13:42:11 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:42:11 INFO FeHistory: [130561.66317025 130495.86125447 114020.11214994 ... 101433.90584123
 111763.39085873 138273.68894012]
2025-06-25 13:42:11 INFO Expected Optimum FE: -5000
2025-06-25 13:42:11 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 13:42:51 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:42:51 INFO FeHistory: [137880.85899092 224546.64269613 121443.76789078 ... 136580.19355884
 165370.97600172 167501.32991951]
2025-06-25 13:42:51 INFO Expected Optimum FE: -5000
2025-06-25 13:42:51 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 13:43:31 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:43:31 INFO FeHistory: [142033.29285053 181330.421579   223187.02877598 ... 172172.17964866
 151651.82539595 260428.72572611]
2025-06-25 13:43:31 INFO Expected Optimum FE: -5000
2025-06-25 13:43:31 INFO Unimodal AOCC mean: nan
2025-06-25 13:43:31 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 13:43:31 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 13:43:31 INFO AOCC mean: 0.0000
2025-06-25 13:43:31 INFO Weighed AOCC mean: nan
2025-06-25 13:43:31 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 13:52:26 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0356
2025-06-25 13:52:26 INFO FeHistory: [195569.95669796 127503.81850924 150779.91765663 ... 132033.04312775
 160865.70414381 125491.82979757]
2025-06-25 13:52:26 INFO Expected Optimum FE: -5000
2025-06-25 13:52:26 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 13:53:06 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0063
2025-06-25 13:53:06 INFO FeHistory: [112893.41209483 183005.65246673 176512.95201009 ... 160166.49841218
 189316.07702331 161422.58795902]
2025-06-25 13:53:06 INFO Expected Optimum FE: -5000
2025-06-25 13:53:06 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 13:53:47 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:53:47 INFO FeHistory: [120561.51387454 249867.95004763 166240.45995386 ... 157872.82762029
 215400.18428059 125346.45286232]
2025-06-25 13:53:47 INFO Expected Optimum FE: -5000
2025-06-25 13:53:47 INFO Unimodal AOCC mean: nan
2025-06-25 13:53:47 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 13:53:47 INFO Multimodal (multiple components) AOCC mean: 0.0139
2025-06-25 13:53:47 INFO AOCC mean: 0.0139
2025-06-25 13:53:47 INFO Weighed AOCC mean: nan
2025-06-25 13:53:47 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 13:54:29 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:54:29 INFO FeHistory: [124239.29377231 119543.20479639 103205.88659453 ...  94701.23462485
 164229.71157622 163261.983051  ]
2025-06-25 13:54:29 INFO Expected Optimum FE: -5000
2025-06-25 13:54:29 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 13:55:10 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:55:10 INFO FeHistory: [135657.46011138 131359.72270882 173523.51939795 ... 192233.52470365
 136184.6118778  161441.83909378]
2025-06-25 13:55:10 INFO Expected Optimum FE: -5000
2025-06-25 13:55:10 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 13:55:50 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0075
2025-06-25 13:55:50 INFO FeHistory: [140647.87409186 137582.947116   200170.84227859 ... 197447.20993458
 179070.70990126 155944.24954762]
2025-06-25 13:55:50 INFO Expected Optimum FE: -5000
2025-06-25 13:55:50 INFO Unimodal AOCC mean: nan
2025-06-25 13:55:50 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 13:55:50 INFO Multimodal (multiple components) AOCC mean: 0.0025
2025-06-25 13:55:50 INFO AOCC mean: 0.0025
2025-06-25 13:55:50 INFO Weighed AOCC mean: nan
2025-06-25 13:55:50 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 13:56:32 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:56:32 INFO FeHistory: [175371.62054502 158964.0250731   69720.63739058 ... 140202.98992892
  95124.88026107 122986.34407221]
2025-06-25 13:56:32 INFO Expected Optimum FE: -5000
2025-06-25 13:56:32 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 13:57:11 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:57:11 INFO FeHistory: [172870.07421475 161204.71061348 119398.04189346 ... 127904.98541789
 136893.55714087 100786.25580726]
2025-06-25 13:57:11 INFO Expected Optimum FE: -5000
2025-06-25 13:57:11 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 13:57:53 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:57:53 INFO FeHistory: [292503.17573562  85807.90969928 228475.9860202  ... 194023.65731421
 264361.43480397 182325.84501418]
2025-06-25 13:57:53 INFO Expected Optimum FE: -5000
2025-06-25 13:57:53 INFO Unimodal AOCC mean: nan
2025-06-25 13:57:53 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 13:57:53 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 13:57:53 INFO AOCC mean: 0.0000
2025-06-25 13:57:53 INFO Weighed AOCC mean: nan
2025-06-25 13:57:53 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 13:58:36 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:58:36 INFO FeHistory: [114426.4985659  135155.21715446 161348.0900722  ... 142307.21382219
 173630.99868355 121254.02692024]
2025-06-25 13:58:36 INFO Expected Optimum FE: -5000
2025-06-25 13:58:36 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 13:59:16 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:59:16 INFO FeHistory: [190033.09129452 134331.31296681 136444.84222571 ... 142708.25713506
 137772.77768645 159525.00651273]
2025-06-25 13:59:16 INFO Expected Optimum FE: -5000
2025-06-25 13:59:16 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 13:59:56 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 13:59:56 INFO FeHistory: [296471.63732274 151995.44639431 187043.77012657 ... 221953.64793465
  93094.32275234 250103.30017912]
2025-06-25 13:59:56 INFO Expected Optimum FE: -5000
2025-06-25 13:59:56 INFO Unimodal AOCC mean: nan
2025-06-25 13:59:56 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 13:59:56 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 13:59:56 INFO AOCC mean: 0.0000
2025-06-25 13:59:56 INFO Weighed AOCC mean: nan
2025-06-25 13:59:56 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 14:00:38 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:00:38 INFO FeHistory: [151209.33469835 101586.1081062  118698.05951541 ...  98489.5576745
 146637.98120052 142952.66151404]
2025-06-25 14:00:38 INFO Expected Optimum FE: -5000
2025-06-25 14:00:38 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 14:01:18 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:01:18 INFO FeHistory: [184478.22564924 152675.65165591 109301.53208183 ... 103493.7458089
 119729.90873649 215343.23152588]
2025-06-25 14:01:18 INFO Expected Optimum FE: -5000
2025-06-25 14:01:18 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 14:01:59 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:01:59 INFO FeHistory: [165708.32403253 221540.88361932 151725.18463554 ...  97374.16207309
 191701.98129458 142087.39466837]
2025-06-25 14:01:59 INFO Expected Optimum FE: -5000
2025-06-25 14:01:59 INFO Unimodal AOCC mean: nan
2025-06-25 14:01:59 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 14:01:59 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 14:01:59 INFO AOCC mean: 0.0000
2025-06-25 14:01:59 INFO Weighed AOCC mean: nan
2025-06-25 14:01:59 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 14:02:43 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.5316
2025-06-25 14:02:43 INFO FeHistory: [115878.39394005 146335.36132926 172632.45850293 ... 132593.25899656
 120545.1138711  133188.79774085]
2025-06-25 14:02:43 INFO Expected Optimum FE: -5000
2025-06-25 14:02:43 INFO Good algorithm:
Algorithm Name: AdaptiveIslandDE
import numpy as np
import random

# Name: AdaptiveIslandDE
# Description: An island-based DE with adaptive migration, local search, and restart mechanisms to handle deceptive landscapes.
# Code:
class AdaptiveIslandDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.41320846873371797,
                 mutation_rate: float = 0.6113964692124271, migration_interval: int = 570.9783683811978, migration_size: int = 5.459755599550154,
                 local_search_iterations: int = 5.957280686848644, local_search_perturbation_scale: float = 0.14035863986402833, restart_percentage: float = 0.9880777912037225):
        """
        Initializes the AdaptiveIslandDE optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search
            local_search_perturbation_scale (float): Scale of the random perturbation in local search.
            restart_percentage (float): Percentage of budget used to trigger restart.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.local_search_perturbation_scale = local_search_perturbation_scale
        self.restart_percentage = restart_percentage

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a simple gradient-based method.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation
            perturbation = np.random.normal(0, self.local_search_perturbation_scale, self.dim) # Scale adjusted from 1 to 0.1
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants

            # Re-evaluate the fitness of the new solutions on the destination island (important!) and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness
             # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol




    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * self.restart_percentage:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
2025-06-25 14:02:43 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 14:03:24 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:03:24 INFO FeHistory: [139022.01866007 136444.44587834 113977.43140545 ... 221578.79284482
 159373.80673922 113161.42826207]
2025-06-25 14:03:24 INFO Expected Optimum FE: -5000
2025-06-25 14:03:24 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 14:04:05 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:04:05 INFO FeHistory: [176813.75140229 202213.66417392 134858.44803292 ...  98128.17045432
 180623.74201142 146749.1096499 ]
2025-06-25 14:04:05 INFO Expected Optimum FE: -5000
2025-06-25 14:04:05 INFO Unimodal AOCC mean: nan
2025-06-25 14:04:05 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 14:04:05 INFO Multimodal (multiple components) AOCC mean: 0.1772
2025-06-25 14:04:05 INFO AOCC mean: 0.1772
2025-06-25 14:04:05 INFO Weighed AOCC mean: nan
2025-06-25 14:04:05 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 14:04:48 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:04:48 INFO FeHistory: [147162.48001428 124509.0702432  134926.93813748 ... 109966.9788845
 109837.48556292 108845.75495584]
2025-06-25 14:04:48 INFO Expected Optimum FE: -5000
2025-06-25 14:04:48 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 14:05:27 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:05:27 INFO FeHistory: [135602.7859997  193694.66112547 180149.35758526 ... 151534.55044733
 160071.39850637 230898.55214374]
2025-06-25 14:05:27 INFO Expected Optimum FE: -5000
2025-06-25 14:05:27 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 14:06:07 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:06:07 INFO FeHistory: [146067.05438351 135778.82021281 126742.45666406 ... 174620.26208727
 276254.99520684 158228.86349213]
2025-06-25 14:06:07 INFO Expected Optimum FE: -5000
2025-06-25 14:06:07 INFO Unimodal AOCC mean: nan
2025-06-25 14:06:07 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 14:06:07 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 14:06:07 INFO AOCC mean: 0.0000
2025-06-25 14:06:07 INFO Weighed AOCC mean: nan
2025-06-25 14:06:07 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 14:06:49 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:06:49 INFO FeHistory: [113917.7518257  202966.65838385  95112.24918941 ... 131733.00209008
 131414.88685446 130095.61406525]
2025-06-25 14:06:49 INFO Expected Optimum FE: -5000
2025-06-25 14:06:49 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 14:07:29 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:07:29 INFO FeHistory: [120649.30197835 203547.81457855 129520.09168849 ... 170210.48332887
 201277.78501544 106802.72605857]
2025-06-25 14:07:29 INFO Expected Optimum FE: -5000
2025-06-25 14:07:29 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 14:08:09 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:08:09 INFO FeHistory: [137676.47510437 236219.19347028  84667.00123992 ... 160578.97969715
 141069.58239698 232371.90317199]
2025-06-25 14:08:09 INFO Expected Optimum FE: -5000
2025-06-25 14:08:09 INFO Unimodal AOCC mean: nan
2025-06-25 14:08:09 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 14:08:09 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 14:08:09 INFO AOCC mean: 0.0000
2025-06-25 14:08:09 INFO Weighed AOCC mean: nan
2025-06-25 14:08:09 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 14:08:51 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.6185
2025-06-25 14:08:51 INFO FeHistory: [140858.87567213 161486.14273318 171764.89091325 ... 158889.05676486
 176448.87644874 126461.01746428]
2025-06-25 14:08:51 INFO Expected Optimum FE: -5000
2025-06-25 14:08:51 INFO Good algorithm:
Algorithm Name: AdaptiveIslandDE
import numpy as np
import random

# Name: AdaptiveIslandDE
# Description: An island-based DE with adaptive migration, local search, and restart mechanisms to handle deceptive landscapes.
# Code:
class AdaptiveIslandDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.8719572569354708,
                 mutation_rate: float = 0.6113964692124271, migration_interval: int = 896.9508697672186, migration_size: int = 2.414743986796276,
                 local_search_iterations: int = 5.957280686848644, local_search_perturbation_scale: float = 0.1446330223199665, restart_percentage: float = 0.8606737890095179):
        """
        Initializes the AdaptiveIslandDE optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search
            local_search_perturbation_scale (float): Scale of the random perturbation in local search.
            restart_percentage (float): Percentage of budget used to trigger restart.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.local_search_perturbation_scale = local_search_perturbation_scale
        self.restart_percentage = restart_percentage

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a simple gradient-based method.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation
            perturbation = np.random.normal(0, self.local_search_perturbation_scale, self.dim) # Scale adjusted from 1 to 0.1
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants

            # Re-evaluate the fitness of the new solutions on the destination island (important!) and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness
             # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol




    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * self.restart_percentage:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
2025-06-25 14:08:51 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 14:09:31 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.1351
2025-06-25 14:09:31 INFO FeHistory: [199973.58494209  94670.18610691 109157.1428431  ... 216427.29590368
 195178.84938877 136700.33606437]
2025-06-25 14:09:31 INFO Expected Optimum FE: -5000
2025-06-25 14:09:31 INFO Good algorithm:
Algorithm Name: AdaptiveIslandDE
import numpy as np
import random

# Name: AdaptiveIslandDE
# Description: An island-based DE with adaptive migration, local search, and restart mechanisms to handle deceptive landscapes.
# Code:
class AdaptiveIslandDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.8719572569354708,
                 mutation_rate: float = 0.6113964692124271, migration_interval: int = 896.9508697672186, migration_size: int = 2.414743986796276,
                 local_search_iterations: int = 5.957280686848644, local_search_perturbation_scale: float = 0.1446330223199665, restart_percentage: float = 0.8606737890095179):
        """
        Initializes the AdaptiveIslandDE optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search
            local_search_perturbation_scale (float): Scale of the random perturbation in local search.
            restart_percentage (float): Percentage of budget used to trigger restart.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.local_search_perturbation_scale = local_search_perturbation_scale
        self.restart_percentage = restart_percentage

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a simple gradient-based method.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation
            perturbation = np.random.normal(0, self.local_search_perturbation_scale, self.dim) # Scale adjusted from 1 to 0.1
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants

            # Re-evaluate the fitness of the new solutions on the destination island (important!) and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness
             # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol




    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * self.restart_percentage:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
2025-06-25 14:09:31 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 14:10:11 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:10:11 INFO FeHistory: [177144.88016863 203957.98133478 107931.94285996 ... 159983.51371025
 248836.41773806 192939.45621104]
2025-06-25 14:10:11 INFO Expected Optimum FE: -5000
2025-06-25 14:10:11 INFO Unimodal AOCC mean: nan
2025-06-25 14:10:11 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 14:10:11 INFO Multimodal (multiple components) AOCC mean: 0.2512
2025-06-25 14:10:11 INFO AOCC mean: 0.2512
2025-06-25 14:10:11 INFO Weighed AOCC mean: nan
2025-06-25 14:10:11 INFO Generation 2, best so far: 0.2952351239662642
2025-06-25 14:10:11 INFO Population length is: 10
2025-06-25 14:10:11 INFO --- Performing Long-Term Reflection at Generation 3 ---
2025-06-25 14:10:11 INFO Reflection Prompt: ### Problem Description
**(CR: Capacity and Role)**
Act as an expert in designing algorithms for deceptive, multi-component landscapes. Your specialty is creating strategies that use multi-population or island models to perform aggressive global exploration.

**(I: Insight)**
Your objective is to design a novel optimization algorithm for the GNBG benchmark. The most difficult functions (f16-f24) have multiple, separate basins of attraction where the global optimum can be hidden. An algorithm must be able to discover and explore these competing regions to succeed.

**(S: Statement & P: Personality)**
Provide a complete, novel Python class that implements a multi-population or island-based search strategy to solve this challenge. The class must have an `__init__(...)` and `optimize(...)` method as specified in the main task description.

### List heuristics
Below is a list of design heuristics ranked from best to worst based on their AOCC score on group function 3 of GNBG benchmark, where higher is better. To enable a detailed analysis of their specializations, the performance breakdown on each of the three GNBG function groups is also provided.
### Rank 1 (Overall AOCC Score on Multimodal instances with multiple components: 2.5120e-01# Name: AdaptiveIslandDE
# Description: 
# Code:
```python
import numpy as np
import random

# Name: AdaptiveIslandDE
# Description: An island-based DE with adaptive migration, local search, and restart mechanisms to handle deceptive landscapes.
# Code:
class AdaptiveIslandDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.8719572569354708,
                 mutation_rate: float = 0.6113964692124271, migration_interval: int = 896.9508697672186, migration_size: int = 2.414743986796276,
                 local_search_iterations: int = 5.957280686848644, local_search_perturbation_scale: float = 0.1446330223199665, restart_percentage: float = 0.8606737890095179):
        """
        Initializes the AdaptiveIslandDE optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search
            local_search_perturbation_scale (float): Scale of the random perturbation in local search.
            restart_percentage (float): Percentage of budget used to trigger restart.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.local_search_perturbation_scale = local_search_perturbation_scale
        self.restart_percentage = restart_percentage

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a simple gradient-based method.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation
            perturbation = np.random.normal(0, self.local_search_perturbation_scale, self.dim) # Scale adjusted from 1 to 0.1
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants

            # Re-evaluate the fitness of the new solutions on the destination island (important!) and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness
             # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol




    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * self.restart_percentage:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 2 (Overall AOCC Score on Multimodal instances with multiple components: 4.0033e-02# Name: AdaptiveIslandDEv2
# Description: Island-based DE with adaptive parameters, fitness-based migration, and local search enhancements to handle deceptive landscapes effectively.
# Code:
```python
import numpy as np
import random

# Name: AdaptiveIslandDEv2
# Description: Island-based DE with adaptive parameters, fitness-based migration, and local search enhancements to handle deceptive landscapes effectively.
# Code:
class AdaptiveIslandDEv2:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20,
                 migration_interval: int = 500, migration_size: int = 2, local_search_iterations: int = 10):
        """
        Initializes the AdaptiveIslandDEv2 optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands

        # Adaptive DE parameters
        self.crossover_rates = np.full(self.num_islands, 0.7)
        self.mutation_rates = np.full(self.num_islands, 0.5)
        self.crossover_rate_adaptation_rate = 0.1
        self.mutation_rate_adaptation_rate = 0.1


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island, with adaptive parameters.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]
        crossover_rate = self.crossover_rates[island_index]
        mutation_rate = self.mutation_rates[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector

                # Adapt DE parameters if improvement found
                self.crossover_rates[island_index] = min(1.0, crossover_rate + self.crossover_rate_adaptation_rate)
                self.mutation_rates[island_index] = min(1.0, mutation_rate + self.mutation_rate_adaptation_rate)

            else:
                # Reduce parameters if no improvement
                self.crossover_rates[island_index] = max(0.1, crossover_rate - self.crossover_rate_adaptation_rate)
                self.mutation_rates[island_index] = max(0.1, mutation_rate - self.mutation_rate_adaptation_rate)



        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable, scale=0.1) -> tuple:
        """
        Performs enhanced local search around a solution.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.
            scale: Adjust magnitude of perturbation

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation, scaling with dimension
            perturbation = np.random.normal(0, scale, self.dim)
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands based on fitness. Elites migrate and are adapted using local search.
        """

        # Sort islands by best fitness to facilitate migration towards better-performing islands
        island_order = np.argsort([self.best_fitnesses[i] for i in range(self.num_islands)])

        for i in range(self.num_islands):
            source_island_index = island_order[i]

            # Select a random destination island *better* than the current one (guided migration)
            possible_destinations = island_order[:i]  # Islands with better fitness
            if not possible_destinations.size > 0:
               dest_island_index = random.choice([j for j in range(self.num_islands) if j != source_island_index]) #Random if no better destination
            else:
                dest_island_index = random.choice(possible_destinations)  #Prioritize better islands


            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[source_island_index]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[source_island_index][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island_index]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island_index][worst_indices] = migrants

            # Re-evaluate the fitness of the new solutions on the destination island and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function, scale=0.05)  # Adapted scale.
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island_index] = dest_island_fitness


            # Update best fitness values, if needed, *after* re-evaluation
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island_index]:
                    self.best_fitnesses[dest_island_index] = fit
                    self.best_solutions[dest_island_index] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the enhanced island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None  # Reset for this run
        self.best_fitness_overall = float('inf')  # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]

        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            # Restart Mechanism if stagnating and budget permits
            if self.eval_count > self.budget * 0.90:  # Restarting later to ensure more explorations
                for i in range(self.num_islands):
                   if self.eval_count + self.population_size < self.budget:
                       new_population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                       new_fitnesses = objective_function(new_population)
                       self.eval_count += self.population_size # Update Evaluation Count immediatly.

                       best_index = np.argmin(new_fitnesses)
                       best_fitness = new_fitnesses[best_index]
                       best_solution = new_population[best_index]
                       self.populations[i] = new_population
                       self.fitness_values[i] = new_fitnesses



                       if best_fitness < self.best_fitnesses[i]:
                           self.best_fitnesses[i] = best_fitness
                           self.best_solutions[i] = best_solution
                           if best_fitness < self.best_fitness_overall:
                               self.best_fitness_overall = best_fitness
                               self.best_solution_overall = best_solution




        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 3 (Overall AOCC Score on Multimodal instances with multiple components: 3.8791e-02# Name: AdaptiveIslandDE2
# Description: Island DE with adaptive migration and restart with re-evaluated fitness and DE local tuning
# Code:
```python
import numpy as np
import random

# Name: AdaptiveIslandDE2
# Description: Island DE with adaptive migration and restart with re-evaluated fitness and DE local tuning
# Code:
class AdaptiveIslandDE2:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 500, migration_size: int = 2,
                 local_search_iterations: int = 10, restart_trigger: float = 0.95):
        """
        Initializes the AdaptiveIslandDE2 optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search with DE operator
            restart_trigger (float) Percentage of budget at which the algorithm restarts near end to reduce stagnation
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.restart_trigger = restart_trigger

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search using DE around a solution.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
             # Mutation - Like DE
            indices = list(range(self.dim))
            a, b, c = random.sample(indices, 3)
            mutant_vector = best_solution + self.mutation_rate * (best_solution - best_solution)  #best_solution vector cause focus to itself
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds) # Clip to bounds
            
            #Evaluation
            new_fitness = objective_function(mutant_vector.reshape(1, -1))[0]
            self.eval_count += 1
        
            #Selection for next iteration
            if new_fitness < best_fitness:
                 best_fitness = new_fitness
                 best_solution = mutant_vector
        return best_solution, best_fitness



    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals. Local search after migration
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants

            # Re-evaluate the fitness of the new solutions on the destination island and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness
             # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol




    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * self.restart_trigger:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 4 (Overall AOCC Score on Multimodal instances with multiple components: 2.5159e-02# Name: AdaptiveIslandDE_v2
# Description: Island DE with local search, adaptive migration, and late-stage restarts for escaping local optima.
# Code:
```python
import numpy as np
import random

# Name: AdaptiveIslandDE_v2
# Description: Island DE with local search, adaptive migration, and late-stage restarts for escaping local optima.
# Code:
class AdaptiveIslandDE_v2:
    """
    Implements an island model DE with adaptive migration, local search and
    late stage restarts to aggressively explore multi-component landscapes.
    """

    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 500, migration_size: int = 2,
                 local_search_probability: float = 0.1, local_search_iterations = 10):
        """
        Initializes the AdaptiveIslandDE_v2 optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_probability (float): Probability of performing local search after migration.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_probability = local_search_probability
        self.local_search_iterations = local_search_iterations


        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands
        self.island_stagnation_counters = [0] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        best_fitness_before = self.best_fitnesses[island_index]
        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                    # Update overall best
                    if trial_fitness < self.best_fitness_overall:
                        self.best_fitness_overall = trial_fitness
                        self.best_solution_overall = trial_vector

        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

        if self.best_fitnesses[island_index] == best_fitness_before:
           self.island_stagnation_counters[island_index] +=1
        else:
           self.island_stagnation_counters[island_index] = 0 #reset counter


    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a simple gradient-based method.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation
            perturbation = np.random.normal(0, 0.1, self.dim) # Scale adjusted from 1 to 0.1
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants
            
            # Re-evaluate the fitness of the new solutions on the destination island (important!) and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                new_fitnesses.append(fitness)
              
            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness
             # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol


    def restart_island(self, island_index: int, objective_function: callable):
        """Restarts a single island by re-initializing its population."""

        self.populations[island_index] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
        self.fitness_values[island_index] = objective_function(self.populations[island_index]).flatten()
        self.eval_count += self.population_size
        best_index = np.argmin(self.fitness_values[island_index])
        self.best_fitnesses[island_index] = self.fitness_values[island_index][best_index]
        self.best_solutions[island_index] = self.populations[island_index][best_index]
        if self.best_fitnesses[island_index] < self.best_fitness_overall:
            self.best_fitness_overall = self.best_fitnesses[island_index]
            self.best_solution_overall = self.best_solutions[island_index]
        self.island_stagnation_counters[island_index] = 0  # Reset stagnation counter


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i]).flatten()
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)
                # Check stagnation and restart island if necessary
                if self.island_stagnation_counters[i] > 5: # Restart threshold
                    self.restart_island(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating overall towards the end, reset to a bigger distribution.
            if self.eval_count > self.budget * 0.95:  # Restart towards the end
                for i in range(self.num_islands):
                    self.restart_island(i, objective_function)


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 5 (Overall AOCC Score on Multimodal instances with multiple components: 8.2371e-03# Name: FitnessAdaptiveIslandDEPlus
# Description: Combines fitness-aware migration with adaptive restarts and local search for deceptive landscape exploration.
# Code:
```python
import numpy as np
import random

# Name: FitnessAdaptiveIslandDEPlus
# Description: Combines fitness-aware migration with adaptive restarts and local search for deceptive landscape exploration.
# Code:
class FitnessAdaptiveIslandDEPlus:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 500, migration_size: int = 2,
                 local_search_iterations: int = 10, local_search_probability: float = 0.1,
                 local_search_step_size_ratio: float = 0.1):
        """
        Initializes the FitnessAdaptiveIslandDEPlus optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search.
            local_search_probability (float): Probability of performing local search.
            local_search_step_size_ratio (float): Ratio of bounds to determine step size in local search.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.local_search_probability = local_search_probability
        self.local_search_step_size_ratio = local_search_step_size_ratio

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands
        self.stagnation_counters = [0] * self.num_islands  # stagnation detection

    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]
        island_stagnation_threshold = self.budget // (5 * self.num_islands)  # Adaptive threshold

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Local Search with Probability
            if random.random() < self.local_search_probability:
                trial_vector, trial_fitness = self.local_search(trial_vector, objective_function)

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness
                self.stagnation_counters[island_index] = 0  # Reset stagnation counter

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector
            else:
                self.stagnation_counters[island_index] += 1  # Increment stagnation counter

            # Restart mechanism when stagnating, adaptive restarts instead of fixed interval
            if self.stagnation_counters[island_index] > island_stagnation_threshold:
                self.populations[island_index] = np.random.uniform(self.lower_bounds, self.upper_bounds,
                                                                   (self.population_size, self.dim))
                self.fitness_values[island_index] = objective_function(self.populations[island_index])
                self.eval_count += self.population_size
                best_index = np.argmin(self.fitness_values[island_index])
                self.best_fitnesses[island_index] = self.fitness_values[island_index][best_index]
                self.best_solutions[island_index] = self.populations[island_index][best_index]
                self.stagnation_counters[island_index] = 0  # reset counter
                if self.best_fitnesses[island_index] < self.best_fitness_overall:
                    self.best_fitness_overall = self.best_fitnesses[island_index]
                    self.best_solution_overall = self.best_solutions[island_index]

        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a gradient-based method with adaptive step size.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        # Adaptive step size
        step_size = self.local_search_step_size_ratio * (self.upper_bounds[0] - self.lower_bounds[0])

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation
            perturbation = np.random.normal(0, step_size, self.dim)
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness

    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands based on fitness, exchanging migrants between best and worst islands.
        """

        # Sort islands based on their best fitness
        island_indices = list(range(self.num_islands))
        island_indices.sort(key=lambda i: self.best_fitnesses[i])

        # Migrate from better islands to worse islands.
        num_migrate_pairs = self.num_islands // 2  # Half sends to the other Half for balance.

        for i in range(num_migrate_pairs):
            source_island = island_indices[i]  # Best Half
            dest_island = island_indices[self.num_islands - 1 - i]  # Worst Half.

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[source_island]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[source_island][best_indices].copy()  # Important to copy
            migrant_fitnesses = source_island_fitness[best_indices].copy()

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants

            # Re-evaluate the fitness of the new solutions on the destination island (important!) and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function)  # Local Adaptation here.
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness

            # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                    self.best_fitnesses[dest_island] = fit
                    self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using island model DE with migrations, local search, and adaptive restarts.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: Best solution, its fitness, and optimization info.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None  # Reset for this run
        self.best_fitness_overall = float('inf')  # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]

        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 6 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptiveIslandDE2
# Description: Combines adaptive populations, local search post-migration, and late-stage restarts for complex multimodal optimization.
# Code:
```python
import numpy as np
import random

# Name: AdaptiveIslandDE2
# Description: Combines adaptive populations, local search post-migration, and late-stage restarts for complex multimodal optimization.
# Code:
class AdaptiveIslandDE2:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.5,
                 mutation_rate: float = 0.5, migration_interval: int = 500, migration_size: int = 2,
                 local_search_iterations: int = 5, perturbation_scale: float = 0.1, restart_threshold: float = 0.9):
        """
        Initializes the AdaptiveIslandDE2 optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Initial number of individuals in each island. Adaptively adjusted.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search.
            perturbation_scale (float): Scale of the random perturbation in local search.
            restart_threshold (float): Fraction of budget after which restart is triggered.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.perturbation_scale = perturbation_scale
        self.restart_threshold = restart_threshold

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        self.stagnation_counter = 0
        self.stagnation_threshold = budget * 0.05  # Restart if stagnation persists for 5% of the budget

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands
        self.island_pop_sizes = [population_size] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.island_pop_sizes[island_index]): # Iterate island population size.
            # Mutation
            indices = list(range(self.island_pop_sizes[island_index]))
            indices.remove(i)
            if len(indices) < 3: #Need at least 3
                continue
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a simple gradient-based method.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation
            perturbation = np.random.normal(0, self.perturbation_scale, self.dim) # Scale adjusted from 1 to 0.1
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants

            # Re-evaluate the fitness of the new solutions on the destination island (important!) and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness

            # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol


    def adjust_population_size(self, island_index: int, objective_function: callable, min_pop_size: int, max_pop_size: int):
        """Adjusts population size of an island based on stagnation."""
        current_pop_size = self.island_pop_sizes[island_index]
        if self.best_fitness_overall == self.best_fitnesses[island_index]: # Island best is global best -> potential stagnancy
            new_size = min(int(current_pop_size * 1.1), max_pop_size) #Exploitation- increase population
        else:
            new_size = max(int(current_pop_size * 0.9), min_pop_size)

        new_size = int(new_size)
        self.island_pop_sizes[island_index] = new_size

        #Resize popualtion
        if new_size > current_pop_size: #Increase to utilize space, may be exploited.
            additional_individuals = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(new_size-current_pop_size, self.dim))
            additional_fitness = objective_function(additional_individuals)
            self.eval_count += len(additional_individuals)

            self.populations[island_index] = np.vstack((self.populations[island_index], additional_individuals))
            self.fitness_values[island_index] = np.concatenate((self.fitness_values[island_index], additional_fitness))
        elif new_size < current_pop_size: #Decrease to explore.
            best_indices = np.argsort(self.fitness_values[island_index])[:new_size]
            self.populations[island_index] = self.populations[island_index][best_indices]
            self.fitness_values[island_index] = self.fitness_values[island_index][best_indices] #shrink to given
        else:
            return #Same population, nothing to do.

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None  # Reset for this run
        self.best_fitness_overall = float('inf')  # Reset for this run
        self.stagnation_counter = 0

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        min_pop_size = self.population_size // 2 if self.population_size // 2 > 2 else 3  #Ensure sample size
        max_pop_size = self.population_size * 2 #Adaptive population is increased by factor.


        # Main optimization loop
        while self.eval_count < self.budget:
            prev_best_fitness = self.best_fitness_overall

            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)
                self.adjust_population_size(i, objective_function, min_pop_size, max_pop_size)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            if self.best_fitness_overall == prev_best_fitness: #Stagnation is reached
                self.stagnation_counter += self.migration_interval #Count stagnation cycle.
            else:
                self.stagnation_counter = 0   #Reset stagnation

            # Restart Mechanism if stagnating
            if self.eval_count > self.budget * self.restart_threshold or self.stagnation_counter > self.stagnation_threshold:  # Restart towards the end
                self.stagnation_counter = 0 #Remove stagnation state to prevent immediate restart.
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.island_pop_sizes[i], self.dim)) # Use adaptive population
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.island_pop_sizes[i]
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]



        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 7 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptiveIslandDEMigLocalRestart
# Description: Combines island-based DE with migration-triggered local search and a restart mechanism for global exploration.
# Code:
```python
import numpy as np
import random

# Name: AdaptiveIslandDEMigLocalRestart
# Description: Combines island-based DE with migration-triggered local search and a restart mechanism for global exploration.
# Code:
class AdaptiveIslandDEMigLocalRestart:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.57,
                 mutation_rate: float = 0.48, migration_interval: int = 700, migration_size: int = 5,
                 local_search_iterations: int = 14, perturbation_scale: float = 0.1, restart_threshold: float = 0.92):
        """
        Initializes the AdaptiveIslandDEMigLocalRestart optimizer.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.perturbation_scale = perturbation_scale
        self.restart_threshold = restart_threshold

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)

            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a gradient-based method.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(int(self.local_search_iterations)): #Explicit cast to int
            perturbation = np.random.normal(0, self.perturbation_scale, self.dim)
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands with local search applied to migrants.
        """

        for i in range(self.num_islands):
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:int(self.migration_size)] # Explicit cast to int

            migrants = self.populations[i][best_indices].copy()

            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-int(self.migration_size):]  # Explicit cast to int

            self.populations[dest_island][worst_indices] = migrants

            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function)
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness

            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol




    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model DE algorithm with local search and restart.
        """
        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % int(self.migration_interval) == 0:  #Explicit cast to int
                self.migrate(objective_function)

            if self.eval_count > self.budget * self.restart_threshold:
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 8 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: IslandModelAdaptiveRestartDE
# Description: Integrates island model DE with adaptive restarts and fitness-re-evaluation for deceptive landscapes.
# Code:
```python
import numpy as np
import random

# Name: IslandModelAdaptiveRestartDE
# Description: Integrates island model DE with adaptive restarts and fitness-re-evaluation for deceptive landscapes.
# Code:
class IslandModelAdaptiveRestartDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float], num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7, mutation_factor: float = 0.5, migration_interval: int = 500, migration_size: int = 2, restart_trigger: float = 0.95):
        """
        Initializes the IslandModelAdaptiveRestartDE algorithm.

        Args:
            budget: Maximum number of function evaluations.
            dim: Problem dimensionality.
            lower_bounds: List of lower bounds for each dimension.
            upper_bounds: List of upper bounds for each dimension.
            num_islands: Number of islands in the archipelago.
            population_size: Number of individuals in each island's population.
            crossover_rate: Crossover rate for Differential Evolution.
            mutation_factor: Mutation factor for Differential Evolution.
            migration_interval: Number of evaluations between migrations.
            migration_size: Number of individuals to migrate between islands.
            restart_trigger: Percentage of budget to trigger a restart.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_factor = mutation_factor
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.restart_trigger = restart_trigger

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize islands and their populations
        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            self.islands.append(population)

        # Island specific best solutions and their fitnesses
        self.island_best_solutions = [None] * self.num_islands
        self.island_best_fitness = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable) -> None:
        """
        Performs one step of Differential Evolution on a given island.

        Args:
            island_index: Index of the island to perform DE on.
            objective_function: The objective function to be minimized.
        """
        population = self.islands[island_index]
        fitness_values = objective_function(population)
        self.eval_count += self.population_size

        # Update island best
        best_index = np.argmin(fitness_values)
        if fitness_values[best_index] < self.island_best_fitness[island_index]:
            self.island_best_fitness[island_index] = fitness_values[best_index]
            self.island_best_solutions[island_index] = population[best_index].copy()

            if self.island_best_fitness[island_index] < self.best_fitness_overall:
                self.best_fitness_overall = self.island_best_fitness[island_index]
                self.best_solution_overall = self.island_best_solutions[island_index].copy()

        for i in range(self.population_size):
            # Choose three random individuals, distinct from each other and the current individual
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)

            # Mutation
            mutant = population[a] + self.mutation_factor * (population[b] - population[c])

            # Ensure the mutant stays within bounds
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

            # Crossover
            crossover_mask = np.random.rand(self.dim) < self.crossover_rate
            trial_vector = np.where(crossover_mask, mutant, population[i])

            # Evaluate the trial vector
            trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]
            self.eval_count += 1  # Increment eval_count for the single evaluation

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                if trial_fitness < self.island_best_fitness[island_index]:
                    self.island_best_fitness[island_index] = trial_fitness
                    self.island_best_solutions[island_index] = trial_vector.copy()

                    if trial_fitness < self.best_fitness_overall:
                        self.best_fitness_overall = trial_fitness
                        self.best_solution_overall = trial_vector.copy()

        self.islands[island_index] = population  # Update population


    def migrate_individuals(self, objective_function: callable) -> None:
        """
        Migrates the best individuals between islands, implementing fitness-based replacement and fitness reevaluation.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best individual on the source island
            migrant = self.island_best_solutions[i].copy()

            # Identify the worst individual on the destination island
            population = self.islands[dest_island]
            fitness_values = objective_function(population)
            worst_index = np.argmax(fitness_values)

            # Replace the worst individual on the destination island with the migrant
            self.islands[dest_island][worst_index] = migrant

            # Re-evaluate fitness in the destination island with the new migrant
            trial_fitness = objective_function(migrant.reshape(1, -1))[0]
            self.eval_count += 1

            # Update the fitness array to incorporate the new value
            fitness_values[worst_index] = trial_fitness

            # Update best fitness, if needed
            if trial_fitness < self.island_best_fitness[dest_island]:
                self.island_best_fitness[dest_island] = trial_fitness
                self.island_best_solutions[dest_island] = migrant

                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = migrant


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the objective function using Island-based Differential Evolution with adaptive restarts.

        Args:
            objective_function: The objective function to be minimized.
            acceptance_threshold: Threshold for early stopping (not used in this implementation).

        Returns:
            A tuple containing the best solution, best fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run

        # Initialize islands and find initial best solutions
        for i in range(self.num_islands):
            fitness_values = objective_function(self.islands[i])
            self.eval_count += self.population_size
            best_index = np.argmin(fitness_values)
            self.island_best_fitness[i] = fitness_values[best_index]
            self.island_best_solutions[i] = self.islands[i][best_index].copy()

            if self.island_best_fitness[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.island_best_fitness[i]
                self.best_solution_overall = self.island_best_solutions[i].copy()

        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            # Migrate individuals between islands periodically
            if self.eval_count % self.migration_interval == 0 and self.eval_count > 0:
                self.migrate_individuals(objective_function)

            # Restart Mechanism if stagnating near budget limit
            if self.eval_count > self.budget * self.restart_trigger:
                for i in range(self.num_islands):
                    self.islands[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
                    fitness_values = objective_function(self.islands[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(fitness_values)
                    self.island_best_fitness[i] = fitness_values[best_index]
                    self.island_best_solutions[i] = self.islands[i][best_index].copy()

                    if self.island_best_fitness[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.island_best_fitness[i]
                        self.best_solution_overall = self.island_best_solutions[i].copy()

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 9 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptiveIslandDifferentialEvolutionPlus
# Description: An enhanced island-based DE with adaptive parameters, fitness-based migration, and a local search operator aimed at effectively exploring deceptive multimodal landscapes.
# Code:
```python
import numpy as np
import random

# Name: AdaptiveIslandDifferentialEvolutionPlus
# Description: An enhanced island-based DE with adaptive parameters, fitness-based migration, and a local search operator aimed at effectively exploring deceptive multimodal landscapes.
# Code:
class AdaptiveIslandDifferentialEvolutionPlus:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20,
                 migration_interval: int = 500, migration_size: int = 2,
                 local_search_iterations: int = 5,  # Reduced iterations for efficiency
                 initial_crossover_rate: float = 0.7, initial_mutation_rate: float = 0.5,
                 crossover_rate_decay: float = 0.995, mutation_rate_decay: float = 0.995): #Adaptive parameters
        """
        Initializes the AdaptiveIslandDifferentialEvolutionPlus optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search.
            initial_crossover_rate (float): Initial DE crossover probability.
            initial_mutation_rate (float): Initial DE mutation scaling factor.
            crossover_rate_decay (float): Decay rate for crossover rate (adaptive parameter).
            mutation_rate_decay (float): Decay rate for mutation rate (adaptive parameter).
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        #Adaptive Parameters
        self.crossover_rate = initial_crossover_rate
        self.mutation_rate = initial_mutation_rate
        self.crossover_rate_decay = crossover_rate_decay
        self.mutation_rate_decay = mutation_rate_decay

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island with adaptive parameters.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector

        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values


    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a simple gradient-based method.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation.  Dynamically Adjust step size
            perturbation = np.random.normal(0, 0.1 * (1 - self.eval_count/self.budget), self.dim)
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands based on fitness. Each island sends its best individuals
        to another island, and those migrants are then improved with local search.
        """
        island_indices = list(range(self.num_islands))
        random.shuffle(island_indices)

        for i in island_indices:
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()

            # Replace *random* solutions on the destination island with the migrants
            replace_indices = random.sample(range(self.population_size), self.migration_size)
            self.populations[dest_island][replace_indices] = migrants

            # Re-evaluate the fitness of the new solutions on the destination island AND apply local search
            new_fitnesses = []
            for j in range(self.migration_size): # or len(replace_indices)
                migrant = migrants[j] #or self.populations[dest_island][replace_indices[j]]
                migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                new_fitnesses.append(fitness)
                
                #Immediately update best fitness overall and in the island
                if fitness < self.best_fitness_overall:
                    self.best_fitness_overall = fitness
                    self.best_solution_overall = migrant
                if fitness < self.best_fitnesses[dest_island]:
                    self.best_fitnesses[dest_island] = fitness
                    self.best_solutions[dest_island] = migrant # Ensure best solution is stored post local search
                    
            self.fitness_values[dest_island][replace_indices] = new_fitnesses #Correct Indices update


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            # Adapt parameters - reduce exploration as time goes on
            self.crossover_rate *= self.crossover_rate_decay
            self.mutation_rate *= self.mutation_rate_decay

            #Restart Mechanism
            if self.eval_count > self.budget * 0.95:  # Restart towards the end if stagnating
               for i in range(self.num_islands):
                   self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                   self.fitness_values[i] = objective_function(self.populations[i])
                   self.eval_count += self.population_size
                   best_index = np.argmin(self.fitness_values[i])
                   self.best_fitnesses[i] = self.fitness_values[i][best_index]
                   self.best_solutions[i] = self.populations[i][best_index]
                   if self.best_fitnesses[i] < self.best_fitness_overall:
                       self.best_fitness_overall = self.best_fitnesses[i]
                       self.best_solution_overall = self.best_solutions[i]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```



### Guide
Keep in mind, this is a list of design heuristics ranked from best to worst. The first algorithm in the list is the best performing on average, and the last is the worst.
Your response must be in Markdown format and contain nothing else. It must have the following structure:

"**Analysis:**
**Experience:**"

In there:
+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.
Example: "Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:"

+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).

I'm going to tip $999K for a better heuristics! Let's think step by step.
2025-06-25 14:10:19 INFO Full response text: ```markdown
**Analysis:**
Comparing (Rank 1) vs (Rank 9), we see Rank 1 `AdaptiveIslandDE` uses fixed `local_search_perturbation_scale`, `migration_size` while Rank 9 `AdaptiveIslandDifferentialEvolutionPlus` uses dynamic value. Also the parameters on Rank 1 are fine tuned to make it better on deceived landscape; (Rank 2) vs (Rank 8): Rank 2 AdaptiveIslandDEv2 includes fitness aware migration and an enhanced local search which helps adaptation while Rank 8 IslandModelAdaptiveRestartDE features with simplified local search; Comparing (1st) vs (2nd), we see Rank 1 does not have Adaptive DE parameter adaptation while Rank 2 AdaptiveIslandDEv2 does. `AdaptiveIslandDE` also incorporates restart percentage mechanism which can enable faster exploration while `AdaptiveIslandDEv2` lacks it. Comparing (3rd) vs (4th), we see `AdaptiveIslandDE2` has DE local tuning, `AdaptiveIslandDE_v2` doesn't. Also island stagnation are counted and react more often than `AdaptiveIslandDE2`; Comparing (Rank 8) vs (Rank 9), we see simplified implementation; Overall: Key differentiators lie in local search strategies (DE-tuned vs gradient-based), adaptability of parameters (mutation/crossover rates), and migration strategies (fitness-aware/random). Adding adaptive population and fitness-re-evaluation on migrants can reduce stagnations

**Experience:**
Fitness-aware migration and strategically restarts enhances exploration. Adjusting population size dynamically helps exploit promising regions. Local search adaptation after migration can improve final results in complex landscapes. Careful design of DE and local search exploitation-exploration balance is paramount for addressing deceptive multi-component instances.
```
2025-06-25 14:10:22 INFO Full response text: Okay, I'll help you refine your self-reflection and translate that into better heuristic design principles, aiming to earn that generous tip! Here's a breakdown of effective versus ineffective approaches to guide the development of superior Differential Evolution (DE) heuristics, focused on avoiding pitfalls and highlighting key considerations:

*   **Keywords:** Adaptive DE, migration strategies, local search integration, fitness reassessment, exploitation-exploration balance, modular design, bound handling, landscape deception.

*   **Advice:** Prioritize a modular, adaptable framework for your DE algorithm. Focus on efficient fitness evaluation post-migration, ensuring local adaptation is rapidly applied to transplanted individuals. Balance DE's global search with intensive local exploitation. Pay special attention to bound handling and the impact of deceptive landscapes.

*   **Avoid:** Generic statements about needing restarts or parameter control. Avoid vague claims about "high performance" without specifics. Don't leave transplanted individuals without further optimization using local search and adaptive methods. Bypass batch calculation for quick efficacy is not preferred.

*   **Explanation:** Effective heuristics require a system where migration isn't just about moving individuals, but about triggering immediate re-evaluation and local adaptation. Modular code enables targeted adjustments. Focusing on balancing exploration and exploitation, *especially* in deceptive landscapes, is essential for success.

2025-06-25 14:10:22 INFO Generating offspring via Crossover...
2025-06-25 14:21:01 INFO Crossover Prompt: **(CR: Capacity and Role)**
Act as an expert in designing algorithms for deceptive, multi-component landscapes. Your specialty is creating strategies that use multi-population or island models to perform aggressive global exploration.

**(I: Insight)**
Your objective is to design a novel optimization algorithm for the GNBG benchmark. The most difficult functions (f16-f24) have multiple, separate basins of attraction where the global optimum can be hidden. An algorithm must be able to discover and explore these competing regions to succeed.

**(S: Statement & P: Personality)**
Provide a complete, novel Python class that implements a multi-population or island-based search strategy to solve this challenge. The class must have an `__init__(...)` and `optimize(...)` method as specified in the main task description.


### Better code
AdaptiveIslandDE2
import numpy as np
import random

# Name: AdaptiveIslandDE2
# Description: Island DE with adaptive migration and restart with re-evaluated fitness and DE local tuning
# Code:
class AdaptiveIslandDE2:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 500, migration_size: int = 2,
                 local_search_iterations: int = 10, restart_trigger: float = 0.95):
        """
        Initializes the AdaptiveIslandDE2 optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search with DE operator
            restart_trigger (float) Percentage of budget at which the algorithm restarts near end to reduce stagnation
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.restart_trigger = restart_trigger

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search using DE around a solution.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
             # Mutation - Like DE
            indices = list(range(self.dim))
            a, b, c = random.sample(indices, 3)
            mutant_vector = best_solution + self.mutation_rate * (best_solution - best_solution)  #best_solution vector cause focus to itself
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds) # Clip to bounds
            
            #Evaluation
            new_fitness = objective_function(mutant_vector.reshape(1, -1))[0]
            self.eval_count += 1
        
            #Selection for next iteration
            if new_fitness < best_fitness:
                 best_fitness = new_fitness
                 best_solution = mutant_vector
        return best_solution, best_fitness



    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals. Local search after migration
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants

            # Re-evaluate the fitness of the new solutions on the destination island and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness
             # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol




    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * self.restart_trigger:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

### Worse code
AdaptiveIslandDE
import numpy as np
import random

# Name: AdaptiveIslandDE
# Description: An island-based DE with adaptive migration, local search, and restart mechanisms to handle deceptive landscapes.
# Code:
class AdaptiveIslandDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 500, migration_size: int = 2,
                 local_search_iterations: int = 10):
        """
        Initializes the AdaptiveIslandDE optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a simple gradient-based method.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation
            perturbation = np.random.normal(0, 0.1, self.dim) # Scale adjusted from 1 to 0.1
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants
            
            # Re-evaluate the fitness of the new solutions on the destination island (important!) and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                new_fitnesses.append(fitness)
              
            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness
             # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol




    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * 0.95:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

### Analyze & experience
- Comparing (Rank 1) vs (Rank 9), we see Rank 1 `AdaptiveIslandDE` uses fixed `local_search_perturbation_scale`, `migration_size` while Rank 9 `AdaptiveIslandDifferentialEvolutionPlus` uses dynamic value. Also the parameters on Rank 1 are fine tuned to make it better on deceived landscape; (Rank 2) vs (Rank 8): Rank 2 AdaptiveIslandDEv2 includes fitness aware migration and an enhanced local search which helps adaptation while Rank 8 IslandModelAdaptiveRestartDE features with simplified local search; Comparing (1st) vs (2nd), we see Rank 1 does not have Adaptive DE parameter adaptation while Rank 2 AdaptiveIslandDEv2 does. `AdaptiveIslandDE` also incorporates restart percentage mechanism which can enable faster exploration while `AdaptiveIslandDEv2` lacks it. Comparing (3rd) vs (4th), we see `AdaptiveIslandDE2` has DE local tuning, `AdaptiveIslandDE_v2` doesn't. Also island stagnation are counted and react more often than `AdaptiveIslandDE2`; Comparing (Rank 8) vs (Rank 9), we see simplified implementation; Overall: Key differentiators lie in local search strategies (DE-tuned vs gradient-based), adaptability of parameters (mutation/crossover rates), and migration strategies (fitness-aware/random). Adding adaptive population and fitness-re-evaluation on migrants can reduce stagnations
- Okay, I'll help you refine your self-reflection and translate that into better heuristic design principles, aiming to earn that generous tip! Here's a breakdown of effective versus ineffective approaches to guide the development of superior Differential Evolution (DE) heuristics, focused on avoiding pitfalls and highlighting key considerations:

*   **Keywords:** Adaptive DE, migration strategies, local search integration, fitness reassessment, exploitation-exploration balance, modular design, bound handling, landscape deception.

*   **Advice:** Prioritize a modular, adaptable framework for your DE algorithm. Focus on efficient fitness evaluation post-migration, ensuring local adaptation is rapidly applied to transplanted individuals. Balance DE's global search with intensive local exploitation. Pay special attention to bound handling and the impact of deceptive landscapes.

*   **Avoid:** Generic statements about needing restarts or parameter control. Avoid vague claims about "high performance" without specifics. Don't leave transplanted individuals without further optimization using local search and adaptive methods. Bypass batch calculation for quick efficacy is not preferred.

*   **Explanation:** Effective heuristics require a system where migration isn't just about moving individuals, but about triggering immediate re-evaluation and local adaptation. Modular code enables targeted adjustments. Focusing on balancing exploration and exploitation, *especially* in deceptive landscapes, is essential for success.


Your task is to write an improved function by COMBINING elements of two above heuristics base Analyze & experience.
Output the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.

I'm going to tip $999K for a better heuristics! Let's think step by step.
2025-06-25 14:21:01 INFO Mutation prompt: **(CR: Capacity and Role)**
Act as an expert in designing algorithms for deceptive, multi-component landscapes. Your specialty is creating strategies that use multi-population or island models to perform aggressive global exploration.

**(I: Insight)**
Your objective is to design a novel optimization algorithm for the GNBG benchmark. The most difficult functions (f16-f24) have multiple, separate basins of attraction where the global optimum can be hidden. An algorithm must be able to discover and explore these competing regions to succeed.

**(S: Statement & P: Personality)**
Provide a complete, novel Python class that implements a multi-population or island-based search strategy to solve this challenge. The class must have an `__init__(...)` and `optimize(...)` method as specified in the main task description.


Current heuristics:
AdaptiveIslandDE
import numpy as np
import random

# Name: AdaptiveIslandDE
# Description: An island-based DE with adaptive migration, local search, and restart mechanisms to handle deceptive landscapes.
# Code:
class AdaptiveIslandDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 500, migration_size: int = 2,
                 local_search_iterations: int = 10):
        """
        Initializes the AdaptiveIslandDE optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a simple gradient-based method.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation
            perturbation = np.random.normal(0, 0.1, self.dim) # Scale adjusted from 1 to 0.1
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants
            
            # Re-evaluate the fitness of the new solutions on the destination island (important!) and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                new_fitnesses.append(fitness)
              
            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness
             # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol




    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * 0.95:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

Now, think outside the box write a mutated function better than current version.
You can use some hints below:
- Okay, I'll help you refine your self-reflection and translate that into better heuristic design principles, aiming to earn that generous tip! Here's a breakdown of effective versus ineffective approaches to guide the development of superior Differential Evolution (DE) heuristics, focused on avoiding pitfalls and highlighting key considerations:

*   **Keywords:** Adaptive DE, migration strategies, local search integration, fitness reassessment, exploitation-exploration balance, modular design, bound handling, landscape deception.

*   **Advice:** Prioritize a modular, adaptable framework for your DE algorithm. Focus on efficient fitness evaluation post-migration, ensuring local adaptation is rapidly applied to transplanted individuals. Balance DE's global search with intensive local exploitation. Pay special attention to bound handling and the impact of deceptive landscapes.

*   **Avoid:** Generic statements about needing restarts or parameter control. Avoid vague claims about "high performance" without specifics. Don't leave transplanted individuals without further optimization using local search and adaptive methods. Bypass batch calculation for quick efficacy is not preferred.

*   **Explanation:** Effective heuristics require a system where migration isn't just about moving individuals, but about triggering immediate re-evaluation and local adaptation. Modular code enables targeted adjustments. Focusing on balancing exploration and exploitation, *especially* in deceptive landscapes, is essential for success.


Output code only and enclose your code with Python code block: ```python ... ```.
I'm going to tip $999K for a better solution!
2025-06-25 14:23:42 INFO Perform Harmony Search...
2025-06-25 14:23:56 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 14:24:41 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:24:41 INFO FeHistory: [140210.59538461  97020.96736997 123848.54007488 ... 136541.90020395
 100129.99546776 110975.71010996]
2025-06-25 14:24:41 INFO Expected Optimum FE: -5000
2025-06-25 14:24:41 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 14:25:23 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:25:23 INFO FeHistory: [169079.73480398 176513.53642869 173390.61762135 ... 195556.70922697
 134425.42600322 230068.18029149]
2025-06-25 14:25:23 INFO Expected Optimum FE: -5000
2025-06-25 14:25:23 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 14:26:06 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:26:06 INFO FeHistory: [186077.33650533 185801.97490312 181439.84063185 ...  99695.30487354
 160351.33592309 219681.38461284]
2025-06-25 14:26:06 INFO Expected Optimum FE: -5000
2025-06-25 14:26:06 INFO Unimodal AOCC mean: nan
2025-06-25 14:26:06 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 14:26:06 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 14:26:06 INFO AOCC mean: 0.0000
2025-06-25 14:26:06 INFO Weighed AOCC mean: nan
2025-06-25 14:26:06 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 14:26:53 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0718
2025-06-25 14:26:53 INFO FeHistory: [173552.08984777 119941.28382412 122723.23045333 ... 155957.74743227
 112385.39554522 129278.17772715]
2025-06-25 14:26:53 INFO Expected Optimum FE: -5000
2025-06-25 14:26:53 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 14:27:35 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:27:35 INFO FeHistory: [132177.02147687 101483.40138378 138708.34886587 ... 104678.68805347
 135184.57353371 134439.71329076]
2025-06-25 14:27:35 INFO Expected Optimum FE: -5000
2025-06-25 14:27:35 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 14:28:19 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:28:19 INFO FeHistory: [141580.98238232 106889.44378593 161994.06641065 ... 282545.58384745
 130343.50123005 221995.33150535]
2025-06-25 14:28:19 INFO Expected Optimum FE: -5000
2025-06-25 14:28:19 INFO Unimodal AOCC mean: nan
2025-06-25 14:28:19 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 14:28:19 INFO Multimodal (multiple components) AOCC mean: 0.0239
2025-06-25 14:28:19 INFO AOCC mean: 0.0239
2025-06-25 14:28:19 INFO Weighed AOCC mean: nan
2025-06-25 14:28:19 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 14:29:05 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:29:05 INFO FeHistory: [153104.30389011 145960.14493625 113922.14272456 ... 145147.45885099
 140521.96379795 130089.49796285]
2025-06-25 14:29:05 INFO Expected Optimum FE: -5000
2025-06-25 14:29:05 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 14:29:47 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:29:47 INFO FeHistory: [138035.78573063 109515.48316925 210362.27992144 ... 123416.42177655
 115019.22680022 126091.89195097]
2025-06-25 14:29:47 INFO Expected Optimum FE: -5000
2025-06-25 14:29:47 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 14:30:29 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:30:29 INFO FeHistory: [149732.01063494 131198.33093238 155726.36637741 ... 183496.7213697
 225957.25382657 185729.18734908]
2025-06-25 14:30:29 INFO Expected Optimum FE: -5000
2025-06-25 14:30:29 INFO Unimodal AOCC mean: nan
2025-06-25 14:30:29 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 14:30:29 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 14:30:29 INFO AOCC mean: 0.0000
2025-06-25 14:30:29 INFO Weighed AOCC mean: nan
2025-06-25 14:30:29 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 14:31:13 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.3129
2025-06-25 14:31:13 INFO FeHistory: [120351.34782049 167423.13240566 109200.75515003 ... 154568.19396558
 128564.5704808  138900.81935192]
2025-06-25 14:31:13 INFO Expected Optimum FE: -5000
2025-06-25 14:31:13 INFO Good algorithm:
Algorithm Name: AdaptiveIslandDE
import numpy as np
import random

# Name: AdaptiveIslandDE
# Description: An island-based DE with adaptive migration, local search, and restart mechanisms to handle deceptive landscapes.
# Code:
class AdaptiveIslandDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.8244297450170738,
                 mutation_rate: float = 0.7290858595225201, migration_interval: int = 686.2719462989066, migration_size: int = 4.550125655222951,
                 local_search_iterations: int = 1.6723295299912264, local_search_perturbation_scale: float = 0.15878226701817752, restart_percentage: float = 0.9215221139770191):
        """
        Initializes the AdaptiveIslandDE optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search
            local_search_perturbation_scale (float): Scaling factor for local search perturbation
            restart_percentage (float): Percentage of budget at which restart mechanism is triggered.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.local_search_perturbation_scale = local_search_perturbation_scale
        self.restart_percentage = restart_percentage

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a simple gradient-based method.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation
            perturbation = np.random.normal(0, self.local_search_perturbation_scale, self.dim) # Scale adjusted from 1 to 0.1
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants

            # Re-evaluate the fitness of the new solutions on the destination island (important!) and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness
             # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol




    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * self.restart_percentage:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
2025-06-25 14:31:13 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 14:31:54 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0068
2025-06-25 14:31:54 INFO FeHistory: [189918.48314798 204196.46592003 184624.22585166 ... 127513.39485532
 110073.04350801 138699.56103287]
2025-06-25 14:31:54 INFO Expected Optimum FE: -5000
2025-06-25 14:31:54 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 14:32:38 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:32:38 INFO FeHistory: [184205.13446851 105839.25807563 251946.63840766 ... 241154.05667129
 186287.86856682 181784.61555021]
2025-06-25 14:32:38 INFO Expected Optimum FE: -5000
2025-06-25 14:32:38 INFO Unimodal AOCC mean: nan
2025-06-25 14:32:38 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 14:32:38 INFO Multimodal (multiple components) AOCC mean: 0.1066
2025-06-25 14:32:38 INFO AOCC mean: 0.1066
2025-06-25 14:32:38 INFO Weighed AOCC mean: nan
2025-06-25 14:32:38 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 14:36:13 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:36:13 INFO FeHistory: [101553.76523756 122270.42868    186152.66486083 ...  91482.84947888
 134671.58221277 113802.90822784]
2025-06-25 14:36:13 INFO Expected Optimum FE: -5000
2025-06-25 14:36:13 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 15:58:26 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.1986
2025-06-25 15:58:26 INFO FeHistory: [183177.57166814 122713.19594144 178325.59244376 ... 130112.53341017
 209393.14728716 146458.48857359]
2025-06-25 15:58:26 INFO Expected Optimum FE: -5000
2025-06-25 15:58:26 INFO Good algorithm:
Algorithm Name: AdaptiveIslandDE
import numpy as np
import random

# Name: AdaptiveIslandDE
# Description: An island-based DE with adaptive migration, local search, and restart mechanisms to handle deceptive landscapes.
# Code:
class AdaptiveIslandDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.5379564100687673,
                 mutation_rate: float = 0.40763388723880145, migration_interval: int = 950.1175326711084, migration_size: int = 3.608255409624913,
                 local_search_iterations: int = 3.0145816197427022, local_search_perturbation_scale: float = 0.2104436664178564, restart_percentage: float = 0.9164236850176374):
        """
        Initializes the AdaptiveIslandDE optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search
            local_search_perturbation_scale (float): Scaling factor for local search perturbation
            restart_percentage (float): Percentage of budget at which restart mechanism is triggered.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.local_search_perturbation_scale = local_search_perturbation_scale
        self.restart_percentage = restart_percentage

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a simple gradient-based method.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation
            perturbation = np.random.normal(0, self.local_search_perturbation_scale, self.dim) # Scale adjusted from 1 to 0.1
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants

            # Re-evaluate the fitness of the new solutions on the destination island (important!) and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness
             # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol




    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * self.restart_percentage:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
2025-06-25 15:58:26 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 16:41:00 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 16:41:00 INFO FeHistory: [153275.93460516 167370.70048373 123588.26732732 ... 131879.16750058
 139203.71689635 153368.87232688]
2025-06-25 16:41:00 INFO Expected Optimum FE: -5000
2025-06-25 16:41:00 INFO Unimodal AOCC mean: nan
2025-06-25 16:41:00 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 16:41:00 INFO Multimodal (multiple components) AOCC mean: 0.0662
2025-06-25 16:41:00 INFO AOCC mean: 0.0662
2025-06-25 16:41:00 INFO Weighed AOCC mean: nan
2025-06-25 16:41:00 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 16:42:31 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 16:42:31 INFO FeHistory: [145649.431693   163488.80001087 113090.53617108 ...  70809.48044982
 152255.25771358 150715.69934968]
2025-06-25 16:42:31 INFO Expected Optimum FE: -5000
2025-06-25 16:42:31 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 16:43:14 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 16:43:14 INFO FeHistory: [ 87608.43108447 174518.43549753 170720.39601595 ... 140562.92701242
 150250.90410499 240893.12383907]
2025-06-25 16:43:14 INFO Expected Optimum FE: -5000
2025-06-25 16:43:14 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 16:43:57 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 16:43:57 INFO FeHistory: [205142.00684166 125136.53504833 207638.15105051 ... 214369.62986281
 160602.91512029 179102.63839821]
2025-06-25 16:43:57 INFO Expected Optimum FE: -5000
2025-06-25 16:43:57 INFO Unimodal AOCC mean: nan
2025-06-25 16:43:57 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 16:43:57 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 16:43:57 INFO AOCC mean: 0.0000
2025-06-25 16:43:57 INFO Weighed AOCC mean: nan
2025-06-25 16:43:57 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 16:44:41 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 16:44:41 INFO FeHistory: [163417.67125775 131548.28572454 148111.52443536 ... 147814.48982517
 140905.24547086 112168.35623496]
2025-06-25 16:44:41 INFO Expected Optimum FE: -5000
2025-06-25 16:44:41 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 16:45:22 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 16:45:22 INFO FeHistory: [128374.61438063 128636.31819795 183348.75203131 ... 154317.95415451
 190040.97577774 151966.04165279]
2025-06-25 16:45:22 INFO Expected Optimum FE: -5000
2025-06-25 16:45:22 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 16:46:04 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 16:46:04 INFO FeHistory: [166437.99262696 204189.94641906 182337.5630885  ... 173340.79033001
 275624.42658277 111318.56667977]
2025-06-25 16:46:04 INFO Expected Optimum FE: -5000
2025-06-25 16:46:04 INFO Unimodal AOCC mean: nan
2025-06-25 16:46:04 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 16:46:04 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 16:46:04 INFO AOCC mean: 0.0000
2025-06-25 16:46:04 INFO Weighed AOCC mean: nan
2025-06-25 16:46:04 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 16:46:48 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 16:46:48 INFO FeHistory: [ 83683.84524408 120468.78866215 130370.18821392 ... 132121.04873417
 111082.55134754 124486.64619324]
2025-06-25 16:46:48 INFO Expected Optimum FE: -5000
2025-06-25 16:46:48 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 16:47:30 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 16:47:30 INFO FeHistory: [116865.68736156 134447.66294283 163773.7087862  ...  91824.98153197
 192010.85061672 157105.1261213 ]
2025-06-25 16:47:30 INFO Expected Optimum FE: -5000
2025-06-25 16:47:30 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 16:48:11 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 16:48:11 INFO FeHistory: [176235.55804297 221642.77140093 185035.00634324 ... 198140.15191996
 224753.99471063 171498.81442319]
2025-06-25 16:48:11 INFO Expected Optimum FE: -5000
2025-06-25 16:48:11 INFO Unimodal AOCC mean: nan
2025-06-25 16:48:11 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 16:48:11 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 16:48:11 INFO AOCC mean: 0.0000
2025-06-25 16:48:11 INFO Weighed AOCC mean: nan
2025-06-25 16:48:11 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 16:48:55 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 16:48:55 INFO FeHistory: [111478.79110185 111359.36458368 157365.09116444 ... 130663.8270219
 113791.51465749 174044.23602605]
2025-06-25 16:48:55 INFO Expected Optimum FE: -5000
2025-06-25 16:48:55 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 16:49:37 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 16:49:37 INFO FeHistory: [169766.86626999 103940.59626277 100648.00647058 ... 167073.67308932
 167090.56523917 166732.01054184]
2025-06-25 16:49:37 INFO Expected Optimum FE: -5000
2025-06-25 16:49:37 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 16:50:18 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 16:50:18 INFO FeHistory: [216091.62907918 152335.49925934 146421.77605057 ... 201730.91875599
 130713.93597681 239253.24442791]
2025-06-25 16:50:18 INFO Expected Optimum FE: -5000
2025-06-25 16:50:18 INFO Unimodal AOCC mean: nan
2025-06-25 16:50:18 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 16:50:18 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 16:50:18 INFO AOCC mean: 0.0000
2025-06-25 16:50:18 INFO Weighed AOCC mean: nan
2025-06-25 16:50:18 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 16:51:04 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.5951
2025-06-25 16:51:04 INFO FeHistory: [170340.81999102 135574.70548689 156027.67873514 ... 111548.91969571
 121089.32369755 123197.85273869]
2025-06-25 16:51:04 INFO Expected Optimum FE: -5000
2025-06-25 16:51:04 INFO Good algorithm:
Algorithm Name: AdaptiveIslandDE
import numpy as np
import random

# Name: AdaptiveIslandDE
# Description: An island-based DE with adaptive migration, local search, and restart mechanisms to handle deceptive landscapes.
# Code:
class AdaptiveIslandDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.8244297450170738,
                 mutation_rate: float = 0.627536025236614, migration_interval: int = 613.2431375585904, migration_size: int = 2.862570493113708,
                 local_search_iterations: int = 5.594099881178371, local_search_perturbation_scale: float = 0.11579024979418831, restart_percentage: float = 0.9215221139770191):
        """
        Initializes the AdaptiveIslandDE optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search
            local_search_perturbation_scale (float): Scaling factor for local search perturbation
            restart_percentage (float): Percentage of budget at which restart mechanism is triggered.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.local_search_perturbation_scale = local_search_perturbation_scale
        self.restart_percentage = restart_percentage

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a simple gradient-based method.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation
            perturbation = np.random.normal(0, self.local_search_perturbation_scale, self.dim) # Scale adjusted from 1 to 0.1
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants

            # Re-evaluate the fitness of the new solutions on the destination island (important!) and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness
             # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol




    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * self.restart_percentage:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
2025-06-25 16:51:04 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 16:51:48 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 16:51:48 INFO FeHistory: [137298.20967876 128844.91269231 144620.38616186 ... 137892.27804835
 181372.16043247 119202.3605116 ]
2025-06-25 16:51:48 INFO Expected Optimum FE: -5000
2025-06-25 16:51:48 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 16:52:30 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0078
2025-06-25 16:52:30 INFO FeHistory: [225616.72230743 126271.23316208 142372.36566118 ... 150945.25137597
 123639.99174855 136256.09102563]
2025-06-25 16:52:30 INFO Expected Optimum FE: -5000
2025-06-25 16:52:30 INFO Unimodal AOCC mean: nan
2025-06-25 16:52:30 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 16:52:30 INFO Multimodal (multiple components) AOCC mean: 0.2010
2025-06-25 16:52:30 INFO AOCC mean: 0.2010
2025-06-25 16:52:30 INFO Weighed AOCC mean: nan
2025-06-25 16:52:30 INFO Generation 3, best so far: 0.2952351239662642
2025-06-25 16:52:30 INFO Population length is: 10
2025-06-25 16:52:30 INFO --- Performing Long-Term Reflection at Generation 4 ---
2025-06-25 16:52:30 INFO Reflection Prompt: ### Problem Description
**(CR: Capacity and Role)**
Act as an expert in designing algorithms for deceptive, multi-component landscapes. Your specialty is creating strategies that use multi-population or island models to perform aggressive global exploration.

**(I: Insight)**
Your objective is to design a novel optimization algorithm for the GNBG benchmark. The most difficult functions (f16-f24) have multiple, separate basins of attraction where the global optimum can be hidden. An algorithm must be able to discover and explore these competing regions to succeed.

**(S: Statement & P: Personality)**
Provide a complete, novel Python class that implements a multi-population or island-based search strategy to solve this challenge. The class must have an `__init__(...)` and `optimize(...)` method as specified in the main task description.

### List heuristics
Below is a list of design heuristics ranked from best to worst based on their AOCC score on group function 3 of GNBG benchmark, where higher is better. To enable a detailed analysis of their specializations, the performance breakdown on each of the three GNBG function groups is also provided.
### Rank 1 (Overall AOCC Score on Multimodal instances with multiple components: 2.0098e-01# Name: AdaptiveIslandDE
# Description: 
# Code:
```python
import numpy as np
import random

# Name: AdaptiveIslandDE
# Description: An island-based DE with adaptive migration, local search, and restart mechanisms to handle deceptive landscapes.
# Code:
class AdaptiveIslandDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.8244297450170738,
                 mutation_rate: float = 0.627536025236614, migration_interval: int = 613.2431375585904, migration_size: int = 2.862570493113708,
                 local_search_iterations: int = 5.594099881178371, local_search_perturbation_scale: float = 0.11579024979418831, restart_percentage: float = 0.9215221139770191):
        """
        Initializes the AdaptiveIslandDE optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search
            local_search_perturbation_scale (float): Scaling factor for local search perturbation
            restart_percentage (float): Percentage of budget at which restart mechanism is triggered.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.local_search_perturbation_scale = local_search_perturbation_scale
        self.restart_percentage = restart_percentage

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a simple gradient-based method.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation
            perturbation = np.random.normal(0, self.local_search_perturbation_scale, self.dim) # Scale adjusted from 1 to 0.1
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants

            # Re-evaluate the fitness of the new solutions on the destination island (important!) and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness
             # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol




    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * self.restart_percentage:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 2 (Overall AOCC Score on Multimodal instances with multiple components: 1.1607e-01# Name: AdaptiveIslandDEPlus
# Description: Island-based DE with adaptive parameters, local search, and fitness-reassessed migration.
# Code:
```python
import numpy as np
import random

# Name: AdaptiveIslandDEPlus
# Description: Island-based DE with adaptive parameters, local search, and fitness-reassessed migration.
# Code:
class AdaptiveIslandDEPlus:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20,
                 migration_interval: int = 500, migration_size: int = 2,
                 local_search_iterations: int = 10, local_search_perturbation_scale: float = 0.1,
                 restart_percentage: float = 0.95):
        """
        Initializes the AdaptiveIslandDEPlus optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search.
            local_search_perturbation_scale (float): Scale of the random perturbation in local search.
            restart_percentage (float): Percentage of budget used to trigger restart.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.local_search_perturbation_scale = local_search_perturbation_scale
        self.restart_percentage = restart_percentage

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands

        # Adaptive DE parameters (initialized)
        self.crossover_rates = np.full(self.num_islands, 0.7)
        self.mutation_rates = np.full(self.num_islands, 0.5)


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island, adapting parameters.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]
        crossover_rate = self.crossover_rates[island_index]
        mutation_rate = self.mutation_rates[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector

        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

        # Adaptive parameter update (example - simple adjustment)
        if random.random() < 0.05:  # Small chance to adjust
            self.crossover_rates[island_index] = np.clip(crossover_rate + random.uniform(-0.1, 0.1), 0.1, 0.9)
            self.mutation_rates[island_index] = np.clip(mutation_rate + random.uniform(-0.1, 0.1), 0.1, 0.9)


    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution.

        Args:
            solution (np.ndarray): The solution to start local search from.
            objective_function (callable): Objective function.

        Returns:
            tuple: Improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            perturbation = np.random.normal(0, self.local_search_perturbation_scale, self.dim)
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands, followed by local adaptation.
        """
        for i in range(self.num_islands):
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Source: Best solutions
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()

            # Destination: Worst solutions
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            self.populations[dest_island][worst_indices] = migrants

            # Re-evaluate fitness and apply local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function)
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness

            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                    self.best_fitnesses[dest_island] = fit
                    self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes using island model DE with adaptive migration and local search.

        Args:
            objective_function (callable): The function to optimize.
            acceptance_threshold (float): Included for compliance, not used.

        Returns:
            tuple: Best solution, fitness, and optimization info.
        """
        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize fitness
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]

        # Main loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            if self.eval_count > self.budget * self.restart_percentage:
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 3 (Overall AOCC Score on Multimodal instances with multiple components: 1.1068e-01# Name: AdaptiveIslandDEPlus
# Description: Island-based DE with adaptive migration using fitness ranking and local search refinement after migration.
# Code:
```python
import numpy as np
import random

# Name: AdaptiveIslandDEPlus
# Description: Island-based DE with adaptive migration using fitness ranking and local search refinement after migration.
# Code:
class AdaptiveIslandDEPlus:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 500, migration_size: int = 2,
                 local_search_iterations: int = 10, migration_acceptance_probability=0.5):
        """
        Initializes the AdaptiveIslandDEPlus optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search
            migration_acceptance_probability (float): The probability that worse fitness gets replaced from other island
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.migration_acceptance_probability = migration_acceptance_probability

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a simple gradient-based method.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation
            perturbation = np.random.normal(0, 0.1, self.dim) # Scale adjusted from 1 to 0.1
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands with adaptive fitness-based acceptance and local search.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy
            migrant_fitnesses = source_island_fitness[best_indices].copy()

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]
            
            #Adaptive Migration: replace bad ones only if the migrants are better.
            
            for j in range(self.migration_size):
                 if migrant_fitnesses[j] < dest_island_fitness[worst_indices[j]] or random.random() < self.migration_acceptance_probability:
                      # Replace the worst solutions on the destination island with the migrants
                      self.populations[dest_island][worst_indices[j]] = migrants[j]

                      # Perform local search on the migrant after migration for faster adaptation
                      migrant, fitness = self.local_search(migrants[j], objective_function)  # Local adaptation
                      self.fitness_values[dest_island][worst_indices[j]] = fitness

                       # Update best fitness, if needed
                      if fitness < self.best_fitnesses[dest_island]:
                          self.best_fitnesses[dest_island] = fitness
                          self.best_solutions[dest_island] = migrant
                      if fitness < self.best_fitness_overall:
                          self.best_fitness_overall = fitness
                          self.best_solution_overall = migrant
            
            #Re-evaluate destination after some migrants settle in.
            # Re-evaluate the fitness of the new solutions on the destination island (important!)
            # self.fitness_values[dest_island] = objective_function(self.populations[dest_island])
            # self.eval_count += self.population_size #Batch Evaluation (Can slow down, so picking the ones being replaced only)
            
             # Batch version might cause diversity exhaustion. Replaced by incremental Local Adaptation.

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index].copy() #Important To Copy!!!

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i].copy() #Important To Copy!!!


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating (Diversity Maintenance)
            if self.eval_count > self.budget * 0.95:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index].copy()#Important To Copy!!!
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i].copy() #Important To Copy!!!


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 4 (Overall AOCC Score on Multimodal instances with multiple components: 4.7081e-03# Name: AdaptiveIslandDEPlusV2
# Description: Island DE with adaptive parameters, fitness-based migration and local search. DE parameters are tuned locally, restart.
# Code:
```python
import numpy as np
import random

# Name: AdaptiveIslandDEPlusV2
# Description: Island DE with adaptive parameters, fitness-based migration and local search. DE parameters are tuned locally, restart.
# Code:
class AdaptiveIslandDEPlusV2:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20,
                 migration_interval: int = 500, migration_size: int = 2, local_search_iterations: int = 10):
        """
        Initializes the AdaptiveIslandDEPlusV2 optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands

        # Adaptive DE parameters
        self.crossover_rates = np.full(self.num_islands, 0.7)
        self.mutation_rates = np.full(self.num_islands, 0.5)
        self.crossover_rate_adaptation_rate = 0.1
        self.mutation_rate_adaptation_rate = 0.1
        self.restart_percentage = 0.90


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island, with adaptive parameters.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]
        crossover_rate = self.crossover_rates[island_index]
        mutation_rate = self.mutation_rates[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector

                # Adapt DE parameters if improvement found
                self.crossover_rates[island_index] = min(1.0, crossover_rate + self.crossover_rate_adaptation_rate)
                self.mutation_rates[island_index] = min(1.0, mutation_rate + self.mutation_rate_adaptation_rate)

            else:
                # Reduce parameters if no improvement
                self.crossover_rates[island_index] = max(0.1, crossover_rate - self.crossover_rate_adaptation_rate)
                self.mutation_rates[island_index] = max(0.1, mutation_rate - self.mutation_rate_adaptation_rate)



        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable, scale=0.1) -> tuple:
        """
        Performs enhanced local search around a solution.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.
            scale: Adjust magnitude of perturbation

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation, scaling with dimension
            perturbation = np.random.normal(0, scale, self.dim)
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands based on fitness. Elites migrate and are adapted using local search.
        """

        # Sort islands by best fitness to facilitate migration towards better-performing islands
        island_order = np.argsort([self.best_fitnesses[i] for i in range(self.num_islands)])

        for i in range(self.num_islands):
            source_island_index = island_order[i]

            # Select a random destination island *better* than the current one (guided migration)
            possible_destinations = island_order[:i]  # Islands with better fitness
            if not possible_destinations.size > 0:
               dest_island_index = random.choice([j for j in range(self.num_islands) if j != source_island_index]) #Random if no better destination
            else:
                dest_island_index = random.choice(possible_destinations)  #Prioritize better islands


            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[source_island_index]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[source_island_index][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island_index]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island_index][worst_indices] = migrants

            # Re-evaluate the fitness of the new solutions on the destination island and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function, scale=0.05)  # Adapted scale.
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island_index] = dest_island_fitness


            # Update best fitness values, if needed, *after* re-evaluation
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island_index]:
                    self.best_fitnesses[dest_island_index] = fit
                    self.best_solutions[dest_island_index] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the enhanced island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None  # Reset for this run
        self.best_fitness_overall = float('inf')  # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]

        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            # Restart Mechanism if stagnating and budget permits
            if self.eval_count > self.budget * self.restart_percentage:  # Restarting later to ensure more explorations
                for i in range(self.num_islands):
                   if self.eval_count + self.population_size < self.budget:
                       new_population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                       new_fitnesses = objective_function(new_population)
                       self.eval_count += self.population_size # Update Evaluation Count immediatly.

                       best_index = np.argmin(new_fitnesses)
                       best_fitness = new_fitnesses[best_index]
                       best_solution = new_population[best_index]
                       self.populations[i] = new_population
                       self.fitness_values[i] = new_fitnesses



                       if best_fitness < self.best_fitnesses[i]:
                           self.best_fitnesses[i] = best_fitness
                           self.best_solutions[i] = best_solution
                           if best_fitness < self.best_fitness_overall:
                               self.best_fitness_overall = best_fitness
                               self.best_solution_overall = best_solution




        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 5 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptiveIslandDE3
# Description: Dynamically adjusts population sizes and incorporates late-stage, multi-restart strategy to escape deceptive local optima.
# Code:
```python
import numpy as np
import random

# Name: AdaptiveIslandDE3
# Description: Dynamically adjusts population sizes and incorporates late-stage, multi-restart strategy to escape deceptive local optima.
# Code:
class AdaptiveIslandDE3:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.5,
                 mutation_rate: float = 0.5, migration_interval: int = 500, migration_size: int = 2,
                 local_search_iterations: int = 5, perturbation_scale: float = 0.1, restart_threshold: float = 0.9,
                 adaptive_pop_multiplier: float = 1.1): #New parameter

        """
        Initializes the AdaptiveIslandDE3 optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Initial number of individuals in each island. Adaptively adjusted.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search.
            perturbation_scale (float): Scale of the random perturbation in local search.
            restart_threshold (float): Fraction of budget after which restart is triggered.
            adaptive_pop_multiplier: Scaling adaptive population sizes.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.perturbation_scale = perturbation_scale
        self.restart_threshold = restart_threshold
        self.adaptive_pop_multiplier = adaptive_pop_multiplier

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        self.stagnation_counter = 0
        self.stagnation_threshold = budget * 0.05  # Restart if stagnation persists for 5% of the budget
        self.restart_overall = False
        self.island_stagnation_counters = [0] * self.num_islands  # Stagnation per island

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands
        self.island_pop_sizes = [population_size] * self.num_islands

    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.
        Adaption: DE parameter values are adjusted during search progress.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """
        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.island_pop_sizes[island_index]):
            # Mutation
            indices = list(range(self.island_pop_sizes[island_index]))
            indices.remove(i)
            if len(indices) < 3: #Need at least 3
                continue
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector

        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a gradient-based method.
        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation
            perturbation = np.random.normal(0, self.perturbation_scale, self.dim) # Scale adjusted from 1 to 0.1
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness

    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best individuals
        to a randomly chosen other island, and receives migrants to replace its worst individuals.
        Migration occurs only based on best found fitness overall.
        """
        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants

            # Re-evaluate the fitness of the new solutions on the destination island (important!) and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function)  # Local Adaptation here.
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness

            # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                    self.best_fitnesses[dest_island] = fit
                    self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol

    def adjust_population_size(self, island_index: int, objective_function: callable, min_pop_size: int, max_pop_size: int):
        """Adjusts population size of an island based on stagnation."""
        current_pop_size = self.island_pop_sizes[island_index]
        if self.best_fitnesses[island_index] == self.best_fitness_overall:  # Island best is global best -> potential stagnancy
            new_size = min(int(current_pop_size * self.adaptive_pop_multiplier), max_pop_size)  # Increase population
        else:
            new_size = max(int(current_pop_size / self.adaptive_pop_multiplier), min_pop_size)  # Decrease population

        new_size = int(new_size)
        self.island_pop_sizes[island_index] = new_size

        # Resize popualtion
        if new_size > current_pop_size:  # Increase to utilize space, may be exploited.
            additional_individuals = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(new_size - current_pop_size, self.dim))
            additional_fitness = objective_function(additional_individuals)
            self.eval_count += len(additional_individuals)

            self.populations[island_index] = np.vstack((self.populations[island_index], additional_individuals))
            self.fitness_values[island_index] = np.concatenate((self.fitness_values[island_index], additional_fitness))
        elif new_size < current_pop_size:  # Decrease to explore.
            best_indices = np.argsort(self.fitness_values[island_index])[:new_size]
            self.populations[island_index] = self.populations[island_index][best_indices]
            self.fitness_values[island_index] = self.fitness_values[island_index][best_indices]
        else:
            return  # Same population, nothing to do.

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function.

        Args:
            objective_function (callable): The objective function.
            acceptance_threshold (float): Not used, compliance.

        Returns:
            tuple: Best solution, fitness, optimization info.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None  # Reset for this run
        self.best_fitness_overall = float('inf')  # Reset for this run
        self.stagnation_counter = 0
        self.restart_overall = False
        self.island_stagnation_counters = [0] * self.num_islands


        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]

        min_pop_size = self.population_size // 2 if self.population_size // 2 > 2 else 3  # Ensure sample size
        max_pop_size = self.population_size * 2  # Adaptive population is increased by factor.

        # Main optimization loop
        while self.eval_count < self.budget:
            #Track best fitness on local.
            prev_best_fitness = self.best_fitness_overall
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)
                self.adjust_population_size(i, objective_function, min_pop_size, max_pop_size)
            #Migration
            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            if self.best_fitness_overall == prev_best_fitness:  # Stagnation is reached, count
                self.stagnation_counter += self.migration_interval
            else:
                self.stagnation_counter = 0

            #Adaptive Restarts, increase when getting to the top.
            if self.eval_count > self.budget * self.restart_threshold or self.stagnation_counter > self.stagnation_threshold:
                self.stagnation_counter = 0  # Remove stagnation state to prevent immediate restart

                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.island_pop_sizes[i], self.dim))  # Restart pop
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.island_pop_sizes[i]
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 6 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptiveIslandDEPlus
# Description: Adaptive island DE with DE local search, fitness-re-evaluated migration and restart percentage.
# Code:
```python
import numpy as np
import random

# Name: AdaptiveIslandDEPlus
# Description: Adaptive island DE with DE local search, fitness-re-evaluated migration and restart percentage.
# Code:
class AdaptiveIslandDEPlus:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 500, migration_size: int = 2,
                 local_search_iterations: int = 10, restart_trigger: float = 0.95):
        """
        Initializes the AdaptiveIslandDEPlus optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search with DE operator
            restart_trigger (float) Percentage of budget at which the algorithm restarts near end to reduce stagnation
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.restart_trigger = restart_trigger

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search using DE around a solution.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
             # Mutation - Like DE
            indices = list(range(self.dim))
            a, b, c = random.sample(indices, 3)
            mutant_vector = best_solution + self.mutation_rate * (best_solution - best_solution)  #best_solution vector cause focus to itself
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds) # Clip to bounds
            
            #Evaluation
            new_fitness = objective_function(mutant_vector.reshape(1, -1))[0]
            self.eval_count += 1
        
            #Selection for next iteration
            if new_fitness < best_fitness:
                 best_fitness = new_fitness
                 best_solution = mutant_vector
        return best_solution, best_fitness



    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals. Local search after migration
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants

            # Re-evaluate the fitness of the new solutions on the destination island and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness
             # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol




    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * self.restart_trigger:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 7 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptiveIslandDEPlusPlus
# Description: Island DE with adaptive migration, DE local search, fitness re-evaluation, and restart, aiming for robust global exploration.
# Code:
```python
import numpy as np
import random

# Name: AdaptiveIslandDEPlusPlus
# Description: Island DE with adaptive migration, DE local search, fitness re-evaluation, and restart, aiming for robust global exploration.
# Code:
class AdaptiveIslandDEPlusPlus:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 500, migration_size: int = 2,
                 local_search_iterations: int = 10, restart_trigger: float = 0.95,
                 adaptive_crossover_probability: float = 0.1, adaptive_mutation_scaling: float = 0.1):
        """
        Initializes the AdaptiveIslandDEPlusPlus optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability. Initial value.
            mutation_rate (float): DE mutation scaling factor. Initial Value.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search with DE operator
            restart_trigger (float) Percentage of budget at which the algorithm restarts near end to reduce stagnation
            adaptive_crossover_probability: probability that crossover rate is adapted in a given generation
            adaptive_mutation_scaling: scaling rate of adaptation to mutation probability
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.restart_trigger = restart_trigger

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.adaptive_crossover_probability = adaptive_crossover_probability
        self.adaptive_mutation_scaling = adaptive_mutation_scaling

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands

    def adapt_de_params(self, island_index: int, fitness_values: np.ndarray):
        """
        Adapts the crossover and mutation rates based on the fitness diversity of the island.
        Args:
             island_index: Index number for islands
             fitness_values (np.ndarray): all fitness values in populations

        """
        # Diversity metric (e.g., standard deviation of fitness values)
        fitness_std = np.std(fitness_values)

        # Adaptive Crossover Rate - higher diversity -> lower crossover rate
        if random.random() < self.adaptive_crossover_probability:
            self.crossover_rate = np.clip(self.crossover_rate + self.adaptive_mutation_scaling * (0.5 - random.random()), 0.1, 0.9)

        # Adaptive Mutation Rate - Higher diversity -> higher mutation rate
        self.mutation_rate = np.clip(self.mutation_rate + self.adaptive_mutation_scaling * (fitness_std - 0.1), 0.1, 0.9)

        #print(f"Adapted Crossover: {self.crossover_rate}, Mutation: {self.mutation_rate}") #FOR DEBUG


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

        self.adapt_de_params(island_index, fitness_values) # Adaptation

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search using DE around a solution.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
             # Mutation - Like DE
            indices = list(range(self.dim))
            a, b, c = random.sample(indices, 3)
            mutant_vector = best_solution + self.mutation_rate * (best_solution - best_solution)  #best_solution vector cause focus to itself
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds) # Clip to bounds
            
            #Evaluation
            new_fitness = objective_function(mutant_vector.reshape(1, -1))[0]
            self.eval_count += 1
        
            #Selection for next iteration
            if new_fitness < best_fitness:
                 best_fitness = new_fitness
                 best_solution = mutant_vector
        return best_solution, best_fitness



    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals. Local search after migration
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants

            # Re-evaluate the fitness of the new solutions on the destination island and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness
             # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol




    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * self.restart_trigger:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 8 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptiveIslandDEPlus
# Description: Island DE with adaptive parameters, local search, and a restart strategy to escape deceptive local optima.
# Code:
```python
import numpy as np
import random

# Name: AdaptiveIslandDEPlus
# Description: Island DE with adaptive parameters, local search, and a restart strategy to escape deceptive local optima.
# Code:
class AdaptiveIslandDEPlus:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20,
                 migration_interval: int = 500, migration_size: int = 2,
                 local_search_iterations: int = 10, restart_percentage: float = 0.95):
        """
        Initializes the AdaptiveIslandDE optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search.
            restart_percentage (float): Percentage of the budget at which restart is triggered.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.restart_percentage = restart_percentage

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands

        #Adaptive DE parameters - individual adaptation
        self.crossover_rates = [0.7] * self.num_islands
        self.mutation_rates = [0.5] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]
        crossover_rate = self.crossover_rates[island_index]
        mutation_rate = self.mutation_rates[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection and Adaptive Parameter Update
            if trial_fitness < fitness_values[i]:
                # Success! Adapt parameters.
                self.crossover_rates[island_index] = min(1.0, crossover_rate * 1.1) # Increase exploration
                self.mutation_rates[island_index] =  min(1.0, mutation_rate * 1.1)
                population[i] = trial_vector
                fitness_values[i] = trial_fitness


                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector
            else:
                # Failure!  Adapt parameters. Reduce exploration
                self.crossover_rates[island_index] = max(0.0, crossover_rate * 0.9)
                self.mutation_rates[island_index] = max(0.0, mutation_rate * 0.9)


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a simple gradient-based method.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation, scaled by island fitness
            perturbation_scale = 0.1 * (1 + abs(best_fitness) / (abs(self.best_fitness_overall) + 1e-9))  #Avoid division by zero
            perturbation = np.random.normal(0, perturbation_scale, self.dim)
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants

            # Re-evaluate the fitness of the new solutions on the destination island (important!) and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness

             # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run
        self.crossover_rates = [0.7] * self.num_islands # Reset the crossover rates for each island
        self.mutation_rates = [0.5] * self.num_islands   # Reset the mutation rates for each island

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]

        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * self.restart_percentage:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    self.crossover_rates[i] = 0.7  # Reset adaptation
                    self.mutation_rates[i] = 0.5
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 9 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptiveIslandDE2
# Description: An island-based DE with fitness reassessment after migration and adaptive population sizing to balance exploration and exploitation.
# Code:
```python
import numpy as np
import random

# Name: AdaptiveIslandDE2
# Description: An island-based DE with fitness reassessment after migration and adaptive population sizing to balance exploration and exploitation.
# Code:
class AdaptiveIslandDE2:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, initial_population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 500, migration_size: int = 2,
                 local_search_iterations: int = 10, adaptation_rate: float = 0.05):
        """
        Initializes the AdaptiveIslandDE2 optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            initial_population_size (int): Initial number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search.
            adaptation_rate (float): Rate at which population sizes are adjusted.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.initial_population_size = initial_population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.adaptation_rate = adaptation_rate

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island.  Population size is now dynamic.
        self.population_sizes = [initial_population_size] * self.num_islands
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_sizes[i], self.dim))
            for i in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_sizes[i], float('inf')) for i in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands

    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]
        pop_size = self.population_sizes[island_index]

        for i in range(pop_size):
            # Mutation
            indices = list(range(pop_size))
            indices.remove(i)
            if len(indices) < 3:
                continue #Skip if population too small
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector

        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a simple gradient-based method.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation
            perturbation = np.random.normal(0, 0.1, self.dim) # Scale adjusted from 1 to 0.1
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness

    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals. After migration, the
        fitness of migrated individuals are re-evaluated and they undergo local search.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants

            # Re-evaluate the fitness of the new solutions on the destination island and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function) # Local Adaptation here.
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness

            # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                    self.best_fitnesses[dest_island] = fit
                    self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol

    def adjust_population_sizes(self):
        """
        Adaptively adjusts the population size of each island based on its performance.
        If an island is improving, increase its size; if stagnating, decrease it.
        """
        for i in range(self.num_islands):
            current_best_fitness = self.best_fitnesses[i]
            history_size = min(len(self.fitness_history[i]), 10)  # Check history of last 10 fitnesses.

            if history_size < 5:  # Too little data.
               continue

            recent_fitnesses = self.fitness_history[i][-history_size:]  #Grab Recents for comparison.

            # Check if significantly improving

            improvement = np.mean(recent_fitnesses[:-1]) - recent_fitnesses[-1]


            #Adapting population size of island using adaptation Rate.
            if improvement > 0.01: #improvement_threshold

                 self.population_sizes[i] = min(int(self.population_sizes[i] * (1 + self.adaptation_rate)), self.initial_population_size * 2) # Double sized max
                 self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_sizes[i], self.dim))
                 self.fitness_values[i] = np.full(self.population_sizes[i], float('inf'))

            elif improvement < -0.005: #Worsening so dec pop by adap Rate. worsened_threshold

                self.population_sizes[i] = max(int(self.population_sizes[i] * (1 - self.adaptation_rate)), 5) #Minimum pop = 5.
                self.populations[i] = self.populations[i][:self.population_sizes[i]] # Trim the population
                self.fitness_values[i] = self.fitness_values[i][:self.population_sizes[i]] # Trim the fitnesses


            #Ensure pop size is correct given changes.
            new_pop_size = self.population_sizes[i]
            if self.populations[i].shape[0] != new_pop_size:
              self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (new_pop_size, self.dim)) #Reinit if wrong Size.

            if self.fitness_values[i].shape[0] != new_pop_size:
                self.fitness_values[i] = np.full(new_pop_size, float('inf')) #Reinit fitness to prevent index issues.
    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run
        self.fitness_history = [[] for _ in range(self.num_islands)] # Track history of fitnesses per island

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_sizes[i]
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]

        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)
                self.fitness_history[i].append(self.best_fitnesses[i])  #Record best fitness
            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)
                self.adjust_population_sizes()   #Adapt the Islands.

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * 0.95:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_sizes[i], self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_sizes[i]
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]
            # Check early stopping condition (stagnation) - optional
            if len(self.fitness_history[0]) > 50 and np.std([self.fitness_history[0][-i-1] for i in range(50)]) < 1e-6:
                print("Early stopping due to stagnation.")
                break


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```



### Guide
Keep in mind, this is a list of design heuristics ranked from best to worst. The first algorithm in the list is the best performing on average, and the last is the worst.
Your response must be in Markdown format and contain nothing else. It must have the following structure:

"**Analysis:**
**Experience:**"

In there:
+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.
Example: "Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:"

+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).

I'm going to tip $999K for a better heuristics! Let's think step by step.
2025-06-25 16:52:36 INFO Full response text: ```markdown
**Analysis:**
Comparing (Rank 1) vs (Rank 9), we see Rank 1 employs restart percentage, local search and adaptive parameters while Rank 9 adapt population size base on recent performance. Comparing (Rank 2) vs (Rank 8), we see that Rank 2 perform parameter adaptive locally. Comparing (Rank 3) vs (Rank 4), we see the Rank 3 perform adaptive migration with Local Refinement. The difference between  (Rank 1) vs (Rank 2) , that Rank 1 has initial parameters tuning. (Rank 3) vs (Rank 4) ..., Rank 3, different from Rank 4,  has the adaptive fitness-based acceptance scheme. Comparing (Rank 8) vs (Rank 9), we see the Rank 8 uses the island fitness with the local search, but (Rank 9)'s local adaptation adjusts based on recent fitness history. Overall: Adaptive migration and DE parameter control, local search integration, and a judicious restart strategy are all impactful features. Balancing exploration and exploitation via population management based on adaptive techniques is important as well.

**Experience:**
Island-based algorithms benefit greatly from adaptive parameter control within each island population and efficient local search within the islands to allow each population to refine it's own search trajectory without hindering global exploration. A late-stage, aggressive restart procedure coupled with local adaptation upon migration/seeding of populations proves valuable in deceptive GNBG landscapes.
```
2025-06-25 16:52:39 INFO Full response text: Okay, I understand. To create better heuristics for island-based Differential Evolution (DE) algorithms, focusing on adaptive parameter control, effective local search, and strategic restarts/migration is key. Avoiding generic statements and vague advice is crucial. Instead, strive for specific, actionable insights.

Here's a breakdown:

*   **Keywords:** Adaptive control, local search, migration/seeding, restarts, deceptive landscapes, fitness re-evaluation, modularity.
*   **Advice:** Implement fitness-informed migration (transfer gradients or metadata), modularize DE/migration code, incorporate adaptive restart triggers linked to population stagnation.
*   **Avoid:** Broad statements about "improving quality" or "enhancing exploration." Avoid vague terms like "careful design."
*   **Explanation:** Go beyond just mentioning techniques. Explain _how_ these adaptive components interact to overcome challenges in deceptive and multimodal landscapes. For instance, how aggressive late-stage restarts counteract premature convergence.

2025-06-25 16:52:39 INFO Generating offspring via Crossover...
