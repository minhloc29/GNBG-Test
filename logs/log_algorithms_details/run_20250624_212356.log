2025-06-24 21:23:57 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-24 21:23:57 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-24 21:23:57 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-24 21:23:57 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-24 21:23:57 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-24 21:23:57 ERROR Can not run the algorithm
2025-06-24 21:23:58 INFO Run function 16 complete. FEHistory len: 510, AOCC: 0.0000
2025-06-24 21:23:58 INFO FeHistory: [110096.54790739 123646.08475941 141627.5551394  130797.35833689
 106246.81388273 145175.32395806 125055.94459876 101558.35316229
 128452.90943719 112082.64461008 138696.31707595 131895.60188685
 148940.43347342 170524.5101281  117586.84789193 168452.23692782
  94012.04867839 177171.3134204  153415.20398869 160698.34150503
 128888.93041631 140181.61634315 149260.9284861  118647.51156976
 149408.03998717 183166.3830413  126871.85716645 129808.25220639
 135197.17820713 163133.14004563 101687.20130118 125029.6404096
 102532.64291297 114409.22596636 113903.53650158 123432.26350273
 116399.51763876 107653.76387043 122654.93870529 107212.18687428
 116684.34523475 113344.52812724 110280.95462619 117307.12099907
 146666.88898064 144839.78091864 116146.39633288 158881.84579834
 168405.82094453  84394.15961096 111737.19448041 123664.79944927
 167783.06497641 155235.72451403 175839.83687425 145780.40551618
  94393.57261113 163004.75597819 111243.57870493 118158.22903002
 139553.76290312 123657.49854836  93282.76525068 143619.17624039
 165905.58915112 199560.75603889 146144.76460496 101539.69703428
  95582.3981755  118423.09288939 113818.17880043  69152.7481033
 157662.10156092 109086.73355549 153838.99165207 118833.62710287
 158423.16329538 135152.58199988 137888.9305636  126278.55391609
  92224.75348948  66082.02499965  97943.19727268  73551.04794411
  98105.87489437 139839.03709347 127037.94874155  99470.2738063
  83233.08322414  78132.83107159  84359.77385638  88198.83516866
 142265.21898465  87525.33477832  90838.5205188  168171.58259801
 121161.11430874 127627.9507765   92050.17114053 125185.82484429
  90051.22449025  75439.5065171  100517.5317876   68724.17462289
  80695.68141226 104025.54168366  99500.95276912  96238.79599509
  84390.70687579 108335.49154992  85546.617445    94879.31176121
  84863.25873194 117129.77283637 114558.36330833 112115.76894057
 112816.16646318 114145.10593951  92229.91993686 126047.54751414
  75173.18411103  72051.67923797 105608.66602715  69409.01395988
 104340.15336151  95887.31994617 117559.00716802  97368.39519535
  88302.29253942  90862.39148564  71151.72313861  66904.13763572
 105363.22450783 104091.47422985  96892.58969697 121322.83379807
 122750.99052818 138420.67583081  85750.74980006 107212.18687428
  72212.85233471  60001.84666776 113499.55297958  98193.69287232
 107907.81663128 100626.17405653 129544.98169645 109036.54939154
  66457.83587441  59729.15440621  66396.87494515  62724.60493645
  88517.35592435  93065.63059302  85836.44005795 113437.91378972
 120443.79573661  88982.83211714 131924.61337854  87710.50636982
  83461.81752605  66991.91678921  66602.0952083   80538.98277493
  83841.59750773  84660.25936793 100496.85937779 125621.29801878
  64767.11675718  66670.04800171  62778.93210358  61086.19346971
  85882.55188532 106672.12455203 107958.84689745 107954.15197301
 103417.38288538  87686.5466737  110436.88500204  86744.91351269
  68446.57078554  66283.4523649   73292.28245542  55832.99857666
  90052.99712246 105795.30241707 109053.96728356 108818.3518258
  74392.15052262  59850.55044899  59728.29040689  67433.48068179
 105425.56940306  78821.52020818 108143.0620268   98539.01092584
  91872.8154025   94555.31878624  81656.81215574 108711.28463897
  59436.2073499   64353.86393033  66780.97824148  77854.38116286
  79034.1594295   96481.67247993  84831.97169705 105853.07158163
  60943.09672262  61555.02707542  60243.07484905  64878.40569043
  93880.91685564  78630.02691857 107713.97966491  89601.08437134
  78718.10313582 102311.82531563  77896.93581294  70077.2245979
  58130.47034758  50851.36530426  57328.93778865  51921.63393395
  63991.03577797 112063.31553662  86686.61920378  96300.54924181
  64678.68579465  62176.76206843  63008.61912423  59311.01019423
  75714.60772268  82997.15177005  80710.20757016  91839.25814418
  95535.35909781  87274.74117496  66062.3147961  102386.07335896
  50253.093045    53458.24199135  53221.79415174  51228.14854789
  65876.98738093  86528.39990385 121560.98315899  92146.32350797
  63661.43068859  54032.50612628  62547.28020863  58474.34605593
  86968.4153763   94449.47557249  80895.24019821  90772.67043784
  69945.92179513  67703.37199542  69785.6427094   76360.04446934
  54852.55895472  50527.61943838  55328.50190792  54237.48396001
  85208.31267867  75835.54807137  80880.57732161  83036.95753928
  60317.90154414  55656.42076115  57947.3270654   57799.19044671
  84744.15592712  86458.57616213  78937.86830514  89478.30887013
  67014.30776247  67549.5766284   69629.83151956  64916.88578303
  48080.92776692  50707.92290566  50923.98633818  48283.03018715
  89543.94055928  81082.93933412  70329.73788578  80603.30828223
  58698.42040033  58724.50646934  58857.22314295  58475.11890748
  83777.01366533  84528.1944464   76800.93434201  75512.46915323
  62321.61241718  61354.52774869  67841.8390738   57039.1767548
  50980.36366821  53182.00685187  52971.27675172  48170.87445868
  63350.82535567  88197.60596936  72422.2565131   92938.24502888
  54621.40141261  55339.91980114  57455.90484039  58456.79485813
  74312.91320471  77537.07086354  76927.66070053  75577.249444
  63587.76194445  64642.12458402  58616.95278496  66237.08407465
  53731.67479678  49570.44324566  48054.91739152  51981.79066136
  79323.51880399  88903.97042859  74527.74721518  78265.46040406
  55476.53572879  53923.45474871  57835.91720169  55185.30062273
  77241.93228214  76302.29470633  78385.73888519  75481.55666284
  57942.44247814  59866.85204748  58505.82761163  56671.65798689
  51803.4437441   48939.87924984  50082.48354491  48728.13492932
  73106.22050508  74858.49935646  64782.07440573  74890.87527127
  54853.5557505   56387.99978162  57277.88490494  58321.39352086
  74977.7021667   76351.60268409  73387.34424913  76217.38164517
  61279.09085575  60599.44097839  59966.65561779  56520.5675942
  48444.75277718  47164.67282859  46790.23083861  45655.44745251
  65787.26921711  73007.80050191  81249.84551271  67905.27378944
  53618.61001821  53925.92489607  53542.91287072  54133.61716601
  73819.0203635   75642.5713135   73824.80864299  76729.75574989
  55579.71474391  58551.25486495  61449.32826551  58795.84280387
  49055.42568757  48142.85283592  45011.75931959  46720.18237196
  72206.51511509  66149.35098924  72858.97282967  67621.15964714
  55619.63432404  53427.68943595  52425.13620996  54385.91617489
  76674.93661229  73484.02678639  74689.33863688  74687.78803031
  57003.74436873  54837.26187492  50844.23906397  51219.0529273
  46511.46141645  45058.03024103  47373.88208744  44589.09553527
  74632.72055404  70388.46276177  63464.3919094   64579.25575461
  53224.97771169  52689.53293647  53233.78386994  53646.13168151
  73523.66674832  72940.97863813  73147.12845643  75070.73825697
  54526.03620857  49405.45548743  54643.02703696  50997.43418175
  46983.87089077  44166.23979941  45522.97835813  46097.81985927
  61308.71850735  61070.54908842  60404.38705913  60548.34834734
  54263.4889842   52843.67252403  52233.65144708  53890.02487527
  74422.73270165  74085.19154873  74998.39291775  73312.53646335
  49772.86053567  49757.22279388  51736.29949763  50726.10285189
  44538.50990209  44679.59527494  44547.60409646  44235.52143513
  58982.58328401  62299.19484111  57746.86094103  61009.60145961
  52981.76817947  52571.87907461  52404.1005834   52570.62876061
  73115.11252678  72376.83592367  72293.71430012  72480.50887102
  49793.87145852  49860.5655363   50618.35612265  50632.47742934
  44181.56905232  44891.25703236  44073.28822634  44140.76149013
  60088.39978476  57203.44902268  57903.84664015  61095.11930161
  52279.03744521  52410.21814626  52088.22366068  53718.96249013
  72197.92698383  75010.93800844  71441.25359586  73590.96081301
  50963.47748044  49539.804481    50182.63353228  50752.13908735
  44320.88297421  43709.25927473  44477.14447492  44289.05364334
  60838.36637624  58077.62206523  57708.73753487  60135.51958178
  53118.72524841  52254.68480238  52155.49826752  52407.54631065
  70838.92842872  71971.45826088  71689.4914716   71979.81982651
  49731.34011133  50123.6209325   50451.65673868  50146.1109512
  98953.17643384 141880.75546795  92714.34526299  60443.63964678
 113175.36801107  59904.4793137   70445.5058488  114291.72459559
  68513.96759702 130341.81615942]
2025-06-24 21:23:58 INFO Expected Optimum FE: -5000
2025-06-24 21:23:58 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 21:23:58 ERROR Can not run the algorithm
2025-06-24 21:23:58 INFO Run function 18 complete. FEHistory len: 500, AOCC: 0.0000
2025-06-24 21:23:58 INFO FeHistory: [120464.97867191 181539.1840496  123866.43020312 208188.21027622
 153881.50774167 174395.78220446 210428.12586555 239437.99271142
 137422.93276434 177602.53858039 153489.9499939  164233.72868305
 203218.46819109 209105.83803751 154891.07320881 178279.77887195
 118198.56080761 111738.98817073 147318.17683246 157049.66085028
 121333.48910838 106323.56528453 118551.6287194  145027.56836284
 217860.49129307 195298.9940194  178810.41928481 120316.59581079
 168938.0140106  169331.50088969 247352.43241913 146856.15089922
 128548.15074357 151019.72941646 205899.74084392 138276.52196908
 177057.61321484 181596.97622943 205601.22500181 183695.37239664
 164552.1945678  166653.5332266  147264.95138242 216407.52711418
 127061.34463034 138409.48678013 128496.48541741 106282.22307767
 127515.93627273 178774.04527834 134203.41423011 189114.24464479
 180593.61769367 175683.86888787 202239.54362083 189785.02150874
 202344.01193784 173135.9652381  140022.3772842  125736.81467903
 207106.70009082 236459.27889214 182223.79557095 136757.07721268
 132523.17644681 104102.06126199 158919.89213508 185136.90417842
 122859.50679981  92508.76795063 118695.7819217  199478.00788453
 168107.21955157 182065.13062389 146094.16585812 141934.29714585
 231347.33169134 159521.50286793 162854.95345686 207027.75358755
 131808.5049361  188240.60522391 170868.42620338 101331.96126534
 149549.57232329  99074.11534963 193586.67044363 113277.2672532
 160590.81652155 109984.68162861 131534.97358605 161705.25748736
 192457.28608453 192753.49948565 214590.18771351 238754.97067178
 169515.41419444 141016.80623408 175884.81552695 146191.95051466
 160209.02914166 165800.51658184 157010.89964978 169054.18532722
 126424.83350261 156972.07174835  84931.20619657 145208.3818315
 120233.17998353 112234.39153038 169930.01996163 155280.95072505
 313367.0239576  128567.7191911  151959.41726006 159644.28864651
 113669.13420657 151223.91685761 160703.16294574 135960.12963414
 228323.15482006 139025.77865702 202724.47618674 161369.85727314
 103632.88891537  97666.39099767  92000.12475461 147864.12223403
 127000.2322629  106562.57044369 168635.60604416 140161.20295498
 216381.33063688 213561.07841921 189444.7856466  148917.3559615
 126457.64820852 136904.51753263 119997.54703756 121748.25622484
 203383.65289277 115581.18417281 186403.00630405 146439.75230031
 100244.74919648  80135.70538407 174037.76310438  64686.23664856
 145715.74131703 125065.23237339 171661.92510859 158989.59866067
 176582.4978259  192402.08813209 192904.60293831 151671.87307012
 166437.30638763  86031.51028562 136462.80474927 103246.85048366
 126991.76419028 123447.58003061 259597.37768101 218106.4292802
 114147.36556683  90572.71840175  75045.2268693   75888.84570049
 141065.31175821 177425.37496935 138894.42909579 124947.25676573
 173969.34854633 198934.30434577 165718.72012445 142579.97823354
 131429.88944373 129204.57372095 142923.39353223 116197.87171318
  85881.13437843 109200.44133588 341747.29841164 154411.59677475
  94923.37398973  68680.3526059   94827.9032618  114189.20033525
 111078.24195811 158007.91595187 134250.20900049 119967.91194295
 144305.81328697 167777.12380981 125764.08908212 175339.58606903
 202758.30047644  98769.91512546 153739.20515807 125501.18729595
  83800.97992481 107951.94953708 210710.74136288 166008.25487036
  84414.00431963  78259.77679654 123536.78116285 149069.86353547
 101675.12004961 157812.8184168   66175.1774045  144321.37561307
 144930.32360692 165230.61288725 195952.93004462 199003.26766979
 109416.21961168 102645.69138982 121498.27629715 123692.03743374
  98247.49890459 179240.67004012 170740.53127176 111821.96293346
  70932.73329399 111266.01338711  64201.61307904  90280.80910302
 119775.31213587 127919.70522761 132052.5025664  115731.229147
 173846.22212278 140308.80415297 122605.24334599 151647.6830333
 110752.85279858 102116.71031737 132700.28775074 118579.3275606
  99655.87306966 105680.5792877  151389.70321699 199428.01584152
  77317.47159729  73387.86258012  71501.76734382  83507.62307848
  88276.46462925 106385.47058699 118370.66571991  98631.0855734
 207675.34737595 117530.62910195 191451.70838095 150911.28448274
 128722.75650793 110153.48523898 146810.95268309 189712.54538039
 134971.42586659 180136.66006832 111403.59780938 125723.2545753
 111790.02401441 153725.34421136 165868.49380761  95959.12479688
 135282.92976194 132871.07856815 123079.80136876  79520.62222224
 181398.1802926  163611.45991054 124547.31035844 210445.65674945
 124040.19212641 101319.09930192  83262.32779188  98674.44064044
 141652.2318265   79633.8991126  102023.11569966 117004.29912563
  66522.86619755  93290.93619122 138675.23855836  82705.24651352
  70636.95362513 111661.18236124  75008.62669253 110241.75499168
 181184.92413406 132229.11497114 160250.57656134 164632.69520579
  93383.58566979  96597.45888297  85006.21463678 112724.47540907
  96896.47280868 122080.35641541 104893.11236268 159526.32541273
  72387.7622887   78120.1398855  113167.87959624  72079.68149349
 124347.22826337  72275.3188721  125322.42868193 107900.76571456
 209774.7936594  140166.76833532 212202.01151668 153327.05340507
 106920.91945569  92357.05320639  95483.51692124 126926.27958966
 116039.50613123 172842.75755208 110727.16475063 195722.55799692
  74818.77047212 106287.93232814  76413.65789279  99388.19351123
  64547.84593205 112488.98999965 115079.94439278  99457.05211337
 164943.68028841 162753.50591675 138271.74795034 215954.11147577
  95837.80142452 120645.13578304 126963.87938338 102954.73837154
  80932.3610747  167934.09078711 106557.38032258 137772.34552691
 101050.56221174  63460.40782058  59998.05554281  86589.3313721
  68007.10874932  86422.12120696  80887.62447563 104088.83725964
 142417.71562579 159632.26563449 123749.65422119 223591.45316863
  73814.49639391 129474.29429736 120401.81500813 111933.62877452
 124166.8584728  115096.57911561 123050.32387205 167429.0376781
 111924.93959773  68536.60450645  73598.56320051 105844.01003043
  73883.44745289  71407.41570139 110123.54247286  96010.90020177
 173755.70060328 107624.669974   234842.02548484 127265.63200095
  84476.77265899 106584.1968305  108186.59941846  93786.57891455
 127741.68452681 186156.13710784 169526.94132425 151519.70061162
  87074.49223346  88702.74532412  67694.77974697  90773.89599804
 163046.94432194  88031.4640222  171669.30289162  83546.71643925
 139789.90512768 167605.6541361  200734.45511949 166984.70624562
 105753.83723429  96901.24166175 145270.98606345 128482.60758004
 144110.89134568 223714.8960693   95720.11445352 206581.64118717
  69781.51710282  81630.98027167  83709.93964979  70646.23389722
  97799.16451582  78300.21646255 102832.94224311  96420.16084275
 215901.25230902 126526.41659436 157038.62311383 142821.10167942
  93886.46820668 115169.34076137  88891.089562   108177.89968318
 199710.29378131 128635.09597156 147697.7300064  141875.24732181
  90342.91177476  80747.19129124  90513.95371083  82094.74325372
  87563.49470726 122301.37493639  85203.25116744 107159.76316902
 158397.45875439 105016.66333959 133502.62060704 160464.14095511
 117678.87683443  85041.61681375 140326.07351098 110375.29129768
 204172.86181705 168145.87197316 107474.25867462 122616.59522166
 114612.97829169  98644.55465452  68781.37401634 102399.63526679
 111759.23544349  87936.21752684  84869.4736415   84046.24517995
 124670.59109341 106329.01419336 124063.74148292 134187.99581413
 165008.13821265  98203.26281474  83331.97786776  80076.11233279
 225296.13976731 125143.89902372 167608.79545257 119839.34282074
  71437.81095498  93561.7369139   91260.30408897 100234.07133076
 126349.31499734  92213.01352995  81368.2851402   86956.66943261
 151231.0257793  127099.85701603 144909.21847802 139747.76697708
 151269.97600304 111845.30197882  99890.38586161 132407.45432216
 203625.56243658 167959.12708417  91527.620143   155218.98941622
  78822.69271109  55330.70212728  73352.35677309 122763.2796077
  77917.26859289 116671.12245447  79061.79501446 108872.47805116
 150604.34545104 125548.24446048 126720.49623668 145729.38060839
 132623.83759349 150546.61896493 146876.05527912 103730.7396959 ]
2025-06-24 21:23:58 INFO Expected Optimum FE: -5000
2025-06-24 21:23:58 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-24 21:23:58 ERROR Can not run the algorithm
2025-06-24 21:23:59 INFO Run function 19 complete. FEHistory len: 500, AOCC: 0.0000
2025-06-24 21:23:59 INFO FeHistory: [135007.48988415 175193.52034075 259535.01477981 153688.45177578
 233239.1791618  282117.51087153 213749.54606546 288963.71605334
 152249.0325862  152613.32303026 179517.75853743 176750.0810081
 290856.88044276 218955.95170004 160790.89569509 221223.76482642
 168116.53160077 118701.97510646 161516.15811979 171462.3520102
  94360.21629669 169966.04549845 194134.69053922 146223.35837288
 163167.37175833 104724.66897789 113236.1376256  168418.33386824
  99881.95100698 178043.86491734 158207.00348093 124889.3921536
 247399.66892242 136865.94242665  85046.72893836 145097.89993697
 175278.50567916 240095.82682518 210504.17985558 136522.73424041
 145023.39778612 149582.35094836 120528.07745181 243514.76398696
 228298.25119856 294656.05323642 198766.41491781 341754.26340754
 192094.16793164 185757.22073566 209118.59454291 191062.44629521
 185806.94587239 221623.60296663 211625.43213088 249865.80768773
 112203.43734862 181113.18894584 114916.47614493 177258.22309216
 143510.25835576 205941.65656749 222069.48391778 156917.17497603
 245715.88848706 110054.01379649 180234.51513448 195948.59503096
 161497.84015435 154661.66211893 149941.55230877 106328.75079769
 268745.66794563 299694.25267737 140654.61683911 141061.45818882
 111754.99303888 125842.31084206 135273.10772719 169816.72446899
 246695.7150819  217210.19339278 127848.35851456 174923.60113221
 208987.5964763  132574.34126427 217231.17942208 333253.46288932
 107722.33387727 155208.05498954 101838.30595087 134327.92796625
 177941.05342378 136259.10981554 196534.532986   218661.2396132
 181237.99051036 174450.69365072 105577.75333761 219788.56106083
 168646.36925619 133755.1899764   75499.56137261  91728.2230297
 173503.83997466 158294.98328375 315494.95969205 121979.75639866
 138120.34067571 134540.07458425  93167.95839521 147656.10541949
 213020.34043008 171828.90920646 224051.34742854 136403.72797601
 208160.92340906 126471.65756328 165081.1186137  104593.80818199
 109196.3811835  142385.85747159 160279.59965077 179495.32588159
 136619.04271775 203332.03029878 159075.55751821 258791.26603053
  84663.54759569 131364.57714167 134351.49074071 236641.60017672
 190709.09290306 202025.79550667 192098.20234077 222918.91708159
 186333.45234634 192113.87741173 100776.82553765 104188.97293363
 192077.57393867 147415.56191479  95751.61367101 251258.86296685
 269748.04041197  83525.44074498 114413.24832276 161595.10864931
 150031.42186611 158172.07786373 126601.28280062 130705.17184709
  80858.15918821 121854.92396624 199148.59346161  81929.83385311
 267072.9854178  153881.34085868 138481.63468331 183768.80859268
 159316.30057828 207195.39173934 166439.8285936  137341.2918771
 166750.26482783 162371.47070245 141003.41285469 136771.36510345
 205023.00122645 183655.81391952 195785.20345446 196507.64496038
  98403.58887451 134677.20852453 205530.23626916 110884.02681733
 192276.8529319  154370.10656612 125516.28758158 170081.8315781
 144480.03647814 103575.53171422 101251.01030858 120308.02401719
 183919.13629486 162433.44402745 206546.65082381 146148.01525521
 185049.98297076 177547.24019888  95534.24491293 166848.84364376
 171970.41616697 217668.8667844  114437.9445955  222488.58249352
 194694.50834976 223949.10564789 113937.16037093 146997.56120266
 132424.37324768 133856.97103549  88758.88105488 138911.60243443
 176860.52658361 129475.48498027 131643.39752121 178513.58498009
 243222.44944657 225601.88378175 109580.11760896 160533.15315478
 156592.6759462  171663.93222801  94752.42359199 254120.01504814
 153126.93790646 263376.22415492 174278.488624   127124.03417357
  97936.71101541 122265.73292355 124165.1692364  119285.00077868
 162983.62081173 123965.51009631 167114.96744926 159376.66731184
 180754.66072691 124568.29510621  87294.41452947  89755.9956958
 117056.89124744 136329.55077733 128798.19727422 129912.24646789
 194160.59979483 255253.96002184 231210.46147944 102166.76036693
 118126.37932609  91313.16371499 135507.81456689  98898.2608736
 203080.7310151  176785.51636532 187751.09303953 159812.18302781
 134066.38223608 120933.12098073 180713.88156843 101154.13517563
 119837.58673554 210844.86146988 140639.83974856 129867.89014346
 202826.02827325 163666.20100957 217812.84789225 151032.96491306
  90718.56229681 194817.94123763 144442.53016913  95010.87992161
 179865.80057725 180204.62212228 168219.75055687 140745.21557255
 174933.76996762 177561.49327314 197015.2047417  194921.86208135
  99973.5517344  213925.35154845 128081.9847276  135625.61073706
 165718.58832319 206449.25152486 200054.66930081  90987.9836158
 138597.2601467  136952.94330504 169950.72872806 107022.38886925
 166251.81717995 176371.90605561 291508.70352219 119342.28287748
  64045.5916415  110004.42088628 133762.90862396 101803.96837935
 136095.3355871  101320.18645707 173073.92512262 111792.76633362
 232974.39324529 114997.78427501 182206.25737527 126115.7742593
 134645.56289553 157060.61976808 158938.14221675  95158.31205207
 146083.67447817 110884.12526271 168706.66020663 169522.14426666
 172889.6065149  126910.42761716 137497.91854294 112044.90157433
  74339.44973067 161528.73309041 120285.7740273  161227.40881182
 190192.47244285 171772.57096877 157629.08270655 152878.87461614
 121253.22320176 102226.16610602 116064.65377838 155660.43445264
 133253.12930304 173165.77047525  66350.01062648 134137.13478931
 151563.61524789 171292.18193598 154717.38891833 152022.66232785
 150642.8452141  112783.49335047 117209.10690526 149605.07868414
 110763.88780254 148014.6382212  171088.38502106 148732.1981587
  98483.95877228 103970.5053785  112731.12412296 196764.76441031
 180116.84035373  68577.54583344 242607.16621399  90995.54222951
 149938.08431196 171794.51058235 131739.59106679 156097.82934603
 134797.45236333 115213.37714591  64575.51249585 103659.29285369
 164100.30264534 174739.82446704 203129.19423511 166189.32636009
 128454.71577772 162528.25499989  72158.77111016 202372.12500986
 149823.37531968 160876.67051638 121420.52355035 159390.10829923
 135649.81880872 139350.41593214 121598.87589273 125308.97953465
  92468.42339196  97132.36965455 165236.36529621 167759.42731651
 117173.1060634  152185.44268065 106256.07758995  72380.89012572
  88033.60885014  88781.99558979 101756.6379427  205964.86938015
 159383.05500736 176176.66474322 184815.25076118 140855.89991462
 196989.46535703 173035.85036193 134528.56727947 205596.9389339
 131012.63470707  94255.43506761 134145.66654462  53670.20704512
 116768.5779021  157212.74567158 127458.94071773 163589.60996982
 151039.06007447 132508.40915516  94038.41409036 122987.46579029
 138750.57021607 114601.15652501 144686.52657417 120714.04474814
  96335.70493676 119241.7334608  132884.55604862 202632.9643174
 170475.72305659 115038.37234662 133923.31507738  98392.27446483
 112891.73930779 202419.05088983  85665.25081431 136972.76734077
 138030.88949084 142373.35748211 127622.49158597 111386.24254867
 144541.62505186 132658.7510534  150427.44958375 145360.09249168
 151147.28183538 179624.89319878 128222.66580289 117715.74273362
 148583.02126391  84597.57910222 134236.32191471  90420.20342869
 166382.53047444  69040.93737955 156153.24011708 150948.79770778
 160163.44592973 137037.11377842 116175.31497504  84099.91122128
 137260.51022049  95035.34001141  99304.67535458  98690.38541894
 154098.40421099 152510.92780863 172638.55171814 126397.15674803
 103032.41931389  96148.94536065  98576.64176455 116784.84652626
 137609.5186198  252800.02723947 149302.68433646 131038.58629724
 169587.34079389 126380.50025086  81542.14560964 156216.80931258
 119889.19577216 146527.58573066 105624.87841295 115843.61077252
 162997.87170579 122036.42614188 168962.1664268  127288.94399411
 187961.71232207 159249.32635753 162844.37066725  88589.31171162
 203226.98176617 168294.10224808 140706.76759488  94515.67909428
 183247.66881945 123657.9149093  124245.2179803   69336.80880119
 115724.63736676 158183.55150844  84547.90855475 115391.97015564
  97660.31413325 113373.49134919 130527.6284567  154626.00687397
 124324.5990137  202004.10667985 106925.13454443 151244.17462987
 135954.79370941 176027.06836336 140557.72975271 235231.56127898]
2025-06-24 21:23:59 INFO Expected Optimum FE: -5000
2025-06-24 21:23:59 INFO Unimodal AOCC mean: nan
2025-06-24 21:23:59 INFO Multimodal (single component) AOCC mean: nan
2025-06-24 21:23:59 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 21:23:59 INFO AOCC mean: 0.0000
2025-06-24 21:23:59 INFO Weighed AOCC mean: nan
2025-06-24 21:23:59 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-24 21:24:39 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:24:39 INFO FeHistory: [113062.43971526 143538.72434197 162706.61325019 ...  -4399.13219206
  -4399.13219206  -4399.13219206]
2025-06-24 21:24:39 INFO Expected Optimum FE: -5000
2025-06-24 21:24:39 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 21:24:40 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:24:40 INFO FeHistory: [156317.97010342 143574.69431092  98493.93521604 ...  -4317.9
  -4317.9         -4317.9       ]
2025-06-24 21:24:40 INFO Expected Optimum FE: -5000
2025-06-24 21:24:40 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 21:24:41 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:24:41 INFO FeHistory: [229338.55542843 147296.72633101 153169.06513066 ...  -4470.3993434
  -4470.39935769  -4470.39949398]
2025-06-24 21:24:41 INFO Expected Optimum FE: -5000
2025-06-24 21:24:41 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 21:24:41 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:24:41 INFO FeHistory: [136778.13351397 158089.92468452 146661.33066547 ...  -4317.9
  -4317.9         -4317.9       ]
2025-06-24 21:24:41 INFO Expected Optimum FE: -5000
2025-06-24 21:24:41 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 21:24:42 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:24:42 INFO FeHistory: [157345.8969359  147253.56611781  94326.23612729 ...  -4470.4
  -4470.4         -4470.4       ]
2025-06-24 21:24:42 INFO Expected Optimum FE: -5000
2025-06-24 21:24:42 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 21:25:18 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:25:18 INFO FeHistory: [161159.79913476 154333.06805708 222562.23444167 ...  11986.82156603
  11986.82156603  11986.82156603]
2025-06-24 21:25:18 INFO Expected Optimum FE: -5000
2025-06-24 21:25:19 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-24 21:25:21 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:25:21 INFO FeHistory: [186602.55334645 201670.72876065 145113.00175926 ...  -4317.89999998
  -4317.89999998  -4317.89999997]
2025-06-24 21:25:21 INFO Expected Optimum FE: -5000
2025-06-24 21:25:21 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-24 21:25:22 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0418
2025-06-24 21:25:22 INFO FeHistory: [144519.7540365  154890.98691544 186474.45966728 ...  -4996.18056835
  -4995.22833396  -4991.74387437]
2025-06-24 21:25:22 INFO Expected Optimum FE: -5000
2025-06-24 21:25:22 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-24 21:25:23 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:25:23 INFO FeHistory: [219087.35852619 109158.03489474 173380.3358028  ...   7571.29244167
   7571.29244167   7571.29244167]
2025-06-24 21:25:23 INFO Expected Optimum FE: -5000
2025-06-24 21:25:23 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-24 21:25:24 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.3699
2025-06-24 21:25:24 INFO FeHistory: [169187.96360434 156687.49577264 107470.02718297 ...  -4999.99999998
  -4999.99999999  -4999.99999999]
2025-06-24 21:25:24 INFO Expected Optimum FE: -5000
2025-06-24 21:25:24 INFO Good algorithm:
Algorithm Name: IslandDifferentialEvolution
import numpy as np
import random

# Name: IslandDifferentialEvolution
# Description: Uses an island model with differential evolution on each island to explore multiple basins of attraction.
# Code:
class IslandDifferentialEvolution:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_factor: float = 0.5, migration_interval: int = 500, migration_amount: int = 2):
        """
        Initializes the IslandDifferentialEvolution algorithm.

        Args:
            budget (int): Max function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of islands to use in the island model.
            population_size (int): Population size for each island.
            crossover_rate (float): Crossover rate for differential evolution.
            mutation_factor (float): Mutation factor for differential evolution.
            migration_interval (int): Number of evaluations between migrations.
            migration_amount (int): Number of individuals to migrate.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_factor = mutation_factor
        self.migration_interval = migration_interval
        self.migration_amount = migration_amount

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize islands
        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            self.islands.append({
                'population': population,
                'fitness': np.full(self.population_size, float('inf')),
                'best_solution': None,
                'best_fitness': float('inf')
            })

    def differential_evolution(self, island, objective_function):
        """
        Performs differential evolution on a single island.

        Args:
            island (dict): Island data (population, fitness, best solution, best fitness).
            objective_function (callable): Objective function to evaluate solutions.
        """
        population = island['population']
        fitness = island['fitness']

        for i in range(self.population_size):
            # Choose three distinct individuals from the population
            idxs = list(range(self.population_size))
            idxs.remove(i)
            a, b, c = random.sample(idxs, 3)

            # Mutation
            mutant = population[a] + self.mutation_factor * (population[b] - population[c])
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant[j]

            # Evaluation
            trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness[i]:
                population[i] = trial_vector
                fitness[i] = trial_fitness

                # Update island best
                if trial_fitness < island['best_fitness']:
                    island['best_fitness'] = trial_fitness
                    island['best_solution'] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


    def migrate(self):
        """
        Migrates individuals between islands. The best individuals from one island move
        to replace the worst individuals of other islands.
        """
        # Identify best individuals on each island
        best_individuals = []
        for island in self.islands:
            best_individuals.append(island['best_solution'])

        # Identify worst individuals on each island
        worst_indices = []
        for island in self.islands:
            worst_indices.append(np.argsort(island['fitness'])[-self.migration_amount:]) # Index of the worst element in each island

        # Perform migration: the worst individuals are replaced by the best individuals from other random islands.
        for i in range(self.num_islands):
            for j in range(self.migration_amount):
                # Choose a different island to migrate from.
                donor_island_index = random.choice([k for k in range(self.num_islands) if k != i])

                # Replace worst individual of current island with the donor's best
                self.islands[i]['population'][worst_indices[i][j]] = best_individuals[donor_island_index]
                # Mark the replaced individual's fitness as "not evaluated"
                self.islands[i]['fitness'][worst_indices[i][j]] = float('inf') # to force fitness re-evaluation


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the objective function using the island model differential evolution.

        Args:
            objective_function (callable): Accepts a 2D NumPy array `X` (shape `(N, dim)`) and returns a 1D NumPy array of `N` fitness values.
            acceptance_threshold (float): Threshold for accepting a solution as optimal.

        Returns:
            tuple: (best_solution_1D_numpy_array, best_fitness_scalar, optimization_info_dict)
        """
        self.eval_count = 0
        if self.dim > 0:
             self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        else:
             self.best_solution_overall = np.array([])
        self.best_fitness_overall = float('inf')


        # Initial evaluation of the populations
        for island in self.islands:
            island['fitness'] = objective_function(island['population'])
            self.eval_count += self.population_size  # population_size evaluations per island.
            best_index = np.argmin(island['fitness'])
            island['best_fitness'] = island['fitness'][best_index]
            island['best_solution'] = island['population'][best_index]

            if island['best_fitness'] < self.best_fitness_overall:
                self.best_fitness_overall = island['best_fitness']
                self.best_solution_overall = island['best_solution']

        while self.eval_count < self.budget:
            for island in self.islands:
                self.differential_evolution(island, objective_function)

            if self.eval_count // self.migration_interval > (self.eval_count - self.population_size * self.num_islands) // self.migration_interval: # after each migration interval
               self.migrate()


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
2025-06-24 21:25:24 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-24 21:25:58 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:25:58 INFO FeHistory: [164568.03020766 108210.08337353 170032.0715007  ...   7071.55903563
  72556.11325763   7071.55903563]
2025-06-24 21:25:58 INFO Expected Optimum FE: -5000
2025-06-24 21:25:58 INFO Unimodal AOCC mean: nan
2025-06-24 21:25:58 INFO Multimodal (single component) AOCC mean: nan
2025-06-24 21:25:58 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 21:25:58 INFO AOCC mean: 0.0000
2025-06-24 21:25:58 INFO Weighed AOCC mean: nan
2025-06-24 21:25:59 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-24 21:26:03 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.1746
2025-06-24 21:26:03 INFO FeHistory: [232346.82757858 117425.90563403 221285.38694024 ...  -4999.99766466
  -4999.99719728  -4999.99895768]
2025-06-24 21:26:03 INFO Expected Optimum FE: -5000
2025-06-24 21:26:03 INFO Good algorithm:
Algorithm Name: IslandModelDifferentialEvolution
import numpy as np
import random


# Name: IslandModelDifferentialEvolution
# Description: Employs an island model with differential evolution and migration to aggressively explore multiple basins.
# Code:
class IslandModelDifferentialEvolution:
    """
    Implements an island model with differential evolution (DE) and migration
    to explore multimodal landscapes aggressively.  Each island runs a DE
    algorithm, and periodically individuals migrate between islands to
    promote diversity and escape local optima.
    """

    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 500, migration_size: int = 2):
        """
        Initializes the IslandModelDifferentialEvolution algorithm.

        Args:
            budget (int): The maximum number of function evaluations.
            dim (int): The dimensionality of the problem.
            lower_bounds (list[float]): The lower bounds for each dimension.
            upper_bounds (list[float]): The upper bounds for each dimension.
            num_islands (int): The number of islands in the model.
            population_size (int): The population size of each island.
            crossover_rate (float): The crossover rate for the DE algorithm.
            mutation_rate (float): The mutation rate for the DE algorithm.
            migration_interval (int): The number of evaluations between migrations.
            migration_size (int): The number of individuals to migrate during each migration event.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize island populations
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]

        # Initialize island fitnesses
        self.fitnesses = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]

    def differential_evolution(self, population: np.ndarray, fitnesses: np.ndarray,
                               objective_function: callable) -> tuple[np.ndarray, np.ndarray]:
        """
        Performs one generation of differential evolution.

        Args:
            population (np.ndarray): The population to evolve.
            fitnesses (np.ndarray): The fitnesses of the population.
            objective_function (callable): The objective function to minimize.

        Returns:
            tuple[np.ndarray, np.ndarray]: The evolved population and its fitnesses.
        """
        new_population = np.copy(population)
        new_fitnesses = np.copy(fitnesses)

        for i in range(self.population_size):
            # Selection: Choose three distinct individuals
            idxs = list(range(self.population_size))
            idxs.remove(i)
            a, b, c = random.sample(idxs, 3)

            # Mutation: Create a mutant vector
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)

            # Crossover: Create a trial vector
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation: Evaluate the trial vector
            trial_vector_reshaped = trial_vector.reshape(1, -1)  # Reshape for single evaluation
            trial_fitness = objective_function(trial_vector_reshaped)[0]  # Extract scalar fitness
            self.eval_count += 1

            # Selection: Replace if the trial vector is better
            if trial_fitness < fitnesses[i]:
                new_population[i] = trial_vector
                new_fitnesses[i] = trial_fitness

                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector
        return new_population, new_fitnesses

    def migrate(self):
        """
        Migrates individuals between islands.  Chooses the worst individuals on
        each island and replaces them with random individuals from other islands.
        """

        for i in range(self.num_islands):
            # Identify the worst individuals on the current island
            worst_indices = np.argsort(self.fitnesses[i])[-self.migration_size:]

            # Choose a random source island (excluding the current island)
            source_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Replace the worst individuals with individuals from the source island
            random_indices = np.random.choice(self.population_size, self.migration_size, replace=False)
            self.populations[i][worst_indices] = self.populations[source_island][random_indices]

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the objective function using an island model with differential evolution.

        Args:
            objective_function (callable): The objective function to minimize.  Must take
                                           a 2D NumPy array as input and return a 1D NumPy array
                                           of fitness values.
            acceptance_threshold (float): The acceptance threshold.  Not strictly needed for this algorithm,
                                           but included for API consistency.

        Returns:
            tuple: A tuple containing the best solution, its fitness, and optimization information.
        """

        self.eval_count = 0  # Reset for this run
        if self.dim > 0:
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        else:
            self.best_solution_overall = np.array([])
        self.best_fitness_overall = float('inf')

        # Initialize fitnesses of each island's initial population
        for i in range(self.num_islands):
            self.fitnesses[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size

            best_index = np.argmin(self.fitnesses[i])
            if self.fitnesses[i][best_index] < self.best_fitness_overall:
                self.best_fitness_overall = self.fitnesses[i][best_index]
                self.best_solution_overall = self.populations[i][best_index]

        generation = 0
        while self.eval_count < self.budget:
            generation += 1

            # Evolve each island independently
            for i in range(self.num_islands):
                self.populations[i], self.fitnesses[i] = self.differential_evolution(
                    self.populations[i], self.fitnesses[i], objective_function
                )
                best_index = np.argmin(self.fitnesses[i])
                if self.fitnesses[i][best_index] < self.best_fitness_overall:
                    self.best_fitness_overall = self.fitnesses[i][best_index]
                    self.best_solution_overall = self.populations[i][best_index]

            # Migrate individuals between islands periodically
            if self.eval_count // self.population_size > 0 and self.eval_count // self.population_size % (self.migration_interval // self.population_size) == 0:
                self.migrate()


        if self.best_solution_overall is None and self.dim > 0:  # Fallback
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
2025-06-24 21:26:03 INFO Unimodal AOCC mean: nan
2025-06-24 21:26:03 INFO Multimodal (single component) AOCC mean: nan
2025-06-24 21:26:03 INFO Multimodal (multiple components) AOCC mean: 0.0582
2025-06-24 21:26:03 INFO AOCC mean: 0.0582
2025-06-24 21:26:03 INFO Weighed AOCC mean: nan
2025-06-24 21:26:04 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-24 21:26:05 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:26:05 INFO FeHistory: [208626.0576459  185572.47439508 199064.47369287 ...  -2976.9106202
  -3222.37998451  -3564.87654876]
2025-06-24 21:26:05 INFO Expected Optimum FE: -5000
2025-06-24 21:26:05 INFO Unimodal AOCC mean: nan
2025-06-24 21:26:05 INFO Multimodal (single component) AOCC mean: nan
2025-06-24 21:26:05 INFO Multimodal (multiple components) AOCC mean: 0.0139
2025-06-24 21:26:05 INFO AOCC mean: 0.0139
2025-06-24 21:26:05 INFO Weighed AOCC mean: nan
2025-06-24 21:26:05 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-24 21:26:05 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:26:05 INFO FeHistory: [161293.27376522 165536.29973827 184394.10303548 ...   7931.6527995
   7931.6527995    7931.6527995 ]
2025-06-24 21:26:05 INFO Expected Optimum FE: -5000
2025-06-24 21:26:05 INFO Unimodal AOCC mean: nan
2025-06-24 21:26:05 INFO Multimodal (single component) AOCC mean: nan
2025-06-24 21:26:05 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 21:26:05 INFO AOCC mean: 0.0000
2025-06-24 21:26:05 INFO Weighed AOCC mean: nan
2025-06-24 21:26:06 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-24 21:26:07 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.1141
2025-06-24 21:26:07 INFO FeHistory: [152829.95388184  93070.95145489 158380.64418634 ...  -4999.97404649
  -4999.98121737  -4999.98839503]
2025-06-24 21:26:07 INFO Expected Optimum FE: -5000
2025-06-24 21:26:07 INFO Good algorithm:
Algorithm Name: IslandDifferentialEvolution
import numpy as np
import random

# Name: IslandDifferentialEvolution
# Description: Uses an island model with differential evolution on each island to explore multiple basins of attraction.
# Code:
class IslandDifferentialEvolution:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_factor: float = 0.5, migration_interval: int = 500, migration_amount: int = 2):
        """
        Initializes the IslandDifferentialEvolution algorithm.

        Args:
            budget (int): Max function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of islands to use in the island model.
            population_size (int): Population size for each island.
            crossover_rate (float): Crossover rate for differential evolution.
            mutation_factor (float): Mutation factor for differential evolution.
            migration_interval (int): Number of evaluations between migrations.
            migration_amount (int): Number of individuals to migrate.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_factor = mutation_factor
        self.migration_interval = migration_interval
        self.migration_amount = migration_amount

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize islands
        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            self.islands.append({
                'population': population,
                'fitness': np.full(self.population_size, float('inf')),
                'best_solution': None,
                'best_fitness': float('inf')
            })

    def differential_evolution(self, island, objective_function):
        """
        Performs differential evolution on a single island.

        Args:
            island (dict): Island data (population, fitness, best solution, best fitness).
            objective_function (callable): Objective function to evaluate solutions.
        """
        population = island['population']
        fitness = island['fitness']

        for i in range(self.population_size):
            # Choose three distinct individuals from the population
            idxs = list(range(self.population_size))
            idxs.remove(i)
            a, b, c = random.sample(idxs, 3)

            # Mutation
            mutant = population[a] + self.mutation_factor * (population[b] - population[c])
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant[j]

            # Evaluation
            trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness[i]:
                population[i] = trial_vector
                fitness[i] = trial_fitness

                # Update island best
                if trial_fitness < island['best_fitness']:
                    island['best_fitness'] = trial_fitness
                    island['best_solution'] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


    def migrate(self):
        """
        Migrates individuals between islands. The best individuals from one island move
        to replace the worst individuals of other islands.
        """
        # Identify best individuals on each island
        best_individuals = []
        for island in self.islands:
            best_individuals.append(island['best_solution'])

        # Identify worst individuals on each island
        worst_indices = []
        for island in self.islands:
            worst_indices.append(np.argsort(island['fitness'])[-self.migration_amount:]) # Index of the worst element in each island

        # Perform migration: the worst individuals are replaced by the best individuals from other random islands.
        for i in range(self.num_islands):
            for j in range(self.migration_amount):
                # Choose a different island to migrate from.
                donor_island_index = random.choice([k for k in range(self.num_islands) if k != i])

                # Replace worst individual of current island with the donor's best
                self.islands[i]['population'][worst_indices[i][j]] = best_individuals[donor_island_index]
                # Mark the replaced individual's fitness as "not evaluated"
                self.islands[i]['fitness'][worst_indices[i][j]] = float('inf') # to force fitness re-evaluation


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the objective function using the island model differential evolution.

        Args:
            objective_function (callable): Accepts a 2D NumPy array `X` (shape `(N, dim)`) and returns a 1D NumPy array of `N` fitness values.
            acceptance_threshold (float): Threshold for accepting a solution as optimal.

        Returns:
            tuple: (best_solution_1D_numpy_array, best_fitness_scalar, optimization_info_dict)
        """
        self.eval_count = 0
        if self.dim > 0:
             self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        else:
             self.best_solution_overall = np.array([])
        self.best_fitness_overall = float('inf')


        # Initial evaluation of the populations
        for island in self.islands:
            island['fitness'] = objective_function(island['population'])
            self.eval_count += self.population_size  # population_size evaluations per island.
            best_index = np.argmin(island['fitness'])
            island['best_fitness'] = island['fitness'][best_index]
            island['best_solution'] = island['population'][best_index]

            if island['best_fitness'] < self.best_fitness_overall:
                self.best_fitness_overall = island['best_fitness']
                self.best_solution_overall = island['best_solution']

        while self.eval_count < self.budget:
            for island in self.islands:
                self.differential_evolution(island, objective_function)

            if self.eval_count // self.migration_interval > (self.eval_count - self.population_size * self.num_islands) // self.migration_interval: # after each migration interval
               self.migrate()


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
2025-06-24 21:26:07 INFO Unimodal AOCC mean: nan
2025-06-24 21:26:07 INFO Multimodal (single component) AOCC mean: nan
2025-06-24 21:26:07 INFO Multimodal (multiple components) AOCC mean: 0.1613
2025-06-24 21:26:07 INFO AOCC mean: 0.1613
2025-06-24 21:26:07 INFO Weighed AOCC mean: nan
2025-06-24 21:26:07 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-24 21:26:43 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.6851
2025-06-24 21:26:43 INFO FeHistory: [147505.99953533 125562.1482693  132202.27534131 ...  -4399.9
  -4399.9         -4399.9       ]
2025-06-24 21:26:43 INFO Expected Optimum FE: -5000
2025-06-24 21:26:43 INFO Good algorithm:
Algorithm Name: IslandBasedDifferentialEvolution
import numpy as np
import random

# Name: IslandBasedDifferentialEvolution
# Description: Uses an island model with differential evolution to explore multiple basins.
# Code:
class IslandBasedDifferentialEvolution:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float], num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7, mutation_factor: float = 0.5, migration_interval: int = 500):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_factor = mutation_factor
        self.migration_interval = migration_interval

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            self.islands.append({
                'population': population,
                'fitness': np.full(self.population_size, float('inf')),
                'best_solution': None,
                'best_fitness': float('inf')
            })

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0

        for island in self.islands:
            island['population'] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            island['fitness'] = np.full(self.population_size, float('inf'))
            island['best_solution'] = None
            island['best_fitness'] = float('inf')

        self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        self.best_fitness_overall = float('inf')

        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.evolve_island(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate_individuals()

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def evolve_island(self, island_index: int, objective_function: callable):
        island = self.islands[island_index]
        population = island['population']
        fitness = island['fitness']

        # Evaluate initial population
        unevaluated_mask = np.isinf(fitness)
        if np.any(unevaluated_mask):
            unevaluated_individuals = population[unevaluated_mask]
            new_fitness_values = objective_function(unevaluated_individuals)
            self.eval_count += len(unevaluated_individuals)
            fitness[unevaluated_mask] = new_fitness_values

        island['fitness'] = fitness  # Update island's fitness array

        for i in range(self.population_size):
            # DE mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)

            mutant = population[a] + self.mutation_factor * (population[b] - population[c])

            # Boundary handling
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

            # Crossover
            trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])

            # Evaluate trial vector
            trial_fitness = objective_function(np.array([trial_vector]))[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness[i]:
                population[i] = trial_vector
                fitness[i] = trial_fitness

                # Update island best
                if trial_fitness < island['best_fitness']:
                    island['best_fitness'] = trial_fitness
                    island['best_solution'] = trial_vector

                    # Update global best
                    if trial_fitness < self.best_fitness_overall:
                        self.best_fitness_overall = trial_fitness
                        self.best_solution_overall = trial_vector

        island['population'] = population  # Update island's population
        island['fitness'] = fitness      # Update island's fitness



    def migrate_individuals(self):
        # Select a random individual from each island
        migrants = []
        for island in self.islands:
            index = random.randint(0, self.population_size - 1)
            migrants.append(island['population'][index].copy())  # Important: copy to avoid modifying the original

        # Replace a random individual on each island with a migrant from another island
        for i in range(self.num_islands):
            receiving_island = self.islands[i]
            donor_island_index = (i + 1) % self.num_islands  # Choose the next island as the donor

            index_to_replace = random.randint(0, self.population_size - 1)
            receiving_island['population'][index_to_replace] = migrants[donor_island_index]
            receiving_island['fitness'][index_to_replace] = float('inf') # Mark as unevaluated


2025-06-24 21:26:43 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 21:26:49 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:26:49 INFO FeHistory: [153531.68523118 129769.30229042  85138.90032535 ...  -4399.9
  -4399.9         -4399.9       ]
2025-06-24 21:26:49 INFO Expected Optimum FE: -5000
2025-06-24 21:26:49 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 21:26:50 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.1325
2025-06-24 21:26:50 INFO FeHistory: [141983.4895574  124866.5517406  145004.89857632 ...  -4317.9
  -4317.9         -4317.9       ]
2025-06-24 21:26:50 INFO Expected Optimum FE: -5000
2025-06-24 21:26:50 INFO Good algorithm:
Algorithm Name: IslandDifferentialEvolution
import numpy as np
import random

# Name: IslandDifferentialEvolution
# Description: Uses an island model with differential evolution and random immigrants to explore multimodal landscapes.
# Code:
class IslandDifferentialEvolution:
    """
    Implements an island model differential evolution algorithm for global optimization.
    """
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 5000, migration_size: int = 2):
        """
        Initializes the IslandDifferentialEvolution algorithm.

        Args:
            budget: Total function evaluation budget.
            dim: Dimensionality of the problem.
            lower_bounds: List of lower bounds for each dimension.
            upper_bounds: List of upper bounds for each dimension.
            num_islands: Number of independent islands (sub-populations).
            population_size: Size of the population on each island.
            crossover_rate: Crossover rate for differential evolution.
            mutation_rate: Mutation rate for differential evolution.
            migration_interval: Number of evaluations before migration occurs.
            migration_size: Number of individuals to migrate between islands.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size

        self.populations = []
        self.fitness_values = []
        self.best_solutions = []
        self.best_fitnesses = []

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize islands
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            self.populations.append(population)
            self.fitness_values.append(np.full(self.population_size, float('inf')))  # Initialize fitnesses to infinity
            self.best_solutions.append(None)
            self.best_fitnesses.append(float('inf'))


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Performs the optimization process using the island differential evolution algorithm.

        Args:
            objective_function: The function to be minimized.  Takes a 2D NumPy array (N, dim)
                                and returns a 1D NumPy array of N fitness values.
            acceptance_threshold:  Not used in this implementation, kept for consistency with API.

        Returns:
            A tuple containing:
                - The best solution found (1D numpy array).
                - The best fitness value achieved (scalar).
                - A dictionary containing optimization information (number of function evaluations).
        """
        self.eval_count = 0 # Reset for this run
        # Ensure best solution is initialized *before* the main loop

        for island_index in range(self.num_islands):
            if self.dim > 0:
                self.best_solutions[island_index] = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
            else:
                self.best_solutions[island_index] = np.array([])
            self.best_fitnesses[island_index] = float('inf')



        while self.eval_count < self.budget:
            for island_index in range(self.num_islands):
                # Differential Evolution within each island
                for i in range(self.population_size):
                    # Ensure we don't exceed the budget during DE steps.
                    if self.eval_count >= self.budget:
                        break
                    
                    # Mutation
                    indices = list(range(self.population_size))
                    indices.remove(i)
                    a, b, c = random.sample(indices, 3)
                    mutant = self.populations[island_index][a] + self.mutation_rate * (self.populations[island_index][b] - self.populations[island_index][c])
                    mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

                    # Crossover
                    trial = np.copy(self.populations[island_index][i])
                    for j in range(self.dim):
                        if random.random() < self.crossover_rate:
                            trial[j] = mutant[j]
                            
                    # Selection
                    fitness_trial = objective_function(trial.reshape(1, -1))[0]  # Correctly reshape trial and retrieve scalar
                    self.eval_count += 1

                    if fitness_trial < self.fitness_values[island_index][i]:
                        self.populations[island_index][i] = trial
                        self.fitness_values[island_index][i] = fitness_trial
                        
                        if fitness_trial < self.best_fitnesses[island_index]:
                            self.best_fitnesses[island_index] = fitness_trial
                            self.best_solutions[island_index] = trial  # store the vector itself

            # Migration
            if self.eval_count % self.migration_interval == 0 and self.num_islands > 1:
                # Select random islands for migration
                island1_index = random.randint(0, self.num_islands - 1)
                island2_index = random.randint(0, self.num_islands - 1)
                while island2_index == island1_index:
                    island2_index = random.randint(0, self.num_islands - 1)

                # Select individuals to migrate (best from island 1 replaces worst in island 2)
                # Sort individuals in island 2 by fitness value, in descending order
                sorted_indices = np.argsort(self.fitness_values[island2_index])[::-1]  # high to low
                migrant_indices = sorted_indices[:self.migration_size]
                
                for i in range(self.migration_size): # Migration size handled here
                    self.populations[island2_index][migrant_indices[i]] = self.best_solutions[island1_index]
                    self.fitness_values[island2_index][migrant_indices[i]] = self.best_fitnesses[island1_index]  # Synchronize fitness, importantly!

            # Random Immigrants
            if self.eval_count % 1000 == 0:
                for island_index in range(self.num_islands):
                     immigrant = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
                     fitness_immigrant = objective_function(immigrant.reshape(1, -1))[0]
                     self.eval_count += 1

                     worst_index = np.argmax(self.fitness_values[island_index])
                     if fitness_immigrant < self.fitness_values[island_index][worst_index]:
                        self.populations[island_index][worst_index] = immigrant
                        self.fitness_values[island_index][worst_index] = fitness_immigrant

            # Track the overall best solution
            for island_index in range(self.num_islands):
                if self.best_fitnesses[island_index] < self.best_fitness_overall:
                    self.best_fitness_overall = self.best_fitnesses[island_index]
                    self.best_solution_overall = self.best_solutions[island_index]
            if self.eval_count >= self.budget:
                break


        if self.best_solution_overall is None and self.dim > 0 : # Fallback
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }

        return self.best_solution_overall, self.best_fitness_overall, optimization_info
2025-06-24 21:26:50 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 21:26:51 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:26:51 INFO FeHistory: [158997.6614707  153962.22320189 171932.87329359 ...  13078.44649868
  23181.70415318  17969.37617303]
2025-06-24 21:26:51 INFO Expected Optimum FE: -5000
2025-06-24 21:26:51 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 21:26:51 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.4099
2025-06-24 21:26:51 INFO FeHistory: [144085.29931027 104728.74208373 130058.94277192 ...  -5000.
  -5000.          -5000.        ]
2025-06-24 21:26:51 INFO Expected Optimum FE: -5000
2025-06-24 21:26:51 INFO Good algorithm:
Algorithm Name: IslandModelDifferentialEvolution
import numpy as np
import random

# Name: IslandModelDifferentialEvolution
# Description: Island model differential evolution with migration to explore multiple basins aggressively.
# Code:
class IslandModelDifferentialEvolution:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float], num_islands: int = 5, population_size: int = 20, mutation_rate: float = 0.5, crossover_rate: float = 0.7, migration_interval: int = 100, migration_size: int = 2):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = int(num_islands)
        self.population_size = int(population_size)
        self.mutation_rate = float(mutation_rate)
        self.crossover_rate = float(crossover_rate)
        self.migration_interval = int(migration_interval)
        self.migration_size = int(migration_size)
        

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        self.populations = []
        self.fitness_values = []

        # Initialize populations for each island
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            self.populations.append(population)
            self.fitness_values.append(np.full(self.population_size, float('inf')))

        self.island_best_solutions = [None] * self.num_islands
        self.island_best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution(self, population, fitness_values, objective_function):
        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant[j]

            # Selection
            f = objective_function(trial_vector.reshape(1, -1))[0]
            self.eval_count += 1

            if f < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = f
        return population, fitness_values


    def migrate(self):
        # Select migrants from each island
        migrants = []
        for i in range(self.num_islands):
            island_indices = np.argsort(self.fitness_values[i])[:self.migration_size]  # Select best solutions for migration
            migrants.append(self.populations[i][island_indices])

        # Migrate to the next island (circular topology)
        for i in range(self.num_islands):
            target_island = (i + 1) % self.num_islands
            worst_indices = np.argsort(self.fitness_values[target_island])[-self.migration_size:] #Replace worst w/ migrants
            self.populations[target_island][worst_indices] = migrants[i]
            

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0  # Reset for this run
        if self.dim > 0:
          self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        else:
            self.best_solution_overall = np.array([])

        self.best_fitness_overall = float('inf')
          # Reinitialize all the populations and fitnesses
        self.populations = []
        self.fitness_values = []
      
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            self.populations.append(population)
            fitness_values = objective_function(population)
            self.eval_count += self.population_size
            self.fitness_values.append(fitness_values)
            
            
            best_index = np.argmin(fitness_values)
            island_best_fitness = fitness_values[best_index]
            island_best_solution = population[best_index]
            
            
            if island_best_fitness < self.best_fitness_overall:
                  self.best_fitness_overall = island_best_fitness
                  self.best_solution_overall = island_best_solution
            
        self.island_best_solutions = [None] * self.num_islands
        self.island_best_fitnesses = [float('inf')] * self.num_islands


        generation = 0
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.populations[i], self.fitness_values[i] = self.differential_evolution(self.populations[i], self.fitness_values[i], objective_function)
                
                
                best_index = np.argmin(self.fitness_values[i])
                island_best_fitness = self.fitness_values[i][best_index]
                island_best_solution = self.populations[i][best_index]
                
                if island_best_fitness < self.island_best_fitnesses[i]:
                  self.island_best_fitnesses[i] = island_best_fitness
                  self.island_best_solutions[i] = island_best_solution

                if island_best_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = island_best_fitness
                    self.best_solution_overall = island_best_solution


            if generation % self.migration_interval == 0:
                self.migrate()

            generation += 1

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'generations': generation
        }

        return self.best_solution_overall, self.best_fitness_overall, optimization_info
2025-06-24 21:26:51 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 21:27:27 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.3813
2025-06-24 21:27:27 INFO FeHistory: [176586.08828867 207333.27907708 160071.43843541 ...  -4999.99996855
  -4999.99996597  -4999.99992422]
2025-06-24 21:27:27 INFO Expected Optimum FE: -5000
2025-06-24 21:27:27 INFO Good algorithm:
Algorithm Name: IslandBasedDifferentialEvolution
import numpy as np
import random

# Name: IslandBasedDifferentialEvolution
# Description: Uses an island model with differential evolution to explore multiple basins.
# Code:
class IslandBasedDifferentialEvolution:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float], num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7, mutation_factor: float = 0.5, migration_interval: int = 500):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_factor = mutation_factor
        self.migration_interval = migration_interval

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            self.islands.append({
                'population': population,
                'fitness': np.full(self.population_size, float('inf')),
                'best_solution': None,
                'best_fitness': float('inf')
            })

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0

        for island in self.islands:
            island['population'] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            island['fitness'] = np.full(self.population_size, float('inf'))
            island['best_solution'] = None
            island['best_fitness'] = float('inf')

        self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        self.best_fitness_overall = float('inf')

        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.evolve_island(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate_individuals()

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def evolve_island(self, island_index: int, objective_function: callable):
        island = self.islands[island_index]
        population = island['population']
        fitness = island['fitness']

        # Evaluate initial population
        unevaluated_mask = np.isinf(fitness)
        if np.any(unevaluated_mask):
            unevaluated_individuals = population[unevaluated_mask]
            new_fitness_values = objective_function(unevaluated_individuals)
            self.eval_count += len(unevaluated_individuals)
            fitness[unevaluated_mask] = new_fitness_values

        island['fitness'] = fitness  # Update island's fitness array

        for i in range(self.population_size):
            # DE mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)

            mutant = population[a] + self.mutation_factor * (population[b] - population[c])

            # Boundary handling
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

            # Crossover
            trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])

            # Evaluate trial vector
            trial_fitness = objective_function(np.array([trial_vector]))[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness[i]:
                population[i] = trial_vector
                fitness[i] = trial_fitness

                # Update island best
                if trial_fitness < island['best_fitness']:
                    island['best_fitness'] = trial_fitness
                    island['best_solution'] = trial_vector

                    # Update global best
                    if trial_fitness < self.best_fitness_overall:
                        self.best_fitness_overall = trial_fitness
                        self.best_solution_overall = trial_vector

        island['population'] = population  # Update island's population
        island['fitness'] = fitness      # Update island's fitness



    def migrate_individuals(self):
        # Select a random individual from each island
        migrants = []
        for island in self.islands:
            index = random.randint(0, self.population_size - 1)
            migrants.append(island['population'][index].copy())  # Important: copy to avoid modifying the original

        # Replace a random individual on each island with a migrant from another island
        for i in range(self.num_islands):
            receiving_island = self.islands[i]
            donor_island_index = (i + 1) % self.num_islands  # Choose the next island as the donor

            index_to_replace = random.randint(0, self.population_size - 1)
            receiving_island['population'][index_to_replace] = migrants[donor_island_index]
            receiving_island['fitness'][index_to_replace] = float('inf') # Mark as unevaluated


2025-06-24 21:27:27 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-24 21:27:35 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.1735
2025-06-24 21:27:35 INFO FeHistory: [103603.24478461 166514.7680879  158652.71236775 ...  -3799.01116057
  -3561.60446754  32684.13268298]
2025-06-24 21:27:35 INFO Expected Optimum FE: -5000
2025-06-24 21:27:35 INFO Good algorithm:
Algorithm Name: IslandDifferentialEvolution
import numpy as np
import random

# Name: IslandDifferentialEvolution
# Description: A multi-island differential evolution algorithm with periodic migration to enhance global exploration in multimodal landscapes.
# Code:
class IslandDifferentialEvolution:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float], num_islands: int = 5, population_size: int = 20, migration_interval: int = 500, crossover_rate: float = 0.7, mutation_rate: float = 0.5):
        """
        Initializes the IslandDifferentialEvolution algorithm.

        Args:
            budget (int): Max function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): Lower bounds for each dimension.
            upper_bounds (list[float]): Upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island.
            migration_interval (int): Number of evaluations between migrations.
            crossover_rate (float): Crossover rate for differential evolution.
            mutation_rate (float): Mutation rate (F) for differential evolution.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.migration_interval = migration_interval
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize islands
        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            fitnesses = np.full(self.population_size, float('inf'))
            self.islands.append({'population': population, 'fitnesses': fitnesses, 'best_solution': None, 'best_fitness': float('inf')})

    def differential_evolution(self, island_index: int, objective_function: callable) -> None:
        """
        Performs a single generation of differential evolution on a single island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to minimize.
        """
        island = self.islands[island_index]
        population = island['population']
        fitnesses = island['fitnesses']

        # Evaluate fitness if not already evaluated
        unevaluated_indices = np.where(fitnesses == float('inf'))[0]
        if len(unevaluated_indices) > 0:
            unevaluated_solutions = population[unevaluated_indices]
            new_fitnesses = objective_function(unevaluated_solutions)
            self.eval_count += len(unevaluated_solutions)
            fitnesses[unevaluated_indices] = new_fitnesses

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)

            mutant = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds) # added clipping.

            # Crossover
            trial = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):
                    trial[j] = mutant[j]

            # Selection
            trial_fitness = objective_function(np.array([trial]))[0] # Ensure objective_function receives a 2D array
            self.eval_count += 1

            if trial_fitness < fitnesses[i]:
                population[i] = trial
                fitnesses[i] = trial_fitness

                # Update best solution on this island
                if trial_fitness < island['best_fitness']:
                    island['best_solution'] = trial
                    island['best_fitness'] = trial_fitness

                # Update overall best solution
                if trial_fitness < self.best_fitness_overall:
                    self.best_solution_overall = trial
                    self.best_fitness_overall = trial_fitness
    

    def migrate(self) -> None:
         """
         Migrates individuals between islands in a ring topology.  The best individual
         from one island is sent to the next island in the ring.
         """
         best_individuals = [island['best_solution'] for island in self.islands]
         
         # Ring migration topology
         for i in range(self.num_islands):
             receiving_island_index = (i + 1) % self.num_islands
             
             # If the island has found something, overwrite a random individual in the next island.
             if best_individuals[i] is not None:
                random_index = random.randint(0, self.population_size - 1)
                self.islands[receiving_island_index]['population'][random_index] = best_individuals[i]
                self.islands[receiving_island_index]['fitnesses'][random_index] = float('inf')  # Mark as un-evaluated.
             # pass

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using a multi-island differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to minimize.
            acceptance_threshold (float): Not used.

        Returns:
            tuple: (best_solution_1D_numpy_array, best_fitness_scalar, optimization_info_dict)
        """
        self.eval_count = 0
        self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim) #added
        self.best_fitness_overall = float('inf')

        while self.eval_count < self.budget:
            # Evolve each island
            for i in range(self.num_islands):
                self.differential_evolution(i, objective_function)

            # Migrate individuals
            if self.eval_count % self.migration_interval == 0:
                self.migrate()

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
2025-06-24 21:27:35 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-24 21:27:35 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.3337
2025-06-24 21:27:35 INFO FeHistory: [224720.97273788 165587.0013272  184439.85849242 ...  -4999.99999966
  -4999.99999968  -4999.99999924]
2025-06-24 21:27:35 INFO Expected Optimum FE: -5000
2025-06-24 21:27:35 INFO Good algorithm:
Algorithm Name: IslandDifferentialEvolution
import numpy as np
import random

# Name: IslandDifferentialEvolution
# Description: Uses an island model with differential evolution and random immigrants to explore multimodal landscapes.
# Code:
class IslandDifferentialEvolution:
    """
    Implements an island model differential evolution algorithm for global optimization.
    """
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 5000, migration_size: int = 2):
        """
        Initializes the IslandDifferentialEvolution algorithm.

        Args:
            budget: Total function evaluation budget.
            dim: Dimensionality of the problem.
            lower_bounds: List of lower bounds for each dimension.
            upper_bounds: List of upper bounds for each dimension.
            num_islands: Number of independent islands (sub-populations).
            population_size: Size of the population on each island.
            crossover_rate: Crossover rate for differential evolution.
            mutation_rate: Mutation rate for differential evolution.
            migration_interval: Number of evaluations before migration occurs.
            migration_size: Number of individuals to migrate between islands.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size

        self.populations = []
        self.fitness_values = []
        self.best_solutions = []
        self.best_fitnesses = []

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize islands
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            self.populations.append(population)
            self.fitness_values.append(np.full(self.population_size, float('inf')))  # Initialize fitnesses to infinity
            self.best_solutions.append(None)
            self.best_fitnesses.append(float('inf'))


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Performs the optimization process using the island differential evolution algorithm.

        Args:
            objective_function: The function to be minimized.  Takes a 2D NumPy array (N, dim)
                                and returns a 1D NumPy array of N fitness values.
            acceptance_threshold:  Not used in this implementation, kept for consistency with API.

        Returns:
            A tuple containing:
                - The best solution found (1D numpy array).
                - The best fitness value achieved (scalar).
                - A dictionary containing optimization information (number of function evaluations).
        """
        self.eval_count = 0 # Reset for this run
        # Ensure best solution is initialized *before* the main loop

        for island_index in range(self.num_islands):
            if self.dim > 0:
                self.best_solutions[island_index] = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
            else:
                self.best_solutions[island_index] = np.array([])
            self.best_fitnesses[island_index] = float('inf')



        while self.eval_count < self.budget:
            for island_index in range(self.num_islands):
                # Differential Evolution within each island
                for i in range(self.population_size):
                    # Ensure we don't exceed the budget during DE steps.
                    if self.eval_count >= self.budget:
                        break
                    
                    # Mutation
                    indices = list(range(self.population_size))
                    indices.remove(i)
                    a, b, c = random.sample(indices, 3)
                    mutant = self.populations[island_index][a] + self.mutation_rate * (self.populations[island_index][b] - self.populations[island_index][c])
                    mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

                    # Crossover
                    trial = np.copy(self.populations[island_index][i])
                    for j in range(self.dim):
                        if random.random() < self.crossover_rate:
                            trial[j] = mutant[j]
                            
                    # Selection
                    fitness_trial = objective_function(trial.reshape(1, -1))[0]  # Correctly reshape trial and retrieve scalar
                    self.eval_count += 1

                    if fitness_trial < self.fitness_values[island_index][i]:
                        self.populations[island_index][i] = trial
                        self.fitness_values[island_index][i] = fitness_trial
                        
                        if fitness_trial < self.best_fitnesses[island_index]:
                            self.best_fitnesses[island_index] = fitness_trial
                            self.best_solutions[island_index] = trial  # store the vector itself

            # Migration
            if self.eval_count % self.migration_interval == 0 and self.num_islands > 1:
                # Select random islands for migration
                island1_index = random.randint(0, self.num_islands - 1)
                island2_index = random.randint(0, self.num_islands - 1)
                while island2_index == island1_index:
                    island2_index = random.randint(0, self.num_islands - 1)

                # Select individuals to migrate (best from island 1 replaces worst in island 2)
                # Sort individuals in island 2 by fitness value, in descending order
                sorted_indices = np.argsort(self.fitness_values[island2_index])[::-1]  # high to low
                migrant_indices = sorted_indices[:self.migration_size]
                
                for i in range(self.migration_size): # Migration size handled here
                    self.populations[island2_index][migrant_indices[i]] = self.best_solutions[island1_index]
                    self.fitness_values[island2_index][migrant_indices[i]] = self.best_fitnesses[island1_index]  # Synchronize fitness, importantly!

            # Random Immigrants
            if self.eval_count % 1000 == 0:
                for island_index in range(self.num_islands):
                     immigrant = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
                     fitness_immigrant = objective_function(immigrant.reshape(1, -1))[0]
                     self.eval_count += 1

                     worst_index = np.argmax(self.fitness_values[island_index])
                     if fitness_immigrant < self.fitness_values[island_index][worst_index]:
                        self.populations[island_index][worst_index] = immigrant
                        self.fitness_values[island_index][worst_index] = fitness_immigrant

            # Track the overall best solution
            for island_index in range(self.num_islands):
                if self.best_fitnesses[island_index] < self.best_fitness_overall:
                    self.best_fitness_overall = self.best_fitnesses[island_index]
                    self.best_solution_overall = self.best_solutions[island_index]
            if self.eval_count >= self.budget:
                break


        if self.best_solution_overall is None and self.dim > 0 : # Fallback
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }

        return self.best_solution_overall, self.best_fitness_overall, optimization_info
2025-06-24 21:27:35 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-24 21:27:39 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:27:39 INFO FeHistory: [107424.40880535 199409.1583447  216552.25625612 ...  -3950.52030982
  -4005.2203765   -3572.61184249]
2025-06-24 21:27:39 INFO Expected Optimum FE: -5000
2025-06-24 21:27:39 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-24 21:27:39 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0813
2025-06-24 21:27:39 INFO FeHistory: [240854.71622983 157431.24142924 157482.31746391 ...  -4999.40426006
  -4999.01124742  -4999.22417887]
2025-06-24 21:27:39 INFO Expected Optimum FE: -5000
2025-06-24 21:27:39 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-24 21:28:17 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0691
2025-06-24 21:28:17 INFO FeHistory: [145045.28706266 232557.94984358 263394.1177235  ...  -4990.30003812
  -4988.02885573  -4983.6297927 ]
2025-06-24 21:28:17 INFO Expected Optimum FE: -5000
2025-06-24 21:28:17 INFO Unimodal AOCC mean: nan
2025-06-24 21:28:17 INFO Multimodal (single component) AOCC mean: nan
2025-06-24 21:28:17 INFO Multimodal (multiple components) AOCC mean: 0.3785
2025-06-24 21:28:17 INFO AOCC mean: 0.3785
2025-06-24 21:28:17 INFO Weighed AOCC mean: nan
2025-06-24 21:28:26 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.1126
2025-06-24 21:28:26 INFO FeHistory: [327470.0609316  176024.55597245 141241.21550241 ...  -4316.8958384
  -4317.05043686  -4317.74730621]
2025-06-24 21:28:26 INFO Expected Optimum FE: -5000
2025-06-24 21:28:26 INFO Good algorithm:
Algorithm Name: IslandDifferentialEvolution
import numpy as np
import random

# Name: IslandDifferentialEvolution
# Description: A multi-island differential evolution algorithm with periodic migration to enhance global exploration in multimodal landscapes.
# Code:
class IslandDifferentialEvolution:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float], num_islands: int = 5, population_size: int = 20, migration_interval: int = 500, crossover_rate: float = 0.7, mutation_rate: float = 0.5):
        """
        Initializes the IslandDifferentialEvolution algorithm.

        Args:
            budget (int): Max function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): Lower bounds for each dimension.
            upper_bounds (list[float]): Upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island.
            migration_interval (int): Number of evaluations between migrations.
            crossover_rate (float): Crossover rate for differential evolution.
            mutation_rate (float): Mutation rate (F) for differential evolution.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.migration_interval = migration_interval
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize islands
        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            fitnesses = np.full(self.population_size, float('inf'))
            self.islands.append({'population': population, 'fitnesses': fitnesses, 'best_solution': None, 'best_fitness': float('inf')})

    def differential_evolution(self, island_index: int, objective_function: callable) -> None:
        """
        Performs a single generation of differential evolution on a single island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to minimize.
        """
        island = self.islands[island_index]
        population = island['population']
        fitnesses = island['fitnesses']

        # Evaluate fitness if not already evaluated
        unevaluated_indices = np.where(fitnesses == float('inf'))[0]
        if len(unevaluated_indices) > 0:
            unevaluated_solutions = population[unevaluated_indices]
            new_fitnesses = objective_function(unevaluated_solutions)
            self.eval_count += len(unevaluated_solutions)
            fitnesses[unevaluated_indices] = new_fitnesses

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)

            mutant = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds) # added clipping.

            # Crossover
            trial = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):
                    trial[j] = mutant[j]

            # Selection
            trial_fitness = objective_function(np.array([trial]))[0] # Ensure objective_function receives a 2D array
            self.eval_count += 1

            if trial_fitness < fitnesses[i]:
                population[i] = trial
                fitnesses[i] = trial_fitness

                # Update best solution on this island
                if trial_fitness < island['best_fitness']:
                    island['best_solution'] = trial
                    island['best_fitness'] = trial_fitness

                # Update overall best solution
                if trial_fitness < self.best_fitness_overall:
                    self.best_solution_overall = trial
                    self.best_fitness_overall = trial_fitness
    

    def migrate(self) -> None:
         """
         Migrates individuals between islands in a ring topology.  The best individual
         from one island is sent to the next island in the ring.
         """
         best_individuals = [island['best_solution'] for island in self.islands]
         
         # Ring migration topology
         for i in range(self.num_islands):
             receiving_island_index = (i + 1) % self.num_islands
             
             # If the island has found something, overwrite a random individual in the next island.
             if best_individuals[i] is not None:
                random_index = random.randint(0, self.population_size - 1)
                self.islands[receiving_island_index]['population'][random_index] = best_individuals[i]
                self.islands[receiving_island_index]['fitnesses'][random_index] = float('inf')  # Mark as un-evaluated.
             # pass

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using a multi-island differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to minimize.
            acceptance_threshold (float): Not used.

        Returns:
            tuple: (best_solution_1D_numpy_array, best_fitness_scalar, optimization_info_dict)
        """
        self.eval_count = 0
        self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim) #added
        self.best_fitness_overall = float('inf')

        while self.eval_count < self.budget:
            # Evolve each island
            for i in range(self.num_islands):
                self.differential_evolution(i, objective_function)

            # Migrate individuals
            if self.eval_count % self.migration_interval == 0:
                self.migrate()

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
2025-06-24 21:28:26 INFO Unimodal AOCC mean: nan
2025-06-24 21:28:26 INFO Multimodal (single component) AOCC mean: nan
2025-06-24 21:28:26 INFO Multimodal (multiple components) AOCC mean: 0.0954
2025-06-24 21:28:26 INFO AOCC mean: 0.0954
2025-06-24 21:28:26 INFO Weighed AOCC mean: nan
2025-06-24 21:28:26 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:28:26 INFO FeHistory: [159990.20765427 169875.40662085 193408.41489718 ...  -4414.94031339
  -4412.68201823  -4413.92971222]
2025-06-24 21:28:26 INFO Expected Optimum FE: -5000
2025-06-24 21:28:26 INFO Unimodal AOCC mean: nan
2025-06-24 21:28:26 INFO Multimodal (single component) AOCC mean: nan
2025-06-24 21:28:26 INFO Multimodal (multiple components) AOCC mean: 0.1554
2025-06-24 21:28:26 INFO AOCC mean: 0.1554
2025-06-24 21:28:26 INFO Weighed AOCC mean: nan
2025-06-24 21:28:27 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:28:27 INFO FeHistory: [120315.11039294 178355.77410965 155074.40707208 ...  -4317.8969028
  -4317.89554431  -4317.8970914 ]
2025-06-24 21:28:27 INFO Expected Optimum FE: -5000
2025-06-24 21:28:27 INFO Unimodal AOCC mean: nan
2025-06-24 21:28:27 INFO Multimodal (single component) AOCC mean: nan
2025-06-24 21:28:27 INFO Multimodal (multiple components) AOCC mean: 0.1637
2025-06-24 21:28:27 INFO AOCC mean: 0.1637
2025-06-24 21:28:27 INFO Weighed AOCC mean: nan
2025-06-24 21:28:28 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:28:28 INFO FeHistory: [171995.54146488 155229.49809301 212599.6139391  ...   4028.50342816
  14978.35855206   9713.13723866]
2025-06-24 21:28:28 INFO Expected Optimum FE: -5000
2025-06-24 21:28:28 INFO Unimodal AOCC mean: nan
2025-06-24 21:28:28 INFO Multimodal (single component) AOCC mean: nan
2025-06-24 21:28:28 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 21:28:28 INFO AOCC mean: 0.0000
2025-06-24 21:28:28 INFO Weighed AOCC mean: nan
2025-06-24 21:30:38 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-24 21:30:38 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-24 21:30:38 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-24 21:30:38 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-24 21:30:38 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-24 21:30:38 ERROR Can not run the algorithm
2025-06-24 21:30:39 INFO Run function 16 complete. FEHistory len: 200, AOCC: 0.0000
2025-06-24 21:30:39 INFO FeHistory: [166364.70048184 118841.30310687 144654.46234435 138590.36550619
 111595.68921172 126482.46374954 140167.43220142 155147.26884965
 154315.12582506 139121.41105436 140567.11313302 101776.93706831
 111083.13015613  92467.98814381  98486.61482803  86281.30082826
 113457.90028937 138716.61542335 147069.44397847 131289.32520712
  91512.0882468  150907.68265814 174250.61966423 117958.76934011
 146025.75852838 144678.85385668 155656.95817577 108375.60409202
 121483.10975933  92571.9596709  126424.0206754   79849.64693505
 123494.70259807 128495.38555875 133700.88132579  88399.49912189
 146501.91915808  77585.34141251 128188.9915459  142308.3692818
 130791.28852664 127624.75514929 168010.27043912 119451.52595684
 163943.22583246 173682.35657085  95157.44492874  95360.70599067
 113546.7049225  130548.88320614 149233.07601865 184715.42025125
 105121.23162198 104283.65147774 116353.03066336 139845.12782631
 152199.03938501 118675.70486529 116535.71739507 136419.36689094
 119231.98182796 196700.48466999 108309.84282708 116480.07232859
 140040.22211642 141794.37792931 150333.46837156 136050.22280663
 132434.47813825 126578.57569509 128019.71293576 149552.24443591
 144813.66914836 135128.82570525 124370.14502064 102285.85474511
 158456.51976775  86888.85574304 116630.77055542 118932.47712468
 119412.68108414  99980.01357126 132279.32201321 134192.41295701
 143428.24372196 125533.37715102 136836.71396211 107753.64545722
 118118.86195333 106278.91341473 124105.44024332 106492.05859835
 134425.88752223 148840.03981103  74735.49850568 167864.28494551
 104487.0077063  178318.26828135 153178.84534136 149697.3267801
 152426.69475174 160696.52978626 119909.81931365 130909.52346057
 141931.75726759 156499.81108837  97799.05404508 127402.4415868
 153043.77078412 137027.40092775 154829.1460058  105993.06106188
  88397.90955834 133819.34426352 111290.3719605  151640.45057058
 162237.57880303 131384.61539079 145982.03024617 130903.90472422
 151100.03312427 137542.37592598 133471.69118681 145548.92641529
 131961.41615159 140457.47993053 157817.28179284 151731.55176365
 175004.83981518 198681.93549459  98639.80343442 147090.10050939
 108139.19135386 167718.42014322 162886.03519768  76533.04312108
 131146.19216198 105593.99453026  90286.06471648  97363.13291082
 123562.50890734 124764.69526056 136772.65751106  89289.45633471
 158680.28050023 186723.90117266 165859.36427145 123078.757755
 155800.73555355 110393.58170619 135959.20154576 123939.58966146
 135753.12698905 122979.24203907 117546.71560886 145644.64097999
 126303.98994782 127438.28328631 117490.99461699  89224.46873758
  77443.06158163 210929.93493491 180908.90874809 116518.59169392
 150208.86525802 105271.44627667 150106.55158809 120309.14669111
 142800.07956177 151957.13765273 140974.03840719 122706.72745794
 131465.29439578 155736.24814037 172212.04097698 199393.32059222
 141937.21202003 154723.64649157 157855.91176918 145964.94585673
 154393.93305311 126638.59004093 161364.4714623  147408.41266306
 184838.90204101 140763.04995055 113504.80229983 149895.90583709
 144602.4867008  114982.05972376 157322.91548143 168879.51717606
 138000.35225468 123796.29807072 158809.65407923 114599.92233398
  99019.04831304 143085.81182888  82629.1447054  143088.65179932]
2025-06-24 21:30:39 INFO Expected Optimum FE: -5000
2025-06-24 21:30:39 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 21:30:39 ERROR Can not run the algorithm
2025-06-24 21:30:39 INFO Run function 18 complete. FEHistory len: 330, AOCC: 0.0000
2025-06-24 21:30:39 INFO FeHistory: [136593.5955448  133124.04029449 165734.41134714 137330.78553554
 192434.18934779 119035.49198554 148980.1394351  204917.88136508
 107066.69154207 144771.4583594  198079.87692109 114092.30257335
  92533.46022448 122610.44773512 151073.81534996 135023.65080153
 216430.0384145   79346.04538561 143559.54357204 165345.6436213
 150248.3766483  175234.61834952 182521.79716323 124132.72615599
 135499.19826155 185442.27263931 186055.44535584 112121.42880873
 145802.47473571 119714.55161501 153191.86094765 189038.74752158
 182577.64905658 166994.22621377 124507.69486966 243473.44412733
 164585.05185636 158802.53752342  75848.60481913 157875.10345607
 131042.28877035 109889.72337483 117424.82004109 173717.16449065
 111792.57771449 135750.82572028 115883.65039957 170829.48677948
 148524.88062729 147256.11850743 125701.82066086 135897.67359308
 147263.59750039 136324.16114647 146813.8133937  170507.70909954
 181318.88381749 131808.59665719 132560.32893995 178882.4793614
 134904.26471576 168253.07544621 157110.33216695 230216.64160061
 105434.7422389  130618.24521706 155009.79299405 147084.67145229
 138622.38969945 106739.65858027 158419.72244094 133886.41523279
 148403.66342551 168037.22605064 140215.89411546 173966.45539516
 162035.6752347   90808.33511646 159552.48500594 145419.07846733
 119609.6274329  192708.93461774 181553.2994702  162836.26341543
 197412.68691216 189612.67815591 145010.36314158 120628.03399329
 149283.90905413 196533.45493757 186416.03373426 151048.84791233
 100280.24684165 208274.07385182 214208.91998306 128826.73535641
 181715.28507498 163199.11423086 249463.33121937 173101.01988796
 141485.67849742 140699.05617504 143333.0094991  132730.36347634
 135259.57034604 220789.52261729 140309.57332082 109512.36776977
 172009.33398576 151928.64720363 180074.23035866 211482.74443727
 126791.29624678 136480.77938018 180349.61310226 206266.88025088
  98392.18035126 172011.75113243  89200.79154113 170705.2878476
 186844.91334247 252394.81979582 198561.70406497 117794.63169073
 129516.19100951 157784.36827895 188031.56506181 103838.35723485
 175965.92837966 208460.97055352 173783.53106295 179269.58944275
 181059.60555338 159111.93400465 114636.55378419 203544.3363678
 187595.66624401 181807.12486639 126294.01389097 180692.43934634
 161516.80246154 131234.58119436 197202.96318882 125783.51178798
 235593.67945325 287741.19134868 108689.19118197 108280.29165603
 207392.12840397 183787.84343026  92483.76562431 139909.75228212
 203918.33562043 107372.31954353 269808.83259702 224750.2606296
 119389.97897887 102497.64383573 289452.56533395 229213.23625961
 188165.54727967 121745.01987472 174959.52199731 148891.00235739
 175272.95602053 173064.84062347 126312.32240932 178077.89850603
 193403.12439318 211116.91763969 159533.773136   174778.27277835
 152102.62943516 113937.34691067 136468.84726016 150302.62006438
 120278.22304015 155535.7796265  204124.76102438 170195.49715299
 143328.43938931 176055.99712776 219885.05745851 145171.35725311
 171776.82553783 153656.17340179 188502.41268617 220068.27943576
 220791.26728153 230453.36677442 153901.60035202 189506.98664907
 120229.39050382 234154.48079416 181956.36523125 218649.47839719
 209493.89370094 185272.41781912 138674.97858898 219547.17703032
 118050.35141205 199588.38579799 136017.90312935 134497.72092767
 137084.03326221 145525.63937652 171576.91374615 191520.76267292
 125588.21717516 169628.8782934  138397.25717902  70110.29886829
 126858.3151312  139814.4912407  160221.85807207 166189.05407522
 182631.00103111 170638.65785325 146598.88157737  95691.87738838
 126814.2011559  180147.22803296 180163.52426805 123270.65735119
 138147.21876419 212287.44959977 233761.59329579 150254.64812617
 255380.85174289 125712.78374588 132049.06733874 160298.85812652
 178500.2889964  155954.65337063 160045.71911937 202288.07368261
 123055.13837092 148776.35637414 134583.22568597 166398.7595742
 287987.94493454 118731.76286914 144684.93783521 208209.12134638
 222746.52170216 200424.41754952 114893.46587329 149453.87701773
 135829.43308998 211883.61021891 174605.33401767 203144.1671835
 169843.01884408 107741.81511687 174032.89077488 126046.29715705
 178506.2175196  134833.93329884 119360.81098883 123189.52215315
 150312.52960946 152567.31486656 147008.99514132 165453.81155905
 185804.65058148 114004.08257394 124772.04763167 196280.72578923
 127990.61857529 123465.0746342  190902.9335515  115618.28189127
  99595.08777483 148574.54483804  59404.72152473 127884.85054104
 148168.89645119 119301.30173791 145954.20908124 151898.01803873
 123915.03068527 156212.35417842 171508.77602647 140010.96362718
 136183.51502047 214819.55081737  94528.7995595  126852.59961666
 156462.31711079 117175.70649117 166964.27981122 195877.20189039
 140085.83549036 109612.4641225  154167.99693999 134973.4522743
 188157.89821893 157796.18784337 163974.44273671 138707.37365437
 146644.96862709 110648.96002882 223304.0268555  162218.79074093
 116454.78592882 104129.82193143 168813.64248394 174661.57388381
 149295.6058697  113123.3123463  229476.57713067 114693.2396022
 146638.38783349 127369.28222893 200769.47122159 198547.25574417
 159065.86684141 144788.86303454 120039.8579914  122661.04570512
 113144.3445815  149863.65826491 184414.93855355 179397.59668603
 121605.28621763 171648.26827202  73247.82881858 100923.99067783
 113394.00063212 183615.65367633]
2025-06-24 21:30:39 INFO Expected Optimum FE: -5000
2025-06-24 21:30:39 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-24 21:30:39 ERROR Can not run the algorithm
2025-06-24 21:30:40 INFO Run function 19 complete. FEHistory len: 200, AOCC: 0.0000
2025-06-24 21:30:40 INFO FeHistory: [160633.34326942 168304.47482169 183102.66466169 167800.61577696
 163303.32018579 128280.36945005 139888.41392558 133127.48792854
 115526.97102957 186908.85190273 129607.58383204 134914.40453281
 140896.74206251 155482.63646539 173809.9716713  248519.97085002
 159766.7138384  121669.18340574 175908.24629821 205243.46260293
 181034.90145733 143975.4990486  152501.99578596 140229.57550691
 213019.02568267 191351.18974869 218310.76596906 213145.22915128
 149838.09048627 201877.59598004 192577.28874329 198754.91478355
 166415.8440405  168265.19641065 115088.27171393 115789.12306841
 111536.94548622 159210.68410559 240881.80078068 208916.6745657
 188603.82906399 210684.55237558 170779.92129447 174468.9682362
 132152.52453668 251534.5929725  160131.91983235 185578.4932231
 105112.99066518 174758.50876792 129901.13220445 138044.23388756
 143115.10111825 135765.13058163 169757.18086369 180467.52175548
 218028.17403073 176416.54878097 115239.76348901 137049.55882165
 205289.63394272 141058.78953987 168791.95476151 199725.64872421
 266071.48559528 162044.05624884 162221.48694012 196857.26289271
  79242.91097308 178814.24249922 142430.16121096 132883.46680361
 147461.87315728 220793.11134786 188678.87273352 185759.27757538
 178926.08959409 114381.47108441 180332.89865615 222914.36253041
 136501.11066059 280875.17370429 171059.2840286  219478.2579359
 158014.2547441  153559.87115697 165709.49964123 245123.35430212
 129682.51541053 248878.77225627 132867.56335368 232161.27811152
 258793.42781348 111993.31104389 205116.55455048 110439.05123585
 155127.09864137 189223.22966511 163252.04527324 176145.23661243
 143269.61617996 127104.48665446 210252.21134836 200012.08138394
 102259.45940242 199129.25455108 142835.64083423 222791.01849578
 180849.98001125 142027.16493619 235897.48361355 222976.91773344
 182774.37293476 137206.04791412  99443.18980806 167663.78486791
 172869.12397783 134291.980266   196544.09892283 123228.63093495
 124140.7744029  195418.69237397 162813.6196085  230554.31530307
 242168.12849811 185343.90362812 190708.85691678 212000.57951556
 190360.33819031 204104.20986732 187370.68296846 171082.48498289
 165939.83743574 232294.77579173 268796.79526236 182705.59311716
 209617.47621078 205409.59082089 156369.11779916 241637.42980876
 165301.0115752  273794.86100175 303760.10951241 205997.10820853
 166786.45555795 173394.2435559  178477.65280711 223128.05648621
 119710.72650093 200321.30787576 197992.48136293 245898.47338115
 188589.17509136 217132.90645379 164256.00164063 214245.73337835
 222742.46973677 125755.81929093 138919.6368859  248811.85242843
 120897.60981397 165175.79381096 170743.82272295  82050.09159122
 348838.05757164 144099.15446971 162852.53998457 210764.39394399
 126789.27194487 150057.21892292  74003.19428211 164606.95638394
 174272.07998118 230606.59057381 199220.46884403 154908.17757297
 162436.62306983 225691.23660453 232123.96195676 242462.28606523
 149225.50160242 152553.42154947 169487.81530338 152786.66994267
 130551.22722328 206509.49165762 241469.61700911 175674.34452015
 186192.94360013 206495.7632544  261074.37909201 143125.11171435
 174225.82770657 257029.04691982 180415.85825041 117251.08733926
 150489.71516601 219442.14259285 210787.60399885 198247.47006462]
2025-06-24 21:30:40 INFO Expected Optimum FE: -5000
2025-06-24 21:30:40 INFO Unimodal AOCC mean: nan
2025-06-24 21:30:40 INFO Multimodal (single component) AOCC mean: nan
2025-06-24 21:30:40 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 21:30:40 INFO AOCC mean: 0.0000
2025-06-24 21:30:40 INFO Weighed AOCC mean: nan
2025-06-24 21:30:40 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-24 21:31:26 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:31:26 INFO FeHistory: [146194.2401409  113887.8808007  129445.55670415 ... 110496.85789602
 120933.82821011 131967.12690624]
2025-06-24 21:31:26 INFO Expected Optimum FE: -5000
2025-06-24 21:31:26 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 21:31:28 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:31:28 INFO FeHistory: [124709.89476527 169082.58335149 138210.29414044 ...  23529.79827438
  15737.5953321   19056.32157664]
2025-06-24 21:31:28 INFO Expected Optimum FE: -5000
2025-06-24 21:31:28 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 21:31:31 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:31:31 INFO FeHistory: [141130.52501062  97821.58633099 124760.85594321 ...  -4470.39999995
  -4470.39999994  -4470.39999992]
2025-06-24 21:31:31 INFO Expected Optimum FE: -5000
2025-06-24 21:31:31 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 21:31:31 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:31:31 INFO FeHistory: [120942.12192916 108960.04325703 178251.26431456 ...  63998.15796357
   4182.45966589  21995.29195089]
2025-06-24 21:31:31 INFO Expected Optimum FE: -5000
2025-06-24 21:31:31 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 21:32:09 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:32:09 INFO FeHistory: [208866.305972   151465.05444156 146024.82147542 ...  95052.13698811
 218063.26617973 160710.82380937]
2025-06-24 21:32:09 INFO Expected Optimum FE: -5000
2025-06-24 21:32:09 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-24 21:32:13 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:32:13 INFO FeHistory: [128938.84403846 147930.52390981 105709.00720238 ...  38457.56658012
  31283.47121897  30536.82931249]
2025-06-24 21:32:13 INFO Expected Optimum FE: -5000
2025-06-24 21:32:13 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-24 21:32:19 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:32:19 INFO FeHistory: [123055.05601536 122496.89805391 146221.71462374 ...  11975.92326854
   7230.98055914  18603.28953322]
2025-06-24 21:32:19 INFO Expected Optimum FE: -5000
2025-06-24 21:32:19 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-24 21:32:19 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:32:19 INFO FeHistory: [118384.71637213 160698.17094115 210426.9095817  ...  -4317.89999705
  -4317.89999867  -4317.8999983 ]
2025-06-24 21:32:19 INFO Expected Optimum FE: -5000
2025-06-24 21:32:19 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-24 21:32:20 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:32:20 INFO FeHistory: [116809.16759578 104545.16733571 130894.16702908 ...  -3931.6450458
  -3931.64495571  -3931.64496272]
2025-06-24 21:32:20 INFO Expected Optimum FE: -5000
2025-06-24 21:32:20 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 21:32:53 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:32:53 INFO FeHistory: [120158.35564528 168633.69892671 193356.99730631 ...  76854.06729714
 139388.10553209 209062.92528117]
2025-06-24 21:32:53 INFO Expected Optimum FE: -5000
2025-06-24 21:32:53 INFO Unimodal AOCC mean: nan
2025-06-24 21:32:53 INFO Multimodal (single component) AOCC mean: nan
2025-06-24 21:32:53 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 21:32:53 INFO AOCC mean: 0.0000
2025-06-24 21:32:53 INFO Weighed AOCC mean: nan
2025-06-24 21:32:53 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-24 21:32:58 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:32:58 INFO FeHistory: [219937.67084947 191176.96299835 161974.71639366 ...  92260.40872125
  53051.00378656 145120.58546362]
2025-06-24 21:32:58 INFO Expected Optimum FE: -5000
2025-06-24 21:32:58 INFO Unimodal AOCC mean: nan
2025-06-24 21:32:58 INFO Multimodal (single component) AOCC mean: nan
2025-06-24 21:32:58 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 21:32:58 INFO AOCC mean: 0.0000
2025-06-24 21:32:58 INFO Weighed AOCC mean: nan
2025-06-24 21:32:59 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-24 21:33:06 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:33:06 INFO FeHistory: [181965.40279195 230520.01383555 153156.60140119 ...  80318.0292754
  82841.08146724 180940.68705421]
2025-06-24 21:33:06 INFO Expected Optimum FE: -5000
2025-06-24 21:33:06 INFO Unimodal AOCC mean: nan
2025-06-24 21:33:06 INFO Multimodal (single component) AOCC mean: nan
2025-06-24 21:33:06 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 21:33:06 INFO AOCC mean: 0.0000
2025-06-24 21:33:06 INFO Weighed AOCC mean: nan
2025-06-24 21:33:07 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:33:07 INFO FeHistory: [232358.59046128 200405.82586805 114651.67680678 ...  71649.5534991
  -4317.5943847   -4317.69892237]
2025-06-24 21:33:07 INFO Expected Optimum FE: -5000
2025-06-24 21:33:07 INFO Unimodal AOCC mean: nan
2025-06-24 21:33:07 INFO Multimodal (single component) AOCC mean: nan
2025-06-24 21:33:07 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 21:33:07 INFO AOCC mean: 0.0000
2025-06-24 21:33:07 INFO Weighed AOCC mean: nan
2025-06-24 21:33:42 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:33:42 INFO FeHistory: [133558.52772079 107556.55961865 114742.15949438 ...   6192.47062597
  -1329.01058182  -1329.01058182]
2025-06-24 21:33:42 INFO Expected Optimum FE: -5000
2025-06-24 21:33:42 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 21:33:46 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:33:46 INFO FeHistory: [153885.4629946  121275.83004462 150697.24930938 ...  -4084.53922571
  -4006.64173648  -4081.43614249]
2025-06-24 21:33:46 INFO Expected Optimum FE: -5000
2025-06-24 21:33:46 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 21:34:12 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:34:12 INFO FeHistory: [176508.00979633 157807.60691989 163139.21968736 ...  -1392.70142171
  -1392.70142527  -1392.7014209 ]
2025-06-24 21:34:12 INFO Expected Optimum FE: -5000
2025-06-24 21:34:12 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-24 21:34:28 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:34:28 INFO FeHistory: [224951.08733118 153624.55279047 116160.87216999 ...  18881.64225033
   5851.17649616  28283.24874884]
2025-06-24 21:34:28 INFO Expected Optimum FE: -5000
2025-06-24 21:34:28 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-24 21:34:33 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0005
2025-06-24 21:34:33 INFO FeHistory: [154119.37853946 165382.52065539  84538.83618346 ...  -2895.00741763
   2238.98792447  -2783.12884739]
2025-06-24 21:34:33 INFO Expected Optimum FE: -5000
2025-06-24 21:34:33 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-24 21:35:14 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:35:14 INFO FeHistory: [243805.37381723  82931.68512295 166460.47148067 ...   5218.27515255
   8618.86592276  13447.78170319]
2025-06-24 21:35:14 INFO Expected Optimum FE: -5000
2025-06-24 21:35:14 INFO Unimodal AOCC mean: nan
2025-06-24 21:35:14 INFO Multimodal (single component) AOCC mean: nan
2025-06-24 21:35:14 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 21:35:14 INFO AOCC mean: 0.0000
2025-06-24 21:35:14 INFO Weighed AOCC mean: nan
2025-06-24 21:35:19 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:35:19 INFO FeHistory: [178876.89454051 163947.97962264 144200.97862729 ...  13710.64355779
   5875.76782238   6174.97935293]
2025-06-24 21:35:19 INFO Expected Optimum FE: -5000
2025-06-24 21:35:19 INFO Unimodal AOCC mean: nan
2025-06-24 21:35:19 INFO Multimodal (single component) AOCC mean: nan
2025-06-24 21:35:19 INFO Multimodal (multiple components) AOCC mean: 0.0002
2025-06-24 21:35:19 INFO AOCC mean: 0.0002
2025-06-24 21:35:19 INFO Weighed AOCC mean: nan
2025-06-24 21:35:56 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:35:56 INFO FeHistory: [144365.06199695 318383.06128382  97188.46861779 ...  -4317.21820704
  -4316.68385728  -4317.24756945]
2025-06-24 21:35:56 INFO Expected Optimum FE: -5000
2025-06-24 21:35:56 INFO Unimodal AOCC mean: nan
2025-06-24 21:35:56 INFO Multimodal (single component) AOCC mean: nan
2025-06-24 21:35:56 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 21:35:56 INFO AOCC mean: 0.0000
2025-06-24 21:35:56 INFO Weighed AOCC mean: nan
2025-06-24 21:36:28 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-24 21:36:28 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-24 21:37:13 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0864
2025-06-24 21:37:13 INFO FeHistory: [163293.22441048 112388.30553959 149946.72819672 ...  21629.34587183
  -4999.67732498  23127.86270058]
2025-06-24 21:37:13 INFO Expected Optimum FE: -5000
2025-06-24 21:37:13 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 21:37:13 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:37:13 INFO FeHistory: [143534.80761846 136360.35584922 103650.47740201 ...  -4317.54581792
  -4317.586434    -4317.55417005]
2025-06-24 21:37:13 INFO Expected Optimum FE: -5000
2025-06-24 21:37:13 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 21:37:53 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.2552
2025-06-24 21:37:53 INFO FeHistory: [146740.36587438 133286.49661252 168764.3426083  ...  -4317.89995248
  -4317.89997901  -4317.89995747]
2025-06-24 21:37:53 INFO Expected Optimum FE: -5000
2025-06-24 21:37:53 INFO Good algorithm:
Algorithm Name: AdaptiveIslandDifferentialEvolution
import numpy as np
import random

# Name: AdaptiveIslandDifferentialEvolution
# Description: Employs an island model with adaptive island sizes and migration rates based on island performance to enhance global exploration in deceptive landscapes.
# Code:
class AdaptiveIslandDifferentialEvolution:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float], initial_num_islands: int = 5, initial_population_size: int = 20, crossover_rate: float = 0.7, mutation_factor: float = 0.5, migration_interval: int = 500, island_size_adapt_freq: int = 1000):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.initial_num_islands = initial_num_islands
        self.initial_population_size = initial_population_size
        self.crossover_rate = crossover_rate
        self.mutation_factor = mutation_factor
        self.migration_interval = migration_interval
        self.island_size_adapt_freq = island_size_adapt_freq

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.islands = []
        for _ in range(self.initial_num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.initial_population_size, self.dim))
            self.islands.append({
                'population': population,
                'fitness': np.full(self.initial_population_size, float('inf')),
                'best_solution': None,
                'best_fitness': float('inf'),
                'size': self.initial_population_size,
                'migration_rate': 0.1  # Initial migration rate
            })

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0

        for island in self.islands:
            island['population'] = np.random.uniform(self.lower_bounds, self.upper_bounds, (island['size'], self.dim))
            island['fitness'] = np.full(island['size'], float('inf'))
            island['best_solution'] = None
            island['best_fitness'] = float('inf')

        self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        self.best_fitness_overall = float('inf')

        while self.eval_count < self.budget:
            for i in range(len(self.islands)):
                self.evolve_island(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate_individuals()

            if self.eval_count % self.island_size_adapt_freq == 0:
                self.adapt_island_sizes()

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def evolve_island(self, island_index: int, objective_function: callable):
        island = self.islands[island_index]
        population = island['population']
        fitness = island['fitness']
        island_size = island['size']

        # Evaluate initial population
        unevaluated_mask = np.isinf(fitness)
        if np.any(unevaluated_mask):
            unevaluated_individuals = population[unevaluated_mask]
            new_fitness_values = objective_function(unevaluated_individuals)
            self.eval_count += len(unevaluated_individuals)
            fitness[unevaluated_mask] = new_fitness_values

        island['fitness'] = fitness  # Update island's fitness array

        for i in range(island_size):
            # DE mutation
            indices = list(range(island_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)

            mutant = population[a] + self.mutation_factor * (population[b] - population[c])

            # Boundary handling
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

            # Crossover
            trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])

            # Evaluate trial vector
            trial_fitness = objective_function(np.array([trial_vector]))[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness[i]:
                population[i] = trial_vector
                fitness[i] = trial_fitness

                # Update island best
                if trial_fitness < island['best_fitness']:
                    island['best_fitness'] = trial_fitness
                    island['best_solution'] = trial_vector

                    # Update global best
                    if trial_fitness < self.best_fitness_overall:
                        self.best_fitness_overall = trial_fitness
                        self.best_solution_overall = trial_vector

        island['population'] = population  # Update island's population
        island['fitness'] = fitness      # Update island's fitness

    def migrate_individuals(self):
        for i in range(len(self.islands)):
            island = self.islands[i]
            island_size = island['size']
            num_migrants = int(island['migration_rate'] * island_size)

            if num_migrants > 0 and len(self.islands) > 1:
                 # Select migrants
                migrant_indices = random.sample(range(island_size), num_migrants)
                migrants = island['population'][migrant_indices].copy()

                 # Choose a different island to migrate to
                recipient_island_index = random.choice([j for j in range(len(self.islands)) if j != i])
                recipient_island = self.islands[recipient_island_index]
                recipient_island_size = recipient_island['size']

                # Replace individuals on the recipient island
                replace_indices = random.sample(range(recipient_island_size), num_migrants)
                recipient_island['population'][replace_indices] = migrants
                recipient_island['fitness'][replace_indices] = np.full(num_migrants, float('inf'))


    def adapt_island_sizes(self):
        island_fitnesses = [island['best_fitness'] for island in self.islands]
        min_fitness = min(island_fitnesses)
        max_fitness = max(island_fitnesses)

        if min_fitness == max_fitness:
            fitness_ranges = np.ones(len(self.islands))
        else:
            fitness_ranges = [(f - min_fitness) / (max_fitness - min_fitness) for f in island_fitnesses]


        total_range = sum(fitness_ranges)

        if total_range > 0:
             probabilities = [r / total_range for r in fitness_ranges]
        else:
             probabilities = [1/len(self.islands) for _ in self.islands]
             

        target_sizes = [max(10, int(p * self.initial_num_islands * self.initial_population_size)) for p in probabilities] # Ensure minimum size of 10. Prevents total collapse of pop on some islands

        for i in range(len(self.islands)):
            island = self.islands[i]
            current_size = island['size']
            new_size = target_sizes[i]

            if new_size != current_size:
                if new_size > current_size:
                    # Add new individuals randomly
                    new_individuals = np.random.uniform(self.lower_bounds, self.upper_bounds, (new_size - current_size, self.dim))
                    island['population'] = np.concatenate([island['population'], new_individuals])
                    island['fitness'] = np.concatenate([island['fitness'], np.full(new_size - current_size, float('inf'))])


                elif new_size < current_size:
                    # Remove worst individuals
                    fitnesses = island['fitness']
                    indices_sorted_by_fitness = np.argsort(fitnesses)
                    indices_to_keep = indices_sorted_by_fitness[:new_size]
                    island['population'] = island['population'][indices_to_keep]
                    island['fitness'] = island['fitness'][indices_to_keep]

                island['size'] = new_size  # Update island size

                #Re-assign island arrays to the shrunk/enlarged sizes:
                island['population'] = island['population'].reshape((island['size'], self.dim))
                island['fitness'] = island['fitness'].reshape((island['size'],))
2025-06-24 21:37:53 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-24 21:37:55 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:37:55 INFO FeHistory: [154373.14705681 188100.0183981  128380.15054603 ...  -4399.32685882
  -4398.91579689  -4316.77739925]
2025-06-24 21:37:55 INFO Expected Optimum FE: -5000
2025-06-24 21:37:55 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-24 21:38:34 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0029
2025-06-24 21:38:34 INFO FeHistory: [197592.09778052 157758.03829175 172799.1719339  ...  -4399.67493751
  -4399.68253497  -4399.56545803]
2025-06-24 21:38:34 INFO Expected Optimum FE: -5000
2025-06-24 21:38:34 INFO Unimodal AOCC mean: nan
2025-06-24 21:38:34 INFO Multimodal (single component) AOCC mean: nan
2025-06-24 21:38:34 INFO Multimodal (multiple components) AOCC mean: 0.1148
2025-06-24 21:38:34 INFO AOCC mean: 0.1148
2025-06-24 21:38:34 INFO Weighed AOCC mean: nan
2025-06-24 21:38:37 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-24 21:38:37 INFO FeHistory: [169093.09803819 192749.18554195 168139.86395408 ...  -4465.11801593
  -4466.47045481  -4415.16959077]
2025-06-24 21:38:37 INFO Expected Optimum FE: -5000
2025-06-24 21:38:37 INFO Unimodal AOCC mean: nan
2025-06-24 21:38:37 INFO Multimodal (single component) AOCC mean: nan
2025-06-24 21:38:37 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 21:38:37 INFO AOCC mean: 0.0000
2025-06-24 21:38:37 INFO Weighed AOCC mean: nan
