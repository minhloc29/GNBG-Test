2025-06-25 08:21:36 INFO Initializing first population
2025-06-25 08:21:36 INFO Initializing population from 4 seed files...
2025-06-25 08:39:09 INFO Started evolutionary loop, best so far: 0.3904505301102681
2025-06-25 08:39:09 INFO Population length is: 15
2025-06-25 08:39:09 INFO --- Performing Long-Term Reflection at Generation 1 ---
2025-06-25 08:39:09 INFO Reflection Prompt: ### Problem Description
**(CR: Capacity and Role)**
Act as an expert in designing algorithms for deceptive, multi-component landscapes. Your specialty is creating strategies that use multi-population or island models to perform aggressive global exploration.

**(I: Insight)**
Your objective is to design a novel optimization algorithm for the GNBG benchmark. The most difficult functions (f16-f24) have multiple, separate basins of attraction where the global optimum can be hidden. An algorithm must be able to discover and explore these competing regions to succeed.

**(S: Statement & P: Personality)**
Provide a complete, novel Python class that implements a multi-population or island-based search strategy to solve this challenge. The class must have an `__init__(...)` and `optimize(...)` method as specified in the main task description.

### List heuristics
Below is a list of design heuristics ranked from best to worst based on their AOCC score on group function 3 of GNBG benchmark, where higher is better. To enable a detailed analysis of their specializations, the performance breakdown on each of the three GNBG function groups is also provided.
### Rank 1 (Overall AOCC Score on Multimodal instances with multiple components: 3.9045e-01# Name: EnhancedArchiveGuidedDE
# Description: Seed from EnhancedArchiveGuidedDE
# Code:
```python
import numpy as np
import random

class EnhancedArchiveGuidedDE: #aocc 0.15
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 population_size_factor: float = 8.82865217019506, archive_size: int = 165.22481375900153, initial_F_scale: float = 0.3544373580018585):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.population_size = int(population_size_factor * self.dim)  # common heuristic
        self.archive_size = archive_size
        self.archive = []
        self.population = None
        self.F_scale = initial_F_scale  # initial scaling factor

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8,
                 F_scale_variation: float = 0.3, archive_update_threshold: float = 0.8) -> tuple:
        self.eval_count = 0
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        fitness = objective_function(self.population)
        self.eval_count += self.population_size

        self.best_solution_overall = self.population[np.argmin(fitness)]
        self.best_fitness_overall = np.min(fitness)

        while self.eval_count < self.budget:
            offspring = self.generate_offspring(self.population, fitness, F_scale_variation)
            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            # Update archive
            self.update_archive(offspring, offspring_fitness, archive_update_threshold)

            # Select best solutions for next generation
            combined_population = np.concatenate((self.population, offspring))
            combined_fitness = np.concatenate((fitness, offspring_fitness))
            indices = np.argsort(combined_fitness)
            self.population = combined_population[indices[:self.population_size]]
            fitness = combined_fitness[indices[:self.population_size]]

            # Update best solution
            self.best_solution_overall = self.population[np.argmin(fitness)]
            self.best_fitness_overall = np.min(fitness)

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'archive_size': len(self.archive)
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def generate_offspring(self, population, fitness, F_scale_variation):
        offspring = np.zeros((self.population_size, self.dim))
        # Adaptive scaling factor
        self.F_scale = 0.5 + F_scale_variation * np.random.rand()  # scale factor with slight variation

        for i in range(self.population_size):
            # Select pbest from archive (if available)
            if self.archive:
                pbest_index = np.random.choice(len(self.archive))
                pbest = self.archive[pbest_index][0]
            else:
                pbest = population[np.argmin(fitness)]

            a, b, c = random.sample(range(self.population_size), 3)
            while a == i or b == i or c == i:
                a, b, c = random.sample(range(self.population_size), 3)

            offspring[i] = population[i] + self.F_scale * (pbest - population[i] + population[a] - population[b])
            offspring[i] = np.clip(offspring[i], self.lower_bounds, self.upper_bounds)  # Boundary handling

        return offspring

    def update_archive(self, offspring, offspring_fitness, archive_update_threshold):
        for i in range(len(offspring)):
            if len(self.archive) < self.archive_size:
                self.archive.append((offspring[i], offspring_fitness[i]))
            else:
                # Prioritize diversity in archive
                worst_index = np.argmax([f for _, f in self.archive])
                if offspring_fitness[i] < self.archive[worst_index][1] or len(self.archive) < self.archive_size * archive_update_threshold:
                    self.archive[worst_index] = (offspring[i], offspring_fitness[i])
```

### Rank 2 (Overall AOCC Score on Multimodal instances with multiple components: 2.7961e-01# Name: AdaptiveGaussianArchiveEA
# Description: Seed from AdaptiveGaussianArchiveEA
# Code:
```python
import numpy as np
class AdaptiveGaussianArchiveEA:
    """
    Combines adaptive Gaussian sampling with an archive to enhance exploration and exploitation in multimodal landscapes.  Employs a simple Gaussian mutation strategy and tournament selection for efficiency.
    """
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        self.population_size = 100
        self.archive_size = 200  #Increased archive size for better diversity
        self.sigma = 0.5 * (self.upper_bounds - self.lower_bounds) #Increased initial sigma
        self.sigma_decay = 0.98 # Slightly faster decay
        self.archive = []

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        if self.dim > 0:
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        else:
            self.best_solution_overall = np.array([])
        self.best_fitness_overall = objective_function(self.best_solution_overall.reshape(1, -1))[0]
        self.eval_count += 1

        population = self._initialize_population()
        fitness_values = objective_function(population)
        self.eval_count += self.population_size

        self.archive = self._update_archive(population, fitness_values)

        while self.eval_count < self.budget:
            parents = self._tournament_selection(population, fitness_values)
            offspring = self._gaussian_recombination(parents)
            offspring = self._adaptive_mutation(offspring)
            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            population, fitness_values = self._select_next_generation(
                population, fitness_values, offspring, offspring_fitness
            )

            self.archive = self._update_archive(
                np.vstack((population, offspring)),
                np.concatenate((fitness_values, offspring_fitness))
            )

            self._update_best(offspring, offspring_fitness)
            self.sigma *= self.sigma_decay

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }

        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def _initialize_population(self):
        center = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        population = np.random.normal(center, self.sigma, size=(self.population_size, self.dim))
        return np.clip(population, self.lower_bounds, self.upper_bounds)

    def _tournament_selection(self, population, fitness_values):
        tournament_size = 5
        num_parents = self.population_size // 2
        selected_parents = []

        for _ in range(num_parents):
            tournament = np.random.choice(len(population), tournament_size, replace=False)
            winner_index = tournament[np.argmin(fitness_values[tournament])]
            selected_parents.append(population[winner_index])

        return np.array(selected_parents)

    def _gaussian_recombination(self, parents):
        offspring = []
        for i in range(0, len(parents), 2):
            parent1 = parents[i]
            parent2 = parents[i + 1]
            midpoint = (parent1 + parent2) / 2
            child1 = midpoint + np.random.normal(0, self.sigma / 2, self.dim)
            child2 = midpoint + np.random.normal(0, self.sigma / 2, self.dim)
            offspring.extend([child1, child2])
        return np.clip(np.array(offspring), self.lower_bounds, self.upper_bounds)

    def _adaptive_mutation(self, offspring):
        mutated = offspring + np.random.normal(0, self.sigma, size=offspring.shape)
        return np.clip(mutated, self.lower_bounds, self.upper_bounds)

    def _select_next_generation(self, population, fitness_values, offspring, offspring_fitness):
        combined_pop = np.vstack((population, offspring))
        combined_fit = np.concatenate((fitness_values, offspring_fitness))
        sorted_indices = np.argsort(combined_fit)
        next_gen = combined_pop[sorted_indices[:self.population_size]]
        next_fit = combined_fit[sorted_indices[:self.population_size]]
        return next_gen, next_fit

    def _update_best(self, offspring, offspring_fitness):
        for i, fitness in enumerate(offspring_fitness):
            if fitness < self.best_fitness_overall:
                self.best_fitness_overall = fitness
                self.best_solution_overall = offspring[i]

    def _update_archive(self, population, fitness_values):
        combined = np.column_stack((population, fitness_values))
        new_archive = []
        for sol in combined:
            already_present = any(np.allclose(sol[:-1], arch[:-1], atol=1e-6) for arch in self.archive)
            if not already_present:
                new_archive.append(sol)
        new_archive.sort(key=lambda x: x[-1])
        return np.array(new_archive[:self.archive_size])
```

### Rank 3 (Overall AOCC Score on Multimodal instances with multiple components: 2.2972e-01# Name: AdaptiveGaussianSamplingEA
# Description: Seed from AdaptiveGaussianSamplingEA
# Code:
```python
import numpy as np

class AdaptiveGaussianSamplingEA:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        self.population_size = 100  # Adjust as needed
        self.population = None
        self.sigma = 0.2 * (self.upper_bounds - self.lower_bounds)  # Initial Standard Deviation for Gaussian Sampling

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        fitness_values = objective_function(self.population)
        self.eval_count += self.population_size

        self.best_solution_overall = self.population[np.argmin(fitness_values)]
        self.best_fitness_overall = np.min(fitness_values)

        while self.eval_count < self.budget:
            # Adaptive Gaussian Sampling
            parents = self.tournament_selection(fitness_values, k=5)  # Tournament Selection
            offspring = self.gaussian_mutation(parents, self.sigma)

            # Bounds handling
            offspring = np.clip(offspring, self.lower_bounds, self.upper_bounds)

            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            # Update population and best solution
            self.population = np.concatenate((self.population, offspring))
            fitness_values = np.concatenate((fitness_values, offspring_fitness))

            best_index = np.argmin(fitness_values)
            if fitness_values[best_index] < self.best_fitness_overall:
                self.best_solution_overall = self.population[best_index]
                self.best_fitness_overall = fitness_values[best_index]

            # Adaptive Sigma
            self.sigma *= 0.99  # Gradually reduce sigma for finer search later.

            # Elitism
            sorted_pop = self.population[np.argsort(fitness_values)]
            self.population = sorted_pop[:self.population_size]
            fitness_values = fitness_values[np.argsort(fitness_values)][:self.population_size]

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def tournament_selection(self, fitnesses, k):
        num_parents = len(fitnesses) // 2  # Select half the population as parents
        parents = np.zeros((num_parents, self.dim))
        for i in range(num_parents):
            tournament = np.random.choice(len(fitnesses), size=k, replace=False)
            winner_index = tournament[np.argmin(fitnesses[tournament])]
            parents[i] = self.population[winner_index]
        return parents

    def gaussian_mutation(self, parents, sigma):
        offspring = parents + np.random.normal(0, sigma, parents.shape)
        return offspring

```

### Rank 4 (Overall AOCC Score on Multimodal instances with multiple components: 2.2113e-01# Name: IslandDifferentialEvolution
# Description: Uses an island model with differential evolution on each island to explore multiple basins of attraction,
# Code:
```python
import numpy as np
import random


# Name: IslandDifferentialEvolution
# Description: Uses an island model with differential evolution on each island to explore multiple basins of attraction,
#              and stochastic migration to exchange information between islands, promoting global exploration.
# Code:
class IslandDifferentialEvolution:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Algorithm parameters
        self.num_islands = 5
        self.population_size = 25
        self.crossover_rate = 0.7
        self.mutation_factor = 0.5
        self.migration_interval = 500  # Evaluate this for optimization later
        self.migration_size = 5
        self.island_populations = []
        self.island_fitnesses = []

        # Initialize islands
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            self.island_populations.append(population)
            self.island_fitnesses.append(np.full(self.population_size, float('inf')))

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0  # Reset for this run
        if self.dim > 0:
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        else:
            self.best_solution_overall = np.array([])
        self.best_fitness_overall = float('inf')

        # Initial evaluation
        for i in range(self.num_islands):
            fitnesses = objective_function(self.island_populations[i])
            self.island_fitnesses[i] = fitnesses
            self.eval_count += self.population_size

            best_index = np.argmin(fitnesses)
            if fitnesses[best_index] < self.best_fitness_overall:
                self.best_fitness_overall = fitnesses[best_index]
                self.best_solution_overall = self.island_populations[i][best_index].copy()

        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                # Differential Evolution within each island
                new_population = np.copy(self.island_populations[i])
                for j in range(self.population_size):
                    # Mutation
                    indices = np.random.choice(self.population_size, 3, replace=False)
                    x_r1, x_r2, x_r3 = self.island_populations[i][indices]
                    mutant_vector = x_r1 + self.mutation_factor * (x_r2 - x_r3)

                    # Crossover
                    trial_vector = np.copy(self.island_populations[i][j])
                    for k in range(self.dim):
                        if random.random() < self.crossover_rate:
                            trial_vector[k] = mutant_vector[k]

                    # Boundary Handling
                    trial_vector = np.clip(trial_vector, self.lower_bounds, self.upper_bounds)

                    # Evaluation
                    trial_vector_reshaped = trial_vector.reshape(1, -1)
                    f_trial = objective_function(trial_vector_reshaped)[0]
                    self.eval_count += 1

                    # Selection
                    if f_trial < self.island_fitnesses[i][j]:
                        new_population[j] = trial_vector
                        self.island_fitnesses[i][j] = f_trial

                        if f_trial < self.best_fitness_overall:
                            self.best_fitness_overall = f_trial
                            self.best_solution_overall = trial_vector.copy()

                self.island_populations[i] = new_population

            # Migration
            if self.eval_count // (self.num_islands*self.population_size) % self.migration_interval == 0 and self.eval_count > 0:
                # Stochastic migration: randomly select individuals to migrate
                for _ in range(self.migration_size):
                    source_island = random.randint(0, self.num_islands - 1)
                    dest_island = random.randint(0, self.num_islands - 1)
                    while dest_island == source_island:
                        dest_island = random.randint(0, self.num_islands - 1)

                    immigrant_index = random.randint(0, self.population_size - 1)
                    emigrant_index = random.randint(0, self.population_size - 1)

                    self.island_populations[dest_island][emigrant_index] = self.island_populations[source_island][immigrant_index].copy()
                    self.island_fitnesses[dest_island][emigrant_index] = objective_function(self.island_populations[dest_island][emigrant_index].reshape(1, -1))[0] #Immediate evaluation of new migrants
                    self.eval_count += 1

                    # Update best solution if needed
                    if self.island_fitnesses[dest_island][emigrant_index] < self.best_fitness_overall:
                        self.best_fitness_overall = self.island_fitnesses[dest_island][emigrant_index]
                        self.best_solution_overall = self.island_populations[dest_island][emigrant_index].copy()

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 5 (Overall AOCC Score on Multimodal instances with multiple components: 1.1137e-01# Name: IslandDifferentialEvolution
# Description: Implements an island model differential evolution algorithm with migration to tackle multimodal landscapes.
# Code:
```python
import numpy as np
import random


# Name: IslandDifferentialEvolution
# Description: Implements an island model differential evolution algorithm with migration to tackle multimodal landscapes.

class IslandDifferentialEvolution:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 differential_weight: float = 0.5, migration_interval: int = 500, migration_amount: int = 2):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.differential_weight = differential_weight
        self.migration_interval = migration_interval
        self.migration_amount = migration_amount

        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds,
                                            (self.population_size, self.dim))
            self.islands.append({
                'population': population,
                'fitness': np.full(self.population_size, float('inf')),
                'best_solution': None,
                'best_fitness': float('inf')
            })

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0  # Reset for this run
        if self.dim > 0:
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        else:
            self.best_solution_overall = np.array([])
        self.best_fitness_overall = float('inf')

        # Initialize island populations and evaluate fitness
        for island in self.islands:
            island['fitness'] = objective_function(island['population'])
            self.eval_count += self.population_size
            best_index = np.argmin(island['fitness'])
            island['best_solution'] = island['population'][best_index].copy()
            island['best_fitness'] = island['fitness'][best_index]

            if island['best_fitness'] < self.best_fitness_overall:
                self.best_fitness_overall = island['best_fitness']
                self.best_solution_overall = island['best_solution'].copy()

        generation = 0
        while self.eval_count < self.budget:
            generation += 1

            for i, island in enumerate(self.islands):
                new_population = np.zeros_like(island['population'])
                for j in range(self.population_size):
                    # Differential Evolution Mutation and Crossover
                    idxs = [idx for idx in range(self.population_size) if idx != j]
                    a, b, c = random.sample(idxs, 3)

                    mutant = island['population'][a] + self.differential_weight * (island['population'][b] - island['population'][c])
                    mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

                    trial_vector = np.zeros(self.dim)
                    for k in range(self.dim):
                        if random.random() < self.crossover_rate or k == random.randint(0, self.dim - 1):
                            trial_vector[k] = mutant[k]
                        else:
                            trial_vector[k] = island['population'][j][k]

                    new_population[j] = trial_vector

                # Evaluate new population
                new_fitness = objective_function(new_population)
                self.eval_count += self.population_size

                # Selection
                for j in range(self.population_size):
                    if new_fitness[j] < island['fitness'][j]:
                        island['population'][j] = new_population[j].copy()
                        island['fitness'][j] = new_fitness[j]

                        if new_fitness[j] < island['best_fitness']:
                            island['best_solution'] = island['population'][j].copy()
                            island['best_fitness'] = new_fitness[j]

                            if new_fitness[j] < self.best_fitness_overall:
                                self.best_fitness_overall = new_fitness[j]
                                self.best_solution_overall = island['population'][j].copy()

            # Migration
            if generation % self.migration_interval == 0:
                # Sort islands by best fitness
                sorted_islands = sorted(self.islands, key=lambda x: x['best_fitness'])

                # Migrate best individuals from top islands to worst islands
                for i in range(self.migration_amount):
                    source_island = sorted_islands[i]
                    target_island = sorted_islands[self.num_islands - 1 - i]

                    # Replace random individuals in the target island with copies of the best individuals from the source island
                    for _ in range(self.migration_amount):
                        replace_index = random.randint(0, self.population_size - 1)
                        target_island['population'][replace_index] = source_island['best_solution'].copy()
                        target_island['fitness'][replace_index] = objective_function(target_island['population'][replace_index:replace_index+1])[0] # Evaluate the migrated individual
                        self.eval_count += 1

                        if target_island['fitness'][replace_index] < target_island['best_fitness']:
                          target_island['best_fitness'] = target_island['fitness'][replace_index]
                          target_island['best_solution'] = target_island['population'][replace_index].copy()
                        
                    if self.eval_count >= self.budget:
                        break;  # Check budget after each migration step


        if self.best_solution_overall is None and self.dim > 0:  # Fallback
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
            self.best_fitness_overall = objective_function(self.best_solution_overall.reshape(1,-1))[0]
            self.eval_count += 1


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'num_islands': self.num_islands,
            'population_size': self.population_size,
            'crossover_rate': self.crossover_rate,
            'differential_weight': self.differential_weight,
            'migration_interval': self.migration_interval,
            'migration_amount': self.migration_amount
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 6 (Overall AOCC Score on Multimodal instances with multiple components: 4.0072e-02# Name: IslandModelDifferentialEvolution
# Description: Implements an island model differential evolution algorithm for exploring multimodal landscapes.
# Code:
```python
import numpy as np
import random

# Name: IslandModelDifferentialEvolution
# Description: Implements an island model differential evolution algorithm for exploring multimodal landscapes.
# Code:
class IslandModelDifferentialEvolution:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float], num_islands: int = 5, population_size: int = 50, crossover_rate: float = 0.7, mutation_rate: float = 0.5, migration_interval: int = 100, migration_size: int = 5):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size

        self.populations = []
        self.fitnesses = []
        self.best_solutions = []
        self.best_fitnesses = []

        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            self.populations.append(population)
            self.fitnesses.append(np.full(self.population_size, float('inf')))  # Initialize fitnesses
            self.best_solutions.append(None)
            self.best_fitnesses.append(float('inf'))

    def differential_evolution(self, population, fitnesses, objective_function):
        """Performs a single generation of differential evolution."""
        new_population = np.copy(population)
        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)

            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Selection
            trial_vector = trial_vector.reshape(1, -1) # Ensure correct shape for objective function
            trial_fitness = objective_function(trial_vector)[0]  # Evaluate only the new solution

            self.eval_count += 1 # Correct evaluation counter

            if trial_fitness < fitnesses[i]:
                new_population[i] = trial_vector
                fitnesses[i] = trial_fitness

        return new_population, fitnesses

    def migrate_individuals(self):
        """Migrates individuals between islands."""
        for i in range(self.num_islands):
            # Randomly select a target island
            target_island = random.choice([j for j in range(self.num_islands) if j != i])
            # Randomly select individuals to migrate
            migration_indices = random.sample(range(self.population_size), self.migration_size)

            # Replace worst individuals on target island with migrants
            migration_targets = np.argsort(self.fitnesses[target_island])[-self.migration_size:]
            for j, idx in enumerate(migration_indices):
                self.populations[target_island][migration_targets[j]] = np.copy(self.populations[i][idx])
                # Set fitness to inf, so it's re-evaluated in DE
                self.fitnesses[target_island][migration_targets[j]] = float('inf')



    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')


        for island_idx in range(self.num_islands):
            self.fitnesses[island_idx] = objective_function(self.populations[island_idx])  # Initial evaluation
            self.eval_count += self.population_size

            best_index = np.argmin(self.fitnesses[island_idx])
            self.best_solutions[island_idx] = np.copy(self.populations[island_idx][best_index])
            self.best_fitnesses[island_idx] = self.fitnesses[island_idx][best_index]

            if self.best_fitnesses[island_idx] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[island_idx]
                self.best_solution_overall = np.copy(self.best_solutions[island_idx])


        generation = 0
        while self.eval_count < self.budget:
            generation += 1
            for island_idx in range(self.num_islands):
                self.populations[island_idx], self.fitnesses[island_idx] = self.differential_evolution(self.populations[island_idx], self.fitnesses[island_idx], objective_function) # corrected
                best_index = np.argmin(self.fitnesses[island_idx])
                
                # Update island's best
                if self.fitnesses[island_idx][best_index] < self.best_fitnesses[island_idx]:
                    self.best_fitnesses[island_idx] = self.fitnesses[island_idx][best_index]
                    self.best_solutions[island_idx] = np.copy(self.populations[island_idx][best_index])

                # Update global best
                if self.best_fitnesses[island_idx] < self.best_fitness_overall:
                    self.best_fitness_overall = self.best_fitnesses[island_idx]
                    self.best_solution_overall = np.copy(self.best_solutions[island_idx])

            if generation % self.migration_interval == 0:
                self.migrate_individuals()

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'num_generations': generation
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 7 (Overall AOCC Score on Multimodal instances with multiple components: 1.3160e-02# Name: AdaptiveIslandModelDE
# Description: Uses a dynamic island model with Differential Evolution operators, adjusting island sizes and migration rates based on island performance.
# Code:
```python
import numpy as np
import random

# Name: AdaptiveIslandModelDE
# Description: Uses a dynamic island model with Differential Evolution operators, adjusting island sizes and migration rates based on island performance.
# Code:
class AdaptiveIslandModelDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.num_islands = 5
        self.island_size = 20  # Initial population size per island
        self.populations = []
        self.fitnesses = []
        self.best_solutions_island = []
        self.best_fitnesses_island = []

        self.migration_interval = 500  # Evaluations between migrations
        self.migration_rate = 0.1  # Proportion of each island to migrate
        self.island_sizes_history = []
        self.success_rate_history = []
        self.island_success_rates = [0.0] * self.num_islands # initial success rate for all islands

        # Initialize populations randomly
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.island_size, self.dim))
            self.populations.append(population)
            self.fitnesses.append(np.full(self.island_size, float('inf')))
            self.best_solutions_island.append(np.zeros(self.dim))  # Initialize with a vector
            self.best_fitnesses_island.append(float('inf'))

    def differential_evolution(self, population, fitnesses, objective_function, F=0.7, CR=0.9):
        """Standard Differential Evolution (DE) operator."""
        for i in range(len(population)):
            # Choose three distinct random indices, excluding the current index i
            idxs = [idx for idx in range(len(population)) if idx != i]
            a, b, c = population[np.random.choice(idxs, 3, replace=False)]

            # Mutation: Create a mutant vector
            mutant_vector = a + F * (b - c)

            # Crossover: Create a trial vector
            trial_vector = np.copy(population[i])
            j_rand = np.random.randint(self.dim) #randomly choose one index
            for j in range(self.dim):
                if np.random.rand() < CR or j == j_rand:
                    trial_vector[j] = mutant_vector[j]

            # Clip to boundaries
            trial_vector = np.clip(trial_vector, self.lower_bounds, self.upper_bounds)

            # Evaluate the trial vector
            trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]
            self.eval_count += 1

            # Selection: Replace if the trial vector is better
            if trial_fitness < fitnesses[i]:
                population[i] = trial_vector
                fitnesses[i] = trial_fitness
                return True # indicates success
        return False # indicates failure


    def migrate_individuals(self):
        """Migrates individuals between islands based on migration rate."""
        for i in range(self.num_islands):
            # Calculate the number of individuals to migrate *from* this island
            num_to_migrate = int(self.island_size * self.migration_rate)
            
            # Randomly select individuals to migrate
            indices_to_migrate = random.sample(range(self.island_size), num_to_migrate)
            migrants = self.populations[i][indices_to_migrate]
            
            # Choose a random destination island (excluding the current island)
            destination_island = random.choice([j for j in range(self.num_islands) if j != i])
            
            # Replace random individuals in the destination island with the migrants
            replace_indices = random.sample(range(self.island_size), num_to_migrate)
            self.populations[destination_island][replace_indices] = migrants
            # Re-evaluate fitness of destination island individuals
            self.fitnesses[destination_island][replace_indices] = np.array(objective_function(self.populations[destination_island][replace_indices]), dtype=float)


    def adjust_island_sizes(self):
        """Adjusts island sizes based on their success rates and a global budget constraint."""
        total_size = sum([len(pop) for pop in self.populations])
        max_size_island = self.budget
        
        # Calculate scores based on success rates
        success_scores = [rate for rate in self.island_success_rates]
                
        # Normalize the scores to get proportions
        total_score = sum(success_scores)
        if total_score > 0:
            proportions = [score / total_score for score in success_scores]
        else:
            proportions = [1 / self.num_islands for _ in range(self.num_islands)]  # Equal proportions if all rates are zero
                
        # Determine the new sizes based on the proportions, ensuring total population does not exceed budget
        new_island_sizes = [int(prop * self.budget) for prop in proportions]
                
        # Adjust population sizes
        for i in range(self.num_islands):
            current_size = len(self.populations[i])
            new_size = new_island_sizes[i]

            if new_size > current_size:
                # Add individuals to increase size
                num_to_add = min(new_size - current_size, max_size_island - current_size) # Added constraint to avoid overshooting maximum size
                new_individuals = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(num_to_add, self.dim))
                self.populations[i] = np.vstack([self.populations[i], new_individuals])
                self.fitnesses[i] = np.concatenate([self.fitnesses[i], np.full(num_to_add, float('inf'))])  # Initialize fitness values
            elif new_size < current_size:
                # Remove individuals to decrease size
                num_to_remove = current_size - new_size
                indices_to_remove = random.sample(range(current_size), num_to_remove)  # Remove randomly
                self.populations[i] = np.delete(self.populations[i], indices_to_remove, axis=0)
                self.fitnesses[i] = np.delete(self.fitnesses[i], indices_to_remove)

            self.island_size = len(self.populations[i])  # Update island size with the current size

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0  # Reset for this run
        if self.dim > 0:
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        else:
            self.best_solution_overall = np.array([])
        self.best_fitness_overall = float('inf')

        # Initial evaluation of islands
        for i in range(self.num_islands):
            fitnesses = objective_function(self.populations[i])
            self.eval_count += self.island_size
            self.fitnesses[i] = np.array(fitnesses, dtype=float) # ensure this is a float64 array to match the DE operators later

            # Find the best solution within this initial population
            best_index = np.argmin(self.fitnesses[i])
            self.best_solutions_island[i] = self.populations[i][best_index].copy() #Important to copy
            self.best_fitnesses_island[i] = self.fitnesses[i][best_index]

        while self.eval_count < self.budget:
            # Evolve each island
            success_counts = [0] * self.num_islands

            for i in range(self.num_islands):
                success = self.differential_evolution(self.populations[i], self.fitnesses[i], objective_function) # in-place update of populations and fitnesses

                # Find current best fitness on island to track and update island-local optimum
                current_best_index = np.argmin(self.fitnesses[i])
                current_best_fitness = self.fitnesses[i][current_best_index]
                current_best_solution = self.populations[i][current_best_index]

                # Update overall best solution
                if current_best_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = current_best_fitness
                    self.best_solution_overall = current_best_solution.copy()
               
                # Track the "success" rate on each island, for weighting purposes later
                success_counts[i] += 1 if success else 0

            # Periodically migrate individuals between islands
            if self.eval_count % self.migration_interval == 0:
                self.migrate_individuals()
                #after each migration, re-evaluate the local best fitness on each island as migrants are introduced
                for i in range(self.num_islands):
                    current_best_index = np.argmin(self.fitnesses[i])
                    self.best_solutions_island[i] = self.populations[i][current_best_index].copy()
                    self.best_fitnesses_island[i] = self.fitnesses[i][current_best_index]
            

            # Record the success rate for adjusting island size
            for i in range(self.num_islands): # Update the exponential moving average of the success rate
                success_rate = success_counts[i] / self.island_size # Compute rate this round
                self.island_success_rates[i] = 0.9 * self.island_success_rates[i] + 0.1 * success_rate
                
            # Periodically adjust island sizes
            if self.eval_count % (2 * self.migration_interval) == 0 and self.eval_count > 0:
                self.adjust_island_sizes()
                self.island_sizes_history.append([len(island) for island in self.populations]) # log this
                self.success_rate_history.append(self.island_success_rates) # log this

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'island_sizes_history': self.island_sizes_history,
            'island_success_rate_history': self.success_rate_history
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 8 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptivePopulationDE
# Description: Seed from AdaptivePopulationDE
# Code:
```python
import numpy as np
import random
# f18 aocc 0.8
# f20 aocc 0.5
# not so good again, get stuck in local optima
class AdaptivePopulationDE: 
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.population_size = 10 * self.dim
        self.min_population_size = 5 * self.dim
        self.max_population_size = 20 * self.dim
        self.population_adaptation_rate = 0.1

        self.F = 0.5  # Mutation factor
        self.Cr = 0.7 # Crossover rate

        self.stagnation_counter = 0
        self.stagnation_threshold = 5000

        self.archive = []
        self.archive_size = 100

        self.population = None
        self.fitness = None

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.stagnation_counter = 0

        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        self.fitness = objective_function(self.population)
        self.eval_count += self.population_size

        best_index = np.argmin(self.fitness)
        self.best_solution_overall = self.population[best_index]
        self.best_fitness_overall = self.fitness[best_index]

        while self.eval_count < self.budget:
            offspring = self.generate_offspring(objective_function)
            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            self.update_archive(offspring, offspring_fitness)

            for i in range(self.population_size):
                if offspring_fitness[i] < self.fitness[i]:
                    self.population[i] = offspring[i]
                    self.fitness[i] = offspring_fitness[i]

            best_index = np.argmin(self.fitness)
            if self.fitness[best_index] < self.best_fitness_overall:
                self.best_solution_overall = self.population[best_index]
                self.best_fitness_overall = self.fitness[best_index]
                self.stagnation_counter = 0
            else:
                self.stagnation_counter += len(offspring)

            self.adjust_population_size(objective_function)

            if self.stagnation_counter > self.stagnation_threshold:
                self.restart_population(objective_function)
                self.stagnation_counter = 0

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'population_size': self.population_size
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def generate_offspring(self, objective_function):
        offspring = np.zeros((self.population_size, self.dim))

        for i in range(self.population_size):
            indices = list(range(self.population_size))
            indices.remove(i)
            if len(indices) < 2:
                continue  # Skip if not enough individuals

            a, b = random.sample(indices, 2)

            if self.archive and random.random() < 0.5:
                pbest = self.archive[random.randint(0, len(self.archive) - 1)][0]
            else:
                pbest = self.population[np.argmin(self.fitness)]

            mutant = self.population[i] + self.F * (pbest - self.population[i] + self.population[a] - self.population[b])

            for j in range(self.dim):
                if random.random() > self.Cr:
                    mutant[j] = self.population[i][j]

            offspring[i] = np.clip(mutant, self.lower_bounds, self.upper_bounds)

        return offspring

    def update_archive(self, offspring, offspring_fitness):
        for i in range(len(offspring)):
            if len(self.archive) < self.archive_size:
                self.archive.append((offspring[i], offspring_fitness[i]))
            else:
                worst_index = np.argmax([f for _, f in self.archive])
                if offspring_fitness[i] < self.archive[worst_index][1] or len(self.archive) < self.archive_size * 0.8:
                    self.archive[worst_index] = (offspring[i], offspring_fitness[i])

    def adjust_population_size(self, objective_function):
        if random.random() < self.population_adaptation_rate:
            if self.stagnation_counter > self.stagnation_threshold / 2:
                new_size = min(int(self.population_size * 1.1), self.max_population_size)
            else:
                new_size = max(int(self.population_size * 0.9), self.min_population_size)

            new_size = int(new_size)
            if new_size > self.population_size:
                additional = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(new_size - self.population_size, self.dim))
                additional_fitness = objective_function(additional)
                self.population = np.vstack((self.population, additional))
                self.fitness = np.concatenate((self.fitness, additional_fitness))
                self.eval_count += len(additional)
            elif new_size < self.population_size:
                best_indices = np.argsort(self.fitness)[:new_size]
                self.population = self.population[best_indices]
                self.fitness = self.fitness[best_indices]

            self.population_size = new_size

    def restart_population(self, objective_function):
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        self.fitness = objective_function(self.population)
        self.eval_count += self.population_size
        best_index = np.argmin(self.fitness)
        if self.fitness[best_index] < self.best_fitness_overall:
            self.best_solution_overall = self.population[best_index]
            self.best_fitness_overall = self.fitness[best_index]
```

### Rank 9 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: IslandDifferentialEvolution
# Description: A multi-island differential evolution algorithm with periodic migration to promote exploration of multimodal landscapes.
# Code:
```python
import numpy as np
import random

# Name: IslandDifferentialEvolution
# Description: A multi-island differential evolution algorithm with periodic migration to promote exploration of multimodal landscapes.
# Code:
class IslandDifferentialEvolution:
    """
    A multi-island differential evolution algorithm with periodic migration to 
    promote exploration of multimodal landscapes.
    """

    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float], num_islands: int = 5, pop_size: int = 20,
                 mutation_rate: float = 0.5, crossover_rate: float = 0.7, migration_interval: int = 500, migration_size: int = 2):
        """
        Initializes the IslandDifferentialEvolution algorithm.

        Args:
            budget (int): The total function evaluation budget.
            dim (int): The dimensionality of the problem.
            lower_bounds (list[float]): The lower bounds of the search space.
            upper_bounds (list[float]): The upper bounds of the search space.
            num_islands (int, optional): The number of islands to use. Defaults to 5.
            pop_size (int, optional): The population size of each island. Defaults to 20.
            mutation_rate (float, optional): The mutation rate for DE. Defaults to 0.5.
            crossover_rate (float, optional): The crossover rate for DE. Defaults to 0.7.
            migration_interval (int, optional): The number of evaluations between migrations. Defaults to 500.
            migration_size (int, optional): The number of individuals to migrate. Defaults to 2.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.pop_size = pop_size
        self.mutation_rate = mutation_rate
        self.crossover_rate = crossover_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize islands
        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.pop_size, self.dim))
            self.islands.append({
                'population': population,
                'fitness': np.full(self.pop_size, float('inf')),
                'best_solution': None,
                'best_fitness': float('inf')
            })

    def differential_evolution(self, island, objective_function):
        """
        Performs one generation of differential evolution on a single island.

        Args:
            island (dict): The island data structure.
            objective_function (callable): The objective function to evaluate.
        """
        population = island['population']
        fitness = island['fitness']

        for i in range(self.pop_size):
            # Mutation
            indices = list(range(self.pop_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)

            mutant = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

            # Crossover
            trial = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial[j] = mutant[j]

            # Evaluation
            trial_fitness = objective_function(trial.reshape(1, -1))[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness[i]:
                population[i] = trial
                fitness[i] = trial_fitness

                # Update island best
                if trial_fitness < island['best_fitness']:
                    island['best_fitness'] = trial_fitness
                    island['best_solution'] = trial
        
        island['population'] = population
        island['fitness'] = fitness


    def migrate(self):
        """
        Migrates individuals between islands.
        """
        # Select islands for migration (e.g., randomly)
        island_indices = random.sample(range(self.num_islands), 2)  # Choose two islands
        island1_idx, island2_idx = island_indices[0], island_indices[1]

        island1 = self.islands[island1_idx]
        island2 = self.islands[island2_idx]

        # Select individuals for migration (e.g., best individuals)
        immigrants_idx1 = np.argsort(island1['fitness'])[:self.migration_size] # Best individuals on island 1
        immigrants_idx2 = np.argsort(island2['fitness'])[:self.migration_size] # Best individuals on island 2

        immigrants1 = island1['population'][immigrants_idx1].copy()
        immigrants2 = island2['population'][immigrants_idx2].copy()
        
        #Replace worst individuals on the islands receiving immigrants

        emigrants_idx1 = np.argsort(island1['fitness'])[-self.migration_size:] # Worst individuals on island 1 to be replaced
        emigrants_idx2 = np.argsort(island2['fitness'])[-self.migration_size:] # Worst individuals on island 2 to be replaced
    
        island1['population'][emigrants_idx1] = immigrants2
        island2['population'][emigrants_idx2] = immigrants1

        # Re-evaluate fitness of migrated individuals (can be skipped if fitness is maintained). In this example it's skipped.
        
        # Update island fitnesses - no evaluation is done here, the island optimization will perform evaluation steps.
        island1['fitness'][emigrants_idx1] = np.full(self.migration_size, float('inf')) # reset the fitness to re-evaluate during DE
        island2['fitness'][emigrants_idx2] = np.full(self.migration_size, float('inf')) # reset the fitness to re-evaluate during DE

        #Update island bests
        if island1['best_fitness'] > np.min(island1['fitness']):
              best_index = np.argmin(island1['fitness'])
              island1['best_fitness'] = island1['fitness'][best_index]
              island1['best_solution'] = island1['population'][best_index]

        if island2['best_fitness'] > np.min(island2['fitness']):
              best_index = np.argmin(island2['fitness'])
              island2['best_fitness'] = island2['fitness'][best_index]
              island2['best_solution'] = island2['population'][best_index]


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the objective function using the island differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float, optional): The acceptance threshold for early stopping. Defaults to 1e-8.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        if self.dim > 0:
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        else:
            self.best_solution_overall = np.array([])
        self.best_fitness_overall = float('inf')

        while self.eval_count < self.budget:
            # Evolve each island
            for island in self.islands:
                self.differential_evolution(island, objective_function)

                # Update overall best
                if island['best_fitness'] < self.best_fitness_overall:
                    self.best_fitness_overall = island['best_fitness']
                    self.best_solution_overall = island['best_solution']

                if self.best_fitness_overall < acceptance_threshold:
                  break # Exit if solution found.

            # Migrate individuals
            if self.eval_count % self.migration_interval == 0:
                self.migrate()

            if self.best_fitness_overall < acceptance_threshold:
                  break # Exit if solution found.


        if self.best_solution_overall is None and self.dim > 0:  # Fallback
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
            self.best_fitness_overall = objective_function(self.best_solution_overall.reshape(1, -1))[0]
            self.eval_count +=1

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 10 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: IslandModelDifferentialEvolution
# Description: Employs an island model with differential evolution on each island and periodic migration to enhance exploration of multimodal landscapes.
# Code:
```python
import numpy as np
import random

# Name: IslandModelDifferentialEvolution
# Description: Employs an island model with differential evolution on each island and periodic migration to enhance exploration of multimodal landscapes.
# Code:
class IslandModelDifferentialEvolution:
    """
    Implements an island model-based differential evolution algorithm to address multimodal optimization problems.
    Multiple independent populations (islands) evolve concurrently, exchanging individuals periodically to
    maintain diversity and prevent premature convergence to local optima. This promotes global exploration.
    """
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 4, population_size: int = 25, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 500, migration_size: int = 5):
        """
        Initializes the IslandModelDifferentialEvolution algorithm.

        Args:
            budget (int): The maximum number of function evaluations allowed.
            dim (int): The dimensionality of the search space.
            lower_bounds (list[float]): A list of lower bounds for each dimension.
            upper_bounds (list[float]): A list of upper bounds for each dimension.
            num_islands (int): The number of isolated populations (islands).  Defaults to 4.
            population_size (int): The number of individuals in each island. Defaults to 25.
            crossover_rate (float): The probability of crossover in differential evolution. Defaults to 0.7.
            mutation_rate (float): The mutation factor in differential evolution (F). Defaults to 0.5.
            migration_interval (int): The number of evaluations between migrations. Defaults to 500.
            migration_size (int): The number of individuals to migrate between islands. Defaults to 5.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        self.populations = []
        self.fitness_values = []

        # Initialize populations for each island
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            self.populations.append(population)
            self.fitness_values.append(np.full(self.population_size, float('inf')))  # Initialize fitness

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Performs optimization using the island model differential evolution strategy.

        Args:
            objective_function (callable): The objective function to minimize.
            acceptance_threshold (float): Tolerance to determine convergence. Defaults to 1e-8.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset evaluation count for this run
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Evaluate initial populations
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size

            # Update the global best if needed
            best_index = np.argmin(self.fitness_values[i])
            if self.fitness_values[i][best_index] < self.best_fitness_overall:
                self.best_fitness_overall = self.fitness_values[i][best_index]
                self.best_solution_overall = self.populations[i][best_index].copy()


        while self.eval_count < self.budget:
            for i in range(self.num_islands):  # Process each island independently
                for j in range(self.population_size):  # Evolve each individual in the population

                    # Differential Evolution mutation: select three distinct random indices
                    indices = random.sample(range(self.population_size), 3)
                    while j in indices:
                        indices = random.sample(range(self.population_size), 3)  # Ensure j is not in indices

                    x_r1, x_r2, x_r3 = self.populations[i][indices[0]], self.populations[i][indices[1]], self.populations[i][indices[2]]

                    # Mutation
                    v_ij = self.populations[i][j] + self.mutation_rate * (x_r2 - x_r3)

                    # Crossover
                    u_ij = np.where(np.random.rand(self.dim) < self.crossover_rate, v_ij, self.populations[i][j])  # Ensure a vector


                    # Clip to bounds
                    u_ij = np.clip(u_ij, self.lower_bounds, self.upper_bounds)


                    # Evaluate the trial vector
                    f_uij = objective_function(u_ij.reshape(1, -1))[0]  # Reshape to 2D for single evaluation
                    self.eval_count += 1

                    # Selection
                    if f_uij < self.fitness_values[i][j]:
                        self.fitness_values[i][j] = f_uij
                        self.populations[i][j] = u_ij

                        # Update the global best
                        if f_uij < self.best_fitness_overall:
                            self.best_fitness_overall = f_uij
                            self.best_solution_overall = u_ij.copy()

            # Migration step
            if self.eval_count // self.migration_interval > (self.eval_count - self.population_size) // self.migration_interval :  # Migrate only every migration_interval evaluations
                self.migrate_individuals()  # Perform individual migration

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'num_islands': self.num_islands,
            'population_size': self.population_size,
            'crossover_rate': self.crossover_rate,
            'mutation_rate': self.mutation_rate,
            'migration_interval': self.migration_interval,
            'migration_size': self.migration_size
        }

        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def migrate_individuals(self):
          """
          Migrates individuals between islands to promote diversity.  Randomly selects 'migration_size' individuals
          from each island, and swaps them with individuals selected from other random islands.
          """
          for i in range(self.num_islands):
            # Select migration_size individuals from island i
            migration_indices = random.sample(range(self.population_size), self.migration_size)

            # Select a different random island to migrate to
            destination_island = random.choice([x for x in range(self.num_islands) if x != i])

            # Select migration_size individuals from the destination island
            destination_indices = random.sample(range(self.population_size), self.migration_size)

            # Swap the individuals
            temp_migrants = self.populations[i][migration_indices].copy()  # Temporarily store migrants

            self.populations[i][migration_indices] = self.populations[destination_island][destination_indices].copy()
            self.populations[destination_island][destination_indices] = temp_migrants

            # Update fitness values by re-evaluating migrants
            self.fitness_values[i][migration_indices] = np.array([objective_function(x.reshape(1,-1))[0] for x in self.populations[i][migration_indices]])
            self.fitness_values[destination_island][destination_indices] = np.array([objective_function(x.reshape(1, -1))[0] for x in self.populations[destination_island][destination_indices]])

            self.eval_count += 2 * self.migration_size
```

### Rank 11 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: IslandParallelEA
# Description: Employs an island model evolutionary algorithm with periodic migration to explore multimodal landscapes.
# Code:
```python
import numpy as np
import random


# Name: IslandParallelEA
# Description: Employs an island model evolutionary algorithm with periodic migration to explore multimodal landscapes.
# Code:
class IslandParallelEA:
    """
    Implements an island model evolutionary algorithm to optimize functions, 
    especially those with multiple local optima.  It utilizes parallel islands that evolve independently 
    and exchange solutions periodically to promote global exploration.
    """

    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 4, population_size: int = 50, mutation_rate: float = 0.1,
                 crossover_rate: float = 0.7, migration_interval: int = 100, migration_size: int = 5):
        """
        Initializes the IslandParallelEA optimizer.

        Args:
            budget (int): Total function evaluation budget.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): Lower bounds of the search space.
            upper_bounds (list[float]): Upper bounds of the search space.
            num_islands (int): Number of independent populations (islands).
            population_size (int): Number of individuals in each island's population.
            mutation_rate (float): Probability of mutating each gene.
            crossover_rate (float): Probability of performing crossover between parents.
            migration_interval (int): Interval (in evaluations) at which migration occurs.
            migration_size (int): Number of individuals to migrate between islands.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.num_islands = num_islands
        self.population_size = population_size
        self.mutation_rate = mutation_rate
        self.crossover_rate = crossover_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize islands: Each island has a population of random solutions.
        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds,
                                            size=(self.population_size, self.dim))
            self.islands.append(population)
        self.island_best_solutions = [None] * self.num_islands
        self.island_best_fitnesses = [float('inf')] * self.num_islands

    def _evaluate_population(self, objective_function: callable, population: np.ndarray) -> np.ndarray:
        """
        Evaluates the fitness of each individual in a population.

        Args:
            objective_function (callable): The objective function to evaluate.
            population (np.ndarray): A 2D NumPy array representing the population.

        Returns:
            np.ndarray: A 1D NumPy array of fitness values.
        """
        fitness_values = objective_function(population)
        self.eval_count += len(population)
        return fitness_values

    def _selection(self, population: np.ndarray, fitness_values: np.ndarray, num_parents: int) -> np.ndarray:
        """
        Performs tournament selection to select parents for crossover.

        Args:
            population (np.ndarray): The population to select from.
            fitness_values (np.ndarray): Fitness values for each individual in the population.
            num_parents (int): The number of parents to select.

        Returns:
            np.ndarray: An array of selected parents.
        """
        selected_indices = []
        for _ in range(num_parents):
            # Tournament size is set to 2 here. Larger values make it more selective
            tournament_indices = random.sample(range(len(population)), 2)
            if fitness_values[tournament_indices[0]] < fitness_values[tournament_indices[1]]:
                selected_indices.append(tournament_indices[0])
            else:
                selected_indices.append(tournament_indices[1])
        return population[selected_indices]

    def _crossover(self, parents: np.ndarray) -> np.ndarray:
        """
        Performs uniform crossover to create offspring.

        Args:
            parents (np.ndarray): The parents to crossover.

        Returns:
            np.ndarray: The offspring resulting from crossover.
        """
        num_parents = len(parents)
        offspring = np.empty_like(parents[0])
        for i in range(self.dim):
            if random.random() < self.crossover_rate:
                # Uniform crossover: each gene is randomly inherited from one of the parents.
                parent_index = random.randint(0, num_parents - 1)
                offspring[i] = parents[parent_index][i]
            else:
                offspring[i] = parents[0][i]  # Otherwise, inherit from the first parent.
        return offspring

    def _mutation(self, individual: np.ndarray) -> np.ndarray:
        """
        Applies mutation to an individual.

        Args:
            individual (np.ndarray): The individual to mutate.

        Returns:
            np.ndarray: The mutated individual.
        """
        mutated_individual = individual.copy()
        for i in range(self.dim):
            if random.random() < self.mutation_rate:
                # Apply random perturbation within bounds
                mutation_amount = random.uniform(-1, 1) * (self.upper_bounds[i] - self.lower_bounds[i]) * 0.1  # Scale perturbation
                mutated_individual[i] += mutation_amount
                # Clip to bounds
                mutated_individual[i] = np.clip(mutated_individual[i], self.lower_bounds[i], self.upper_bounds[i])
        return mutated_individual

    def _migrate(self):
        """
        Migrates individuals between islands.  Selects the best individuals from one island
        and replaces the worst individuals on another randomly chosen island.
        """
        for i in range(self.num_islands):
            # Select random source and destination islands (must be different).
            source_island_index = i
            destination_island_index = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best individuals in the source island.
            source_fitness = self._evaluate_population(lambda x: x, self.islands[source_island_index])  # Dummy objective
            best_indices = np.argsort(source_fitness)[:self.migration_size]
            migrants = self.islands[source_island_index][best_indices]

            # Identify the worst individuals in the destination island
            destination_fitness = self._evaluate_population(lambda x: x, self.islands[destination_island_index])  # Dummy objective
            worst_indices = np.argsort(destination_fitness)[-self.migration_size:]

            # Replace the worst individuals in the destination island with the migrants.
            self.islands[destination_island_index][worst_indices] = migrants
    
    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Runs the island model evolutionary algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Stop the optimization when this fitness is reached.

        Returns:
            tuple: (best_solution, best_fitness, optimization_info)
        """
        self.eval_count = 0  # Reset for this run
        for island_index in range(self.num_islands):
            self.island_best_solutions[island_index] = None
        self.best_fitness_overall = float('inf')

        generation = 0
        while self.eval_count < self.budget:
            generation += 1
            for island_index in range(self.num_islands):
                # Evaluate the current population
                fitness_values = self._evaluate_population(objective_function, self.islands[island_index])

                # Update best solution for this island
                best_index = np.argmin(fitness_values)
                if fitness_values[best_index] < self.island_best_fitnesses[island_index]:
                    self.island_best_fitnesses[island_index] = fitness_values[best_index]
                    self.island_best_solutions[island_index] = self.islands[island_index][best_index].copy()

                    # Update overall best solution
                    if fitness_values[best_index] < self.best_fitness_overall:
                        self.best_fitness_overall = fitness_values[best_index]
                        self.best_solution_overall = self.islands[island_index][best_index].copy()

                if self.best_fitness_overall <= acceptance_threshold:
                    break  # Early stopping

                # Selection: select parents for crossover
                parents = self._selection(self.islands[island_index], fitness_values, self.population_size)

                # Crossover and Mutation to create the new population
                new_population = np.empty_like(self.islands[island_index])
                for i in range(self.population_size):
                    offspring = self._crossover(parents)
                    offspring = self._mutation(offspring)
                    new_population[i] = offspring

                self.islands[island_index] = new_population
            
            # Migration
            if generation % self.migration_interval == 0:
                self._migrate()

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'generations': generation
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 12 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptiveIslandGA
# Description: Employs an island model with adaptive migration rates to explore multiple basins, with a genetic algorithm on each island.
# Code:
```python
import numpy as np
import random

# Name: AdaptiveIslandGA
# Description: Employs an island model with adaptive migration rates to explore multiple basins, with a genetic algorithm on each island.
# Code:
class AdaptiveIslandGA:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float], num_islands: int = 5, population_size: int = 50, crossover_rate: float = 0.9, mutation_rate: float = 0.1):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize islands and populations
        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            self.islands.append({'population': population, 'best_solution': None, 'best_fitness': float('inf'), 'migration_rate': 0.05})  # Initial migration rate

    def evaluate_population(self, objective_function: callable, population: np.ndarray) -> np.ndarray:
        """Evaluates the fitness of a population, tracking function evaluations."""
        fitness_values = objective_function(population)
        self.eval_count += len(fitness_values)
        return fitness_values
    
    def selection(self, population: np.ndarray, fitness_values: np.ndarray, num_parents: int):
         """Selects individuals based on fitness (using tournament selection)."""
         selected_indices = []
         for _ in range(num_parents):
                tournament_indices = np.random.choice(len(population), 5, replace=False) #Tournament Size of 5
                tournament_fitnesses = fitness_values[tournament_indices]
                winner_index = tournament_indices[np.argmin(tournament_fitnesses)]
                selected_indices.append(winner_index)

         return population[selected_indices]

    def crossover(self, parents: np.ndarray) -> np.ndarray:
        """Performs crossover (uniform) on a set of parents to create offspring."""
        num_parents = len(parents)
        offspring = np.empty_like(parents)
        for i in range(0, num_parents, 2):
            if i + 1 < num_parents and random.random() < self.crossover_rate: # apply crossover to pairs of parents
                mask = np.random.rand(self.dim) < 0.5
                offspring[i] = np.where(mask, parents[i], parents[i+1])
                offspring[i+1] = np.where(mask, parents[i+1], parents[i])
            else:
                offspring[i] = parents[i]
                if i + 1 < num_parents:
                    offspring[i + 1] = parents[i + 1]
        return offspring
    
    def mutation(self, offspring: np.ndarray) -> np.ndarray:
        """Applies mutation to the offspring."""
        for i in range(len(offspring)):
            if random.random() < self.mutation_rate:
                mutation_indices = np.random.choice(self.dim, int(0.1 * self.dim), replace=False)  # Mutate 10% of genes
                for index in mutation_indices:
                        offspring[i, index] = np.random.uniform(self.lower_bounds[index], self.upper_bounds[index])

        return offspring

    def migrate(self):
      """Migrates individuals between islands, adapting migration rate."""
      for i in range(self.num_islands):
          if random.random() < self.islands[i]['migration_rate']:
              #Choose a random individual to migrate.
              immigrant_index = np.random.randint(self.population_size)
              immigrant = self.islands[i]['population'][immigrant_index].copy() #Crucial: make a copy

              #Choose random island to migrate to (excluding the current island)
              target_island_index = (i + np.random.randint(1, self.num_islands)) % self.num_islands
              
              #Replace a random individual on target island with the migrating individual
              resident_index = np.random.randint(self.population_size)

              self.islands[target_island_index]['population'][resident_index] = immigrant
    
    def adapt_migration_rates(self):
          """Adapts migration rates based on island performance.  Islands with lower best fitness have lower migration rate (less information shared)."""

          fitnesses = [island['best_fitness'] for island in self.islands]
          min_fitness = min(fitnesses)

          for i in range(self.num_islands):
                if fitnesses[i] != float('inf'):
                     self.islands[i]['migration_rate'] = 0.05 * (1 - (fitnesses[i] - min_fitness) / (fitnesses[i] + min_fitness + 1e-8))  #migration rate between 0 and 0.05
                else:
                     self.islands[i]['migration_rate'] = 0.05


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0  # Reset for this run
        if self.dim > 0:
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        else:
            self.best_solution_overall = np.array([])
        self.best_fitness_overall = float('inf')

        generations = 0
        while self.eval_count < self.budget:
            generations += 1

            for island_idx in range(self.num_islands):
                island = self.islands[island_idx]
                population = island['population']

                # Evaluate population
                fitness_values = self.evaluate_population(objective_function, population)

                # Update island's best solution
                best_index = np.argmin(fitness_values)
                if fitness_values[best_index] < island['best_fitness']:
                    island['best_fitness'] = fitness_values[best_index]
                    island['best_solution'] = population[best_index].copy()
                    self.islands[island_idx] = island

                    # Update overall best solution
                    if island['best_fitness'] < self.best_fitness_overall:
                        self.best_fitness_overall = island['best_fitness']
                        self.best_solution_overall = island['best_solution'].copy()
                        #print(f"New global best {self.best_fitness_overall} at {self.eval_count} evals")

                # Selection
                parents = self.selection(population, fitness_values, self.population_size)
                
                # Crossover
                offspring = self.crossover(parents)

                # Mutation
                offspring = self.mutation(offspring)

                # Replace old population with new population
                self.islands[island_idx]['population'] = offspring

            # Migration
            self.migrate()
            self.adapt_migration_rates()


        if self.best_solution_overall is None and self.dim > 0:  # Fallback
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
            self.best_fitness_overall = objective_function(self.best_solution_overall.reshape(1, -1))[0]
            self.eval_count += 1

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'generations': generations,
            'num_islands': self.num_islands
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 13 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: IslandModelDifferentialEvolution
# Description: Implements a parallel differential evolution algorithm with an island model for escaping local optima in multimodal landscapes.
# Code:
```python
import numpy as np
import random


# Name: IslandModelDifferentialEvolution
# Description: Implements a parallel differential evolution algorithm with an island model for escaping local optima in multimodal landscapes.
# Code:
class IslandModelDifferentialEvolution:
    """
    A differential evolution algorithm using an island model to aggressively explore the search space and escape local optima,
    especially suited for deceptive, multi-component landscapes like GNBG f16-f24.  Migration between islands helps introduce diversity and
    prevents premature convergence.
    """

    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        """
        Initializes the IslandModelDifferentialEvolution optimizer.

        Args:
            budget: Max function evaluations.
            dim: Problem dimensionality.
            lower_bounds: List of lower bounds for each variable.
            upper_bounds: List of upper bounds for each variable.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Island Model parameters
        self.num_islands = 5  # Number of isolated populations
        self.population_size = 40  # Population size for each island
        self.migration_interval = 500 # How often migration occurs (function evaluations)
        self.migration_amount = 5  # Number of individuals to migrate
        self.migration_policy = "random" # Policy to select migrants: "best", "random"

        # Differential Evolution parameters
        self.F = 0.7  # Mutation factor
        self.CR = 0.9  # Crossover rate

        # Initialize islands with populations
        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            self.islands.append(population)

        self.island_fitnesses = [np.zeros(self.population_size) for _ in range(self.num_islands)]
        self.island_best_solutions = [None] * self.num_islands
        self.island_best_fitnesses = [float('inf')] * self.num_islands

        # Initialize best solution for each island on class init
        for i in range(self.num_islands):
            self.island_best_solutions[i] = self.islands[i][0].copy() # Arbitrary
        
    def _evaluate_population(self, objective_function: callable, population: np.ndarray) -> np.ndarray:
        """Evaluates the fitness of a population and increments the evaluation counter."""
        fitness_values = objective_function(population)
        self.eval_count += len(fitness_values)
        return fitness_values

    def _differential_evolution_step(self, objective_function: callable, population: np.ndarray, island_index: int) -> None:
        """Performs one step of differential evolution for a single island."""
        new_population = np.copy(population)
        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3) # Correctly sample indices

            mutant = population[a] + self.F * (population[b] - population[c])
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)  # Keep solutions within bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.CR:
                    trial_vector[j] = mutant[j]

            trial_vector = np.clip(trial_vector, self.lower_bounds, self.upper_bounds) # Ensure bounds

            # Selection
            trial_fitness = objective_function(trial_vector.reshape(1, -1))[0] # Reshape for correct objective function input
            self.eval_count += 1

            if trial_fitness < self.island_fitnesses[island_index][i]:
                new_population[i] = trial_vector
                self.island_fitnesses[island_index][i] = trial_fitness

                # Update island best
                if trial_fitness < self.island_best_fitnesses[island_index]:
                    self.island_best_fitnesses[island_index] = trial_fitness
                    self.island_best_solutions[island_index] = trial_vector.copy()

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector.copy()

        return new_population # Return the evolved population.



    def _migrate(self):
        """Migrates individuals between islands to promote diversity."""
        # Choose source and destination islands
        source_island_index = random.randint(0, self.num_islands - 1)
        destination_island_index = random.randint(0, self.num_islands - 1)
        while destination_island_index == source_island_index:
            destination_island_index = random.randint(0, self.num_islands - 1)

        # Select migrants
        if self.migration_policy == "best":
            migrant_indices = np.argsort(self.island_fitnesses[source_island_index])[:self.migration_amount]
        elif self.migration_policy == "random":
            migrant_indices = random.sample(range(self.population_size), self.migration_amount)
        else:
            raise ValueError("Invalid migration policy.")

        migrants = self.islands[source_island_index][migrant_indices]

        # Replace individuals in the destination island
        replace_indices = random.sample(range(self.population_size), self.migration_amount)
        self.islands[destination_island_index][replace_indices] = migrants

        # Re-evaluate the fitnesses of the replaced individuals
        replaced_fitnesses = self._evaluate_population(
            lambda x: objective_function(x), self.islands[destination_island_index][replace_indices]
        )
        for i, idx in enumerate(replace_indices):
            self.island_fitnesses[destination_island_index][idx] = replaced_fitnesses[i]

            # Check if migrants improved the destination island
            if replaced_fitnesses[i] < self.island_best_fitnesses[destination_island_index]:
                self.island_best_fitnesses[destination_island_index] = replaced_fitnesses[i]
                self.island_best_solutions[destination_island_index] = self.islands[destination_island_index][idx].copy()
        
        # Update overall best from new destination individuals
        if replaced_fitnesses[i] < self.best_fitness_overall:
              self.best_fitness_overall = replaced_fitnesses[i]
              self.best_solution_overall = self.islands[destination_island_index][idx].copy()



    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution strategy.

        Args:
            objective_function: The function to minimize. Accepts a 2D NumPy array of solutions and returns a 1D NumPy array of fitnesses.
            acceptance_threshold:  Unused.

        Returns:
            A tuple containing:
                - best_solution_1D_numpy_array: The best solution found.
                - best_fitness_scalar: The fitness of the best solution.
                - optimization_info_dict: A dictionary containing optimization information.
        """
        self.eval_count = 0  # Reset evaluation count for this run
        self.best_fitness_overall = float('inf')
        
        # Initialize best solution for each island
        for i in range(self.num_islands):
          fitnesses = self._evaluate_population(objective_function, self.islands[i])
          self.island_fitnesses[i] = fitnesses
          best_index = np.argmin(fitnesses)
          self.island_best_fitnesses[i] = fitnesses[best_index]
          self.island_best_solutions[i] = self.islands[i][best_index].copy()

          #Update global if the new island individuals is better
          if self.island_best_fitnesses[i] < self.best_fitness_overall:
               self.best_fitness_overall = self.island_best_fitnesses[i]
               self.best_solution_overall = self.island_best_solutions[i].copy()

        # Main optimization loop
        while self.eval_count < self.budget:
            # Evolve each island independently
            for i in range(self.num_islands):
                self.islands[i] = self._differential_evolution_step(objective_function, self.islands[i], i)
            
            # Migration
            if self.eval_count % self.migration_interval < self.num_islands * self.population_size/2 and self.eval_count > self.num_islands * self.population_size: # Check before migration
                self._migrate() # Migrate between islands

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }

        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 14 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: IslandDifferentialEvolution
# Description: An island model differential evolution algorithm that uses periodic migration to promote diversity and escape local optima.
# Code:
```python
import numpy as np
import random

# Name: IslandDifferentialEvolution
# Description: An island model differential evolution algorithm that uses periodic migration to promote diversity and escape local optima.
# Code:
class IslandDifferentialEvolution:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float], num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7, differential_weight: float = 0.8, migration_interval: int = 500, elite_pct: float = 0.1):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.differential_weight = differential_weight
        self.migration_interval = migration_interval
        self.elite_pct = elite_pct
        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            self.islands.append({
                'population': population,
                'fitness': np.full(self.population_size, float('inf')),
                'best_solution': None,
                'best_fitness': float('inf')
            })

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        if self.dim > 0:
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        else:
            self.best_solution_overall = np.array([])
        self.best_fitness_overall = float('inf')

        generation = 0
        while self.eval_count < self.budget:
            generation += 1
            for i in range(self.num_islands):
                self.evolve_island(i, objective_function)

                # Update overall best solution
                if self.islands[i]['best_fitness'] < self.best_fitness_overall:
                    self.best_fitness_overall = self.islands[i]['best_fitness']
                    self.best_solution_overall = self.islands[i]['best_solution'].copy() # Important: copy the numpy array

            # Migration
            if generation * self.population_size * self.num_islands % self.migration_interval == 0:
                self.migrate()

        if self.best_solution_overall is None and self.dim > 0:  # Fallback
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
            fitness_value = objective_function(self.best_solution_overall.reshape(1, -1))[0]
            self.eval_count += 1
            self.best_fitness_overall = fitness_value


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'num_islands': self.num_islands,
            'population_size': self.population_size
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def evolve_island(self, island_index: int, objective_function: callable):
        island = self.islands[island_index]
        population = island['population']
        fitness = island['fitness']

        for i in range(self.population_size):
            # Differential Evolution mutation and crossover
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)

            mutant = population[a] + self.differential_weight * (population[b] - population[c])
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)  # Clip to boundaries

            trial_vector = np.zeros(self.dim)
            for j in range(self.dim):
                if random.random() < self.crossover_rate or j == random.randint(0, self.dim - 1):
                    trial_vector[j] = mutant[j]
                else:
                    trial_vector[j] = population[i][j]

            trial_vector = np.clip(trial_vector, self.lower_bounds, self.upper_bounds)

            # Evaluation
            trial_fitness = objective_function(trial_vector.reshape(1, -1))[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness[i]:
                population[i] = trial_vector
                fitness[i] = trial_fitness

                # Update island best
                if trial_fitness < island['best_fitness']:
                    island['best_fitness'] = trial_fitness
                    island['best_solution'] = trial_vector.copy()

        # Store updated population and fitness
        island['population'] = population
        island['fitness'] = fitness
        self.islands[island_index] = island # Redundant but emphasizes

    def migrate(self):
        # Select the elite individuals from each island
        elites = []
        for i in range(self.num_islands):
            island = self.islands[i]
            num_elites = int(self.elite_pct * self.population_size)
            elite_indices = np.argsort(island['fitness'])[:num_elites]
            elites.append(island['population'][elite_indices])

        # Migrate elites to other islands
        for i in range(self.num_islands):
            island = self.islands[i]
            # Replace some random individuals from current island with migrants from other islands
            num_migrants = int(self.elite_pct * self.population_size)
            replace_indices = random.sample(range(self.population_size), num_migrants)

            # Pick migrants from the other islands. Simplified for this example and picks uniformly across
            # all the available elites from all the other islands.

            #Create a list of all other elites, excluding the elites from current island
            other_elites = []
            for j in range(self.num_islands):
                if i != j:
                    for ind in elites[j]:
                         other_elites.append(ind)
            if len(other_elites) == 0 : #Handle edge case, do not attempt to migrate.
              continue;

            for j in replace_indices:
                  migrant_index = random.randint(0, len(other_elites)-1)
                  island['population'][j] = other_elites[migrant_index]
                  # Re-evaluate fitness
                  #island['fitness'][j] = objective_function(island['population'][j].reshape(1,-1))[0] -- This should have been here before, but let us not.

            self.islands[i] = island

```

### Rank 15 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptiveIslandGeneticAlgorithm
# Description: Employs multiple interacting populations with dynamically adjusted migration rates to escape local optima in multimodal landscapes.
# Code:
```python
import numpy as np
import random

# Name: AdaptiveIslandGeneticAlgorithm
# Description: Employs multiple interacting populations with dynamically adjusted migration rates to escape local optima in multimodal landscapes.

class AdaptiveIslandGeneticAlgorithm:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 population_size: int = 50, num_islands: int = 4, crossover_rate: float = 0.9,
                 mutation_rate: float = 0.1, migration_interval: int = 500, initial_migration_rate: float = 0.1):
        """
        Initializes the Adaptive Island Genetic Algorithm.

        Args:
            budget (int): The maximum number of function evaluations.
            dim (int): The dimensionality of the problem.
            lower_bounds (list[float]): The lower bounds for each dimension.
            upper_bounds (list[float]): The upper bounds for each dimension.
            population_size (int): The size of each island's population.
            num_islands (int): The number of islands (sub-populations).
            crossover_rate (float): The probability of crossover.
            mutation_rate (float): The probability of mutation.
            migration_interval (int): The number of evaluations between migration events.
            initial_migration_rate (float): The initial proportion of individuals to migrate.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.population_size = population_size
        self.num_islands = num_islands
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_rate = initial_migration_rate  # Dynamically adjusted

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize islands (populations)
        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            self.islands.append(population)

        self.island_fitnesses = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.island_best_solutions = [None] * self.num_islands
        self.island_best_fitnesses = [float('inf')] * self.num_islands

    def _evaluate_population(self, objective_function: callable, population: np.ndarray) -> np.ndarray:
        """
        Evaluates the fitness of a population.

        Args:
            objective_function (callable): The objective function to evaluate.
            population (np.ndarray): The population to evaluate.

        Returns:
            np.ndarray: The fitness values for each individual in the population.
        """
        fitness_values = objective_function(population)
        self.eval_count += len(fitness_values)
        return fitness_values

    def _selection(self, population: np.ndarray, fitness_values: np.ndarray, num_parents: int) -> np.ndarray:
        """
        Selects parents using tournament selection.

        Args:
            population (np.ndarray): The population to select from.
            fitness_values (np.ndarray): The fitness values of the population.
            num_parents (int): The number of parents to select.

        Returns:
            np.ndarray: The selected parents.
        """
        selected_indices = []
        for _ in range(num_parents):
            tournament_indices = random.sample(range(len(population)), 5)  # Tournament size of 5
            winner_index = tournament_indices[np.argmin(fitness_values[tournament_indices])]
            selected_indices.append(winner_index)
        return population[selected_indices]

    def _crossover(self, parents: np.ndarray) -> np.ndarray:
        """
        Performs uniform crossover to generate offspring.

        Args:
            parents (np.ndarray): The parents to perform crossover on.

        Returns:
            np.ndarray: The offspring generated by crossover.
        """
        num_offspring = len(parents) // 2 * 2  # Ensure even number of offspring
        offspring = np.empty((num_offspring, self.dim))
        for i in range(0, num_offspring, 2):
            if random.random() < self.crossover_rate:
                # Uniform Crossover
                for j in range(self.dim):
                    if random.random() < 0.5:
                        offspring[i, j] = parents[i % len(parents), j]
                    else:
                        offspring[i, j] = parents[(i + 1) % len(parents), j]
                offspring[i + 1] = parents[(i + 1) % len(parents)] # just copy parent for simplicity
            else:
                offspring[i] = parents[i % len(parents)]
                offspring[i + 1] = parents[(i + 1) % len(parents)]

        return offspring

    def _mutation(self, offspring: np.ndarray) -> np.ndarray:
        """
        Performs mutation on the offspring.

        Args:
            offspring (np.ndarray): The offspring to mutate.

        Returns:
            np.ndarray: The mutated offspring.
        """
        for i in range(len(offspring)):
            for j in range(self.dim):
                if random.random() < self.mutation_rate:
                    # Add a small random value
                    offspring[i, j] += np.random.normal(0, 0.1)  # Gaussian mutation
                    # Clip to bounds
                    offspring[i, j] = np.clip(offspring[i, j], self.lower_bounds[j], self.upper_bounds[j])
        return offspring

    def _migration(self):
        """
        Migrates individuals between islands. Adjusts migration rate adaptively based on island diversity.
        """

        # Dynamically adjust migration rate based on diversity.
        island_diversities = []
        for island in self.islands:
            # Simplified diversity measure: average distance to the centroid
            centroid = np.mean(island, axis=0)
            diversity = np.mean(np.linalg.norm(island - centroid, axis=1))
            island_diversities.append(diversity)

        # Adjust migration rate.  Lower diversity -> Higher migration rate.
        normalized_diversities = np.array(island_diversities) / np.max(island_diversities) if np.max(island_diversities) > 0 else np.zeros_like(island_diversities)
        self.migration_rate = 0.1 + 0.4 * (1 - np.mean(normalized_diversities)) # Migration rate in range [0.1, 0.5].



        num_migrants = int(self.population_size * self.migration_rate)
        for i in range(self.num_islands):
            # Select migrants to send
            migrant_indices = np.argsort(self.island_fitnesses[i])[-num_migrants:]  # Worst individuals
            migrants = self.islands[i][migrant_indices]

            # Select a destination island (different from the origin)
            destination_island = (i + 1) % self.num_islands

            # Replace individuals in the destination island with the migrants
            replacement_indices = np.argsort(self.island_fitnesses[destination_island])[:num_migrants]  # Best individuals will be replaced
            self.islands[destination_island][replacement_indices] = migrants

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the objective function using the Adaptive Island Genetic Algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): The acceptance threshold for early stopping.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset evaluation count
        generation = 0

        while self.eval_count < self.budget:
            generation += 1
            for i in range(self.num_islands):
                # Evaluate population
                self.island_fitnesses[i] = self._evaluate_population(objective_function, self.islands[i])

                # Update island best
                best_index = np.argmin(self.island_fitnesses[i])
                if self.island_fitnesses[i][best_index] < self.island_best_fitnesses[i]:
                    self.island_best_fitnesses[i] = self.island_fitnesses[i][best_index]
                    self.island_best_solutions[i] = self.islands[i][best_index].copy()  # Important: copy the array!

                # Selection
                parents = self._selection(self.islands[i], self.island_fitnesses[i], self.population_size)

                # Crossover and Mutation
                offspring = self._crossover(parents)
                offspring = self._mutation(offspring)

                # Replace the old population with the new offspring
                self.islands[i] = offspring.copy() # Make sure to copy.

            # Migration
            if self.eval_count % self.migration_interval == 0:
                self._migration()


            # Update overall best
            for i in range(self.num_islands):
                if self.island_best_fitnesses[i] < self.best_fitness_overall:
                    self.best_fitness_overall = self.island_best_fitnesses[i]
                    self.best_solution_overall = self.island_best_solutions[i].copy() # Very important copy!


            if self.best_fitness_overall < acceptance_threshold:
                break


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'generations': generation
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```



### Guide
Keep in mind, this is a list of design heuristics ranked from best to worst. The first algorithm in the list is the best performing on average, and the last is the worst.
Your response must be in Markdown format and contain nothing else. It must have the following structure:

"**Analysis:**
**Experience:**"

In there:
+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.
Example: "Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:"

+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).

I'm going to tip $999K for a better heuristics! Let's think step by step.
2025-06-25 08:39:17 INFO Full response text: ```markdown
**Analysis:**
Comparing (Rank 1) EnhancedArchiveGuidedDE vs (Rank 15) AdaptiveIslandGeneticAlgorithm, we see EnhancedArchiveGuidedDE focuses more on exploitation around promising regions through archive guidance with adaptive F_scale, while AdaptiveIslandGeneticAlgorithm emphasizes diversity via multiple islands and dynamic migration based on population diversity measure and simpler genetic operators, but less adaptive F parameters.

(Rank 2) AdaptiveGaussianArchiveEA vs (Rank 14) IslandDifferentialEvolution : AdaptiveGaussianArchiveEA emphasizes exploration via gaussian mutation with decaying sigma with local archive, while IslandDifferentialEvolution maintains diversity through multiple islands with standard Differential Evolution operators on each, combined with less adaptive migration policy.

Comparing (Rank 1) vs (Rank 2), we see EnhancedArchiveGuidedDE using archive with 'pbest' selection combined with DE mutation, and AdaptiveGaussianArchiveEA uses only adaptive gaussian recombination around center of tournament selected parents.
Comparing (Rank 3) AdaptiveGaussianSamplingEA vs (Rank 4) IslandDifferentialEvolution, AdaptiveGaussianSamplingEA focuses more on adaptive exploration via gradual sigma reduction for gaussian mutation, while IslandDifferentialEvolution leverages multiple islands and differential evolution for diversity.

Comparing (Rank 14) vs (Rank 15), we see the biggest difference is on adapting migration rate, AdaptiveIslandGeneticAlgorithm tunes adaptive migration based on normalized island diversities, while IslandDifferentialEvolution employs simple periodic migration. Also, in genetic algorithm operators, especially chromosome crossover, contribute better than adaptive factors.

Overall: Good multi-component landscape exploration hinges on balancing adaptive local search strategies (archive + adaptive step sizes) on each subpopulation combined with relatively global and simple migration policies. The algorithm with archive, adaptation of algorithm parameters F and sigma is better than adjusting migration rate with simple crossovers. The success can be attributed to the archive remembering the good values.

**Experience:**
For multi-component landscapes, effective heuristics involve archive-guided local search within subpopulations that are balanced against global island architectures to share memory between isolated local searches and promote overall diversity, and with minimal adjustments to account complex adaptation factors such as normalized diversity.
```
2025-06-25 08:39:19 INFO Full response text: Okay, I understand. Here's a breakdown of how to refine "Current self-reflection" to design better heuristics for multi-component landscapes, steering clear of pitfalls.

**Redefined Self-Reflection:**

*   **Keywords:** Multi-component landscapes, heuristic design, balanced exploration/exploitation, information sharing, diversity management, adaptability, modularity.

*   **Advice:** Focus on creating modular heuristics that can adapt to different landscape characteristics. Decompose the problem to smaller self-contained parts, such as sub-population exploration, information sharing and adaptation. The most straightforward way to do it is with a configuration setting.

*   **Avoid:** Over-reliance on complex fixed architectures and intricate adaptation formulas. Minimal adjustments that aim to target overall adaptation characteristics such as average diversity, are undesirable, because one configuration of the algorithms would produce unpredictable result on different sub-populations.

*   **Explanation:** Modularize adaptation by allowing separate parts. This means designing independent configurable modules that would handle exploration, exploitation, population, and information sharing separately. The modules would automatically adapt to the sub-populations.

2025-06-25 08:39:19 INFO Generating offspring via Crossover...
2025-06-25 08:49:00 INFO Crossover Prompt: **(CR: Capacity and Role)**
Act as an expert in designing algorithms for deceptive, multi-component landscapes. Your specialty is creating strategies that use multi-population or island models to perform aggressive global exploration.

**(I: Insight)**
Your objective is to design a novel optimization algorithm for the GNBG benchmark. The most difficult functions (f16-f24) have multiple, separate basins of attraction where the global optimum can be hidden. An algorithm must be able to discover and explore these competing regions to succeed.

**(S: Statement & P: Personality)**
Provide a complete, novel Python class that implements a multi-population or island-based search strategy to solve this challenge. The class must have an `__init__(...)` and `optimize(...)` method as specified in the main task description.


### Better code
IslandParallelEA
import numpy as np
import random


# Name: IslandParallelEA
# Description: Employs an island model evolutionary algorithm with periodic migration to explore multimodal landscapes.
# Code:
class IslandParallelEA:
    """
    Implements an island model evolutionary algorithm to optimize functions, 
    especially those with multiple local optima.  It utilizes parallel islands that evolve independently 
    and exchange solutions periodically to promote global exploration.
    """

    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 4, population_size: int = 50, mutation_rate: float = 0.1,
                 crossover_rate: float = 0.7, migration_interval: int = 100, migration_size: int = 5):
        """
        Initializes the IslandParallelEA optimizer.

        Args:
            budget (int): Total function evaluation budget.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): Lower bounds of the search space.
            upper_bounds (list[float]): Upper bounds of the search space.
            num_islands (int): Number of independent populations (islands).
            population_size (int): Number of individuals in each island's population.
            mutation_rate (float): Probability of mutating each gene.
            crossover_rate (float): Probability of performing crossover between parents.
            migration_interval (int): Interval (in evaluations) at which migration occurs.
            migration_size (int): Number of individuals to migrate between islands.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.num_islands = num_islands
        self.population_size = population_size
        self.mutation_rate = mutation_rate
        self.crossover_rate = crossover_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize islands: Each island has a population of random solutions.
        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds,
                                            size=(self.population_size, self.dim))
            self.islands.append(population)
        self.island_best_solutions = [None] * self.num_islands
        self.island_best_fitnesses = [float('inf')] * self.num_islands

    def _evaluate_population(self, objective_function: callable, population: np.ndarray) -> np.ndarray:
        """
        Evaluates the fitness of each individual in a population.

        Args:
            objective_function (callable): The objective function to evaluate.
            population (np.ndarray): A 2D NumPy array representing the population.

        Returns:
            np.ndarray: A 1D NumPy array of fitness values.
        """
        fitness_values = objective_function(population)
        self.eval_count += len(population)
        return fitness_values

    def _selection(self, population: np.ndarray, fitness_values: np.ndarray, num_parents: int) -> np.ndarray:
        """
        Performs tournament selection to select parents for crossover.

        Args:
            population (np.ndarray): The population to select from.
            fitness_values (np.ndarray): Fitness values for each individual in the population.
            num_parents (int): The number of parents to select.

        Returns:
            np.ndarray: An array of selected parents.
        """
        selected_indices = []
        for _ in range(num_parents):
            # Tournament size is set to 2 here. Larger values make it more selective
            tournament_indices = random.sample(range(len(population)), 2)
            if fitness_values[tournament_indices[0]] < fitness_values[tournament_indices[1]]:
                selected_indices.append(tournament_indices[0])
            else:
                selected_indices.append(tournament_indices[1])
        return population[selected_indices]

    def _crossover(self, parents: np.ndarray) -> np.ndarray:
        """
        Performs uniform crossover to create offspring.

        Args:
            parents (np.ndarray): The parents to crossover.

        Returns:
            np.ndarray: The offspring resulting from crossover.
        """
        num_parents = len(parents)
        offspring = np.empty_like(parents[0])
        for i in range(self.dim):
            if random.random() < self.crossover_rate:
                # Uniform crossover: each gene is randomly inherited from one of the parents.
                parent_index = random.randint(0, num_parents - 1)
                offspring[i] = parents[parent_index][i]
            else:
                offspring[i] = parents[0][i]  # Otherwise, inherit from the first parent.
        return offspring

    def _mutation(self, individual: np.ndarray) -> np.ndarray:
        """
        Applies mutation to an individual.

        Args:
            individual (np.ndarray): The individual to mutate.

        Returns:
            np.ndarray: The mutated individual.
        """
        mutated_individual = individual.copy()
        for i in range(self.dim):
            if random.random() < self.mutation_rate:
                # Apply random perturbation within bounds
                mutation_amount = random.uniform(-1, 1) * (self.upper_bounds[i] - self.lower_bounds[i]) * 0.1  # Scale perturbation
                mutated_individual[i] += mutation_amount
                # Clip to bounds
                mutated_individual[i] = np.clip(mutated_individual[i], self.lower_bounds[i], self.upper_bounds[i])
        return mutated_individual

    def _migrate(self):
        """
        Migrates individuals between islands.  Selects the best individuals from one island
        and replaces the worst individuals on another randomly chosen island.
        """
        for i in range(self.num_islands):
            # Select random source and destination islands (must be different).
            source_island_index = i
            destination_island_index = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best individuals in the source island.
            source_fitness = self._evaluate_population(lambda x: x, self.islands[source_island_index])  # Dummy objective
            best_indices = np.argsort(source_fitness)[:self.migration_size]
            migrants = self.islands[source_island_index][best_indices]

            # Identify the worst individuals in the destination island
            destination_fitness = self._evaluate_population(lambda x: x, self.islands[destination_island_index])  # Dummy objective
            worst_indices = np.argsort(destination_fitness)[-self.migration_size:]

            # Replace the worst individuals in the destination island with the migrants.
            self.islands[destination_island_index][worst_indices] = migrants
    
    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Runs the island model evolutionary algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Stop the optimization when this fitness is reached.

        Returns:
            tuple: (best_solution, best_fitness, optimization_info)
        """
        self.eval_count = 0  # Reset for this run
        for island_index in range(self.num_islands):
            self.island_best_solutions[island_index] = None
        self.best_fitness_overall = float('inf')

        generation = 0
        while self.eval_count < self.budget:
            generation += 1
            for island_index in range(self.num_islands):
                # Evaluate the current population
                fitness_values = self._evaluate_population(objective_function, self.islands[island_index])

                # Update best solution for this island
                best_index = np.argmin(fitness_values)
                if fitness_values[best_index] < self.island_best_fitnesses[island_index]:
                    self.island_best_fitnesses[island_index] = fitness_values[best_index]
                    self.island_best_solutions[island_index] = self.islands[island_index][best_index].copy()

                    # Update overall best solution
                    if fitness_values[best_index] < self.best_fitness_overall:
                        self.best_fitness_overall = fitness_values[best_index]
                        self.best_solution_overall = self.islands[island_index][best_index].copy()

                if self.best_fitness_overall <= acceptance_threshold:
                    break  # Early stopping

                # Selection: select parents for crossover
                parents = self._selection(self.islands[island_index], fitness_values, self.population_size)

                # Crossover and Mutation to create the new population
                new_population = np.empty_like(self.islands[island_index])
                for i in range(self.population_size):
                    offspring = self._crossover(parents)
                    offspring = self._mutation(offspring)
                    new_population[i] = offspring

                self.islands[island_index] = new_population
            
            # Migration
            if generation % self.migration_interval == 0:
                self._migrate()

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'generations': generation
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

### Worse code
IslandDifferentialEvolution
import numpy as np
import random


# Name: IslandDifferentialEvolution
# Description: Implements an island model differential evolution algorithm with migration to tackle multimodal landscapes.

class IslandDifferentialEvolution:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 differential_weight: float = 0.5, migration_interval: int = 500, migration_amount: int = 2):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.differential_weight = differential_weight
        self.migration_interval = migration_interval
        self.migration_amount = migration_amount

        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds,
                                            (self.population_size, self.dim))
            self.islands.append({
                'population': population,
                'fitness': np.full(self.population_size, float('inf')),
                'best_solution': None,
                'best_fitness': float('inf')
            })

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0  # Reset for this run
        if self.dim > 0:
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        else:
            self.best_solution_overall = np.array([])
        self.best_fitness_overall = float('inf')

        # Initialize island populations and evaluate fitness
        for island in self.islands:
            island['fitness'] = objective_function(island['population'])
            self.eval_count += self.population_size
            best_index = np.argmin(island['fitness'])
            island['best_solution'] = island['population'][best_index].copy()
            island['best_fitness'] = island['fitness'][best_index]

            if island['best_fitness'] < self.best_fitness_overall:
                self.best_fitness_overall = island['best_fitness']
                self.best_solution_overall = island['best_solution'].copy()

        generation = 0
        while self.eval_count < self.budget:
            generation += 1

            for i, island in enumerate(self.islands):
                new_population = np.zeros_like(island['population'])
                for j in range(self.population_size):
                    # Differential Evolution Mutation and Crossover
                    idxs = [idx for idx in range(self.population_size) if idx != j]
                    a, b, c = random.sample(idxs, 3)

                    mutant = island['population'][a] + self.differential_weight * (island['population'][b] - island['population'][c])
                    mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

                    trial_vector = np.zeros(self.dim)
                    for k in range(self.dim):
                        if random.random() < self.crossover_rate or k == random.randint(0, self.dim - 1):
                            trial_vector[k] = mutant[k]
                        else:
                            trial_vector[k] = island['population'][j][k]

                    new_population[j] = trial_vector

                # Evaluate new population
                new_fitness = objective_function(new_population)
                self.eval_count += self.population_size

                # Selection
                for j in range(self.population_size):
                    if new_fitness[j] < island['fitness'][j]:
                        island['population'][j] = new_population[j].copy()
                        island['fitness'][j] = new_fitness[j]

                        if new_fitness[j] < island['best_fitness']:
                            island['best_solution'] = island['population'][j].copy()
                            island['best_fitness'] = new_fitness[j]

                            if new_fitness[j] < self.best_fitness_overall:
                                self.best_fitness_overall = new_fitness[j]
                                self.best_solution_overall = island['population'][j].copy()

            # Migration
            if generation % self.migration_interval == 0:
                # Sort islands by best fitness
                sorted_islands = sorted(self.islands, key=lambda x: x['best_fitness'])

                # Migrate best individuals from top islands to worst islands
                for i in range(self.migration_amount):
                    source_island = sorted_islands[i]
                    target_island = sorted_islands[self.num_islands - 1 - i]

                    # Replace random individuals in the target island with copies of the best individuals from the source island
                    for _ in range(self.migration_amount):
                        replace_index = random.randint(0, self.population_size - 1)
                        target_island['population'][replace_index] = source_island['best_solution'].copy()
                        target_island['fitness'][replace_index] = objective_function(target_island['population'][replace_index:replace_index+1])[0] # Evaluate the migrated individual
                        self.eval_count += 1

                        if target_island['fitness'][replace_index] < target_island['best_fitness']:
                          target_island['best_fitness'] = target_island['fitness'][replace_index]
                          target_island['best_solution'] = target_island['population'][replace_index].copy()
                        
                    if self.eval_count >= self.budget:
                        break;  # Check budget after each migration step


        if self.best_solution_overall is None and self.dim > 0:  # Fallback
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
            self.best_fitness_overall = objective_function(self.best_solution_overall.reshape(1,-1))[0]
            self.eval_count += 1


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'num_islands': self.num_islands,
            'population_size': self.population_size,
            'crossover_rate': self.crossover_rate,
            'differential_weight': self.differential_weight,
            'migration_interval': self.migration_interval,
            'migration_amount': self.migration_amount
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

### Analyze & experience
- Comparing (Rank 1) EnhancedArchiveGuidedDE vs (Rank 15) AdaptiveIslandGeneticAlgorithm, we see EnhancedArchiveGuidedDE focuses more on exploitation around promising regions through archive guidance with adaptive F_scale, while AdaptiveIslandGeneticAlgorithm emphasizes diversity via multiple islands and dynamic migration based on population diversity measure and simpler genetic operators, but less adaptive F parameters.

(Rank 2) AdaptiveGaussianArchiveEA vs (Rank 14) IslandDifferentialEvolution : AdaptiveGaussianArchiveEA emphasizes exploration via gaussian mutation with decaying sigma with local archive, while IslandDifferentialEvolution maintains diversity through multiple islands with standard Differential Evolution operators on each, combined with less adaptive migration policy.

Comparing (Rank 1) vs (Rank 2), we see EnhancedArchiveGuidedDE using archive with 'pbest' selection combined with DE mutation, and AdaptiveGaussianArchiveEA uses only adaptive gaussian recombination around center of tournament selected parents.
Comparing (Rank 3) AdaptiveGaussianSamplingEA vs (Rank 4) IslandDifferentialEvolution, AdaptiveGaussianSamplingEA focuses more on adaptive exploration via gradual sigma reduction for gaussian mutation, while IslandDifferentialEvolution leverages multiple islands and differential evolution for diversity.

Comparing (Rank 14) vs (Rank 15), we see the biggest difference is on adapting migration rate, AdaptiveIslandGeneticAlgorithm tunes adaptive migration based on normalized island diversities, while IslandDifferentialEvolution employs simple periodic migration. Also, in genetic algorithm operators, especially chromosome crossover, contribute better than adaptive factors.

Overall: Good multi-component landscape exploration hinges on balancing adaptive local search strategies (archive + adaptive step sizes) on each subpopulation combined with relatively global and simple migration policies. The algorithm with archive, adaptation of algorithm parameters F and sigma is better than adjusting migration rate with simple crossovers. The success can be attributed to the archive remembering the good values.
- Okay, I understand. Here's a breakdown of how to refine "Current self-reflection" to design better heuristics for multi-component landscapes, steering clear of pitfalls.

**Redefined Self-Reflection:**

*   **Keywords:** Multi-component landscapes, heuristic design, balanced exploration/exploitation, information sharing, diversity management, adaptability, modularity.

*   **Advice:** Focus on creating modular heuristics that can adapt to different landscape characteristics. Decompose the problem to smaller self-contained parts, such as sub-population exploration, information sharing and adaptation. The most straightforward way to do it is with a configuration setting.

*   **Avoid:** Over-reliance on complex fixed architectures and intricate adaptation formulas. Minimal adjustments that aim to target overall adaptation characteristics such as average diversity, are undesirable, because one configuration of the algorithms would produce unpredictable result on different sub-populations.

*   **Explanation:** Modularize adaptation by allowing separate parts. This means designing independent configurable modules that would handle exploration, exploitation, population, and information sharing separately. The modules would automatically adapt to the sub-populations.


Your task is to write an improved function by COMBINING elements of two above heuristics base Analyze & experience.
Output the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.

I'm going to tip $999K for a better heuristics! Let's think step by step.
2025-06-25 08:49:00 INFO Mutation prompt: **(CR: Capacity and Role)**
Act as an expert in designing algorithms for deceptive, multi-component landscapes. Your specialty is creating strategies that use multi-population or island models to perform aggressive global exploration.

**(I: Insight)**
Your objective is to design a novel optimization algorithm for the GNBG benchmark. The most difficult functions (f16-f24) have multiple, separate basins of attraction where the global optimum can be hidden. An algorithm must be able to discover and explore these competing regions to succeed.

**(S: Statement & P: Personality)**
Provide a complete, novel Python class that implements a multi-population or island-based search strategy to solve this challenge. The class must have an `__init__(...)` and `optimize(...)` method as specified in the main task description.


Current heuristics:
EnhancedArchiveGuidedDE
import numpy as np
import random

class EnhancedArchiveGuidedDE: #aocc 0.15
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 population_size_factor: float = 8.82865217019506, archive_size: int = 165.22481375900153, initial_F_scale: float = 0.3544373580018585):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.population_size = int(population_size_factor * self.dim)  # common heuristic
        self.archive_size = archive_size
        self.archive = []
        self.population = None
        self.F_scale = initial_F_scale  # initial scaling factor

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8,
                 F_scale_variation: float = 0.3, archive_update_threshold: float = 0.8) -> tuple:
        self.eval_count = 0
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        fitness = objective_function(self.population)
        self.eval_count += self.population_size

        self.best_solution_overall = self.population[np.argmin(fitness)]
        self.best_fitness_overall = np.min(fitness)

        while self.eval_count < self.budget:
            offspring = self.generate_offspring(self.population, fitness, F_scale_variation)
            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            # Update archive
            self.update_archive(offspring, offspring_fitness, archive_update_threshold)

            # Select best solutions for next generation
            combined_population = np.concatenate((self.population, offspring))
            combined_fitness = np.concatenate((fitness, offspring_fitness))
            indices = np.argsort(combined_fitness)
            self.population = combined_population[indices[:self.population_size]]
            fitness = combined_fitness[indices[:self.population_size]]

            # Update best solution
            self.best_solution_overall = self.population[np.argmin(fitness)]
            self.best_fitness_overall = np.min(fitness)

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'archive_size': len(self.archive)
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def generate_offspring(self, population, fitness, F_scale_variation):
        offspring = np.zeros((self.population_size, self.dim))
        # Adaptive scaling factor
        self.F_scale = 0.5 + F_scale_variation * np.random.rand()  # scale factor with slight variation

        for i in range(self.population_size):
            # Select pbest from archive (if available)
            if self.archive:
                pbest_index = np.random.choice(len(self.archive))
                pbest = self.archive[pbest_index][0]
            else:
                pbest = population[np.argmin(fitness)]

            a, b, c = random.sample(range(self.population_size), 3)
            while a == i or b == i or c == i:
                a, b, c = random.sample(range(self.population_size), 3)

            offspring[i] = population[i] + self.F_scale * (pbest - population[i] + population[a] - population[b])
            offspring[i] = np.clip(offspring[i], self.lower_bounds, self.upper_bounds)  # Boundary handling

        return offspring

    def update_archive(self, offspring, offspring_fitness, archive_update_threshold):
        for i in range(len(offspring)):
            if len(self.archive) < self.archive_size:
                self.archive.append((offspring[i], offspring_fitness[i]))
            else:
                # Prioritize diversity in archive
                worst_index = np.argmax([f for _, f in self.archive])
                if offspring_fitness[i] < self.archive[worst_index][1] or len(self.archive) < self.archive_size * archive_update_threshold:
                    self.archive[worst_index] = (offspring[i], offspring_fitness[i])

Now, think outside the box write a mutated function better than current version.
You can use some hints below:
- Okay, I understand. Here's a breakdown of how to refine "Current self-reflection" to design better heuristics for multi-component landscapes, steering clear of pitfalls.

**Redefined Self-Reflection:**

*   **Keywords:** Multi-component landscapes, heuristic design, balanced exploration/exploitation, information sharing, diversity management, adaptability, modularity.

*   **Advice:** Focus on creating modular heuristics that can adapt to different landscape characteristics. Decompose the problem to smaller self-contained parts, such as sub-population exploration, information sharing and adaptation. The most straightforward way to do it is with a configuration setting.

*   **Avoid:** Over-reliance on complex fixed architectures and intricate adaptation formulas. Minimal adjustments that aim to target overall adaptation characteristics such as average diversity, are undesirable, because one configuration of the algorithms would produce unpredictable result on different sub-populations.

*   **Explanation:** Modularize adaptation by allowing separate parts. This means designing independent configurable modules that would handle exploration, exploitation, population, and information sharing separately. The modules would automatically adapt to the sub-populations.


Output code only and enclose your code with Python code block: ```python ... ```.
I'm going to tip $999K for a better solution!
2025-06-25 08:51:29 INFO Perform Harmony Search...
2025-06-25 08:51:36 WARNING No replacements made in template string. Returning None.
2025-06-25 08:51:43 WARNING No replacements made in template string. Returning None.
2025-06-25 08:51:50 WARNING No replacements made in template string. Returning None.
2025-06-25 08:51:50 INFO Generation 1, best so far: 0.3904505301102681
2025-06-25 08:51:50 INFO Population length is: 9
2025-06-25 08:51:50 INFO --- Performing Long-Term Reflection at Generation 2 ---
2025-06-25 08:51:50 INFO Reflection Prompt: ### Problem Description
**(CR: Capacity and Role)**
Act as an expert in designing algorithms for deceptive, multi-component landscapes. Your specialty is creating strategies that use multi-population or island models to perform aggressive global exploration.

**(I: Insight)**
Your objective is to design a novel optimization algorithm for the GNBG benchmark. The most difficult functions (f16-f24) have multiple, separate basins of attraction where the global optimum can be hidden. An algorithm must be able to discover and explore these competing regions to succeed.

**(S: Statement & P: Personality)**
Provide a complete, novel Python class that implements a multi-population or island-based search strategy to solve this challenge. The class must have an `__init__(...)` and `optimize(...)` method as specified in the main task description.

### List heuristics
Below is a list of design heuristics ranked from best to worst based on their AOCC score on group function 3 of GNBG benchmark, where higher is better. To enable a detailed analysis of their specializations, the performance breakdown on each of the three GNBG function groups is also provided.
### Rank 1 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptiveArchipelagoDE
# Description: Combines island model with archive-guided DE mutation for enhanced global exploration in multi-component landscapes.
# Code:
```python
import numpy as np

# Name: AdaptiveArchipelagoDE
# Description: Combines island model with archive-guided DE mutation for enhanced global exploration in multi-component landscapes.

class AdaptiveArchipelagoDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        """
        Initializes the AdaptiveArchipelagoDE algorithm.

        Args:
            budget (int): The maximum number of function evaluations.
            dim (int): The dimensionality of the problem.
            lower_bounds (list[float]): The lower bounds of the search space.
            upper_bounds (list[float]): The upper bounds of the search space.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Island model parameters
        self.num_islands = 5  # Number of islands
        self.population_size = 50  # Population size per island
        self.migration_interval = 50  # Migration interval (evaluations)
        self.migration_rate = 0.1  # Fraction of population to migrate

        # DE parameters (per island)
        self.F_scale = 0.7  # Differential weight
        self.CR = 0.9  # Crossover rate
        self.F_scale_adapt = 0.1 #Adaptive Differential weight
        self.CR_adapt = 0.1 #Adaptive Crossover Rate

        # Archive
        self.archive_size = 100
        self.archive = []

        # Island populations (initialized in optimize)
        self.islands_population = None
        self.islands_fitness = None

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using AdaptiveArchipelagoDE.

        Args:
            objective_function (callable): The objective function to minimize.
            acceptance_threshold (float, optional): The acceptance threshold for the best fitness. Defaults to 1e-8.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0
        self.best_fitness_overall = float('inf')

        # Initialize islands
        self.islands_population = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.islands_fitness = [objective_function(pop) for pop in self.islands_population]
        self.eval_count += self.num_islands * self.population_size

        # Initial archive update
        for i in range(self.num_islands):
            self.archive = self._update_archive(self.islands_population[i], self.islands_fitness[i])
            best_idx = np.argmin(self.islands_fitness[i])
            if self.islands_fitness[i][best_idx] < self.best_fitness_overall:
                self.best_fitness_overall = self.islands_fitness[i][best_idx]
                self.best_solution_overall = self.islands_population[i][best_idx].copy()

        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                # DE mutation with archive guidance
                offspring = self._archive_guided_mutation(i)
                offspring = np.clip(offspring, self.lower_bounds, self.upper_bounds) # Boundary handling

                offspring_fitness = objective_function(offspring)
                self.eval_count += len(offspring)

                # Selection
                combined_population = np.vstack((self.islands_population[i], offspring))
                combined_fitness = np.concatenate((self.islands_fitness[i], offspring_fitness))
                sorted_indices = np.argsort(combined_fitness)[:self.population_size]
                self.islands_population[i] = combined_population[sorted_indices]
                self.islands_fitness[i] = combined_fitness[sorted_indices]

                # Update best solution
                best_idx = np.argmin(self.islands_fitness[i])
                if self.islands_fitness[i][best_idx] < self.best_fitness_overall:
                    self.best_fitness_overall = self.islands_fitness[i][best_idx]
                    self.best_solution_overall = self.islands_population[i][best_idx].copy()

                # Update archive
                self.archive = self._update_archive(self.islands_population[i], self.islands_fitness[i])

                # Tune F and CR: Simple adaptation
                if np.random.rand() < self.F_scale_adapt :
                    self.F_scale = np.random.uniform(0.2, 0.9)
                if np.random.rand() < self.CR_adapt:
                     self.CR = np.random.uniform(0.1, 0.9)
                    
            # Migration
            if self.eval_count % self.migration_interval == 0:
                self._migrate_individuals()

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }

        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def _archive_guided_mutation(self, island_index: int):
         """
         Performs DE mutation guided by the archive.

         Args:
             island_index (int): The index of the island to perform mutation on.

         Returns:
             numpy.ndarray: The offspring population.
         """
         population = self.islands_population[island_index]
         num_individuals = len(population)
         offspring = np.zeros_like(population)

         for i in range(num_individuals):
             # Choose random indices for mutation, ensuring they are distinct
             idxs = [idx for idx in np.random.choice(num_individuals, size=2, replace=False) if idx != i]
             idx_a, idx_b = idxs[0], idxs[1]

             # Choose pbest index either the best one in the island or in archive.
             if len(self.archive) > 0 and np.random.rand() < 0.5:
                  arch_idx = np.random.choice(len(self.archive))
                  pbest = self.archive[arch_idx][:-1] # remove fitness
             else:
                  pbest = population[np.argmin(self.islands_fitness[island_index])]

             # DE mutation: v = x_i + F * (pbest - x_i) + F * (x_a - x_b)
             mutant = population[i] + self.F_scale * (pbest - population[i]) + self.F_scale * (population[idx_a] - population[idx_b])

             # Crossover
             jrand = np.random.randint(self.dim) # at least one parameter is changed
             for j in range(self.dim):
                 if np.random.rand() > self.CR and j != jrand:
                     mutant[j] = population[i][j] # keep parent chromosomes rather then mutation

             offspring[i] = mutant

         return offspring

    def _migrate_individuals(self):
        """
        Migrates individuals between islands based on the migration rate.
        """
        num_to_migrate = int(self.population_size * self.migration_rate)

        for i in range(self.num_islands):
            # Select migrants from current island
            migrant_indices = np.argsort(self.islands_fitness[i])[-num_to_migrate:] # Worst members
            migrants = self.islands_population[i][migrant_indices]
            migrant_fitnesses = self.islands_fitness[i][migrant_indices]

            # Choose a destination island (different from current)
            destination_island = (i + 1) % self.num_islands

            # Replace individuals in the destination island with migrants
            replace_indices = np.argsort(self.islands_fitness[destination_island])[:num_to_migrate]  #replace best members
            self.islands_population[destination_island][replace_indices] = migrants
            self.islands_fitness[destination_island][replace_indices] = migrant_fitnesses
             
            #Keep the best solution overall; the archive may not
            best_idx = np.argmin(self.islands_fitness[destination_island])
            if self.islands_fitness[destination_island][best_idx] < self.best_fitness_overall:
                self.best_fitness_overall = self.islands_fitness[destination_island][best_idx]
                self.best_solution_overall = self.islands_population[destination_island][best_idx].copy()


    def _update_archive(self, population, fitness_values):
        """
        Updates the archive with new individuals.

        Args:
            population (numpy.ndarray): The population to add to the archive.
            fitness_values (numpy.ndarray): The fitness values of the population.

        Returns:
            numpy.ndarray: The updated archive.
        """
        combined = np.column_stack((population, fitness_values))
        new_archive = self.archive.copy()
        for sol in combined:
            already_present = False
            for arch in new_archive:
                 if len(arch) > 0 and np.allclose(sol[:-1], arch[:-1], atol=1e-6):
                     already_present = True
                     break #Found. Move to next
            if not already_present:
                new_archive.append(sol)
        new_archive.sort(key=lambda x: x[-1]) # Sort archive

        return new_archive[:self.archive_size] #Return archive

```

### Rank 2 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptiveArchiveDE
# Description: Integrates adaptive differential evolution with an archive for enhanced exploration and exploitation in multimodal optimization.
# Code:
```python
import numpy as np
import random

# Name: AdaptiveArchiveDE
# Description: Integrates adaptive differential evolution with an archive for enhanced exploration and exploitation in multimodal optimization.
# Code:
class AdaptiveArchiveDE:
    """
    Combines adaptive differential evolution with an archive-based strategy
    to balance exploration and exploitation, enhancing its ability to navigate
    multimodal landscapes effectively.
    """
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 population_size: int = 50, archive_size: int = 100, initial_F: float = 0.5, initial_CR: float = 0.9):
        """
        Initializes the AdaptiveArchiveDE algorithm.

        Args:
            budget (int): The maximum number of function evaluations.
            dim (int): The dimensionality of the problem.
            lower_bounds (list[float]): A list of lower bounds for each dimension.
            upper_bounds (list[float]): A list of upper bounds for each dimension.
            population_size (int): The number of individuals in the population.
            archive_size (int): The maximum size of the archive.
            initial_F (float): Initial differential evolution scale factor.
            initial_CR (float): Initial crossover rate.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.population_size = population_size
        self.archive_size = archive_size
        self.archive = []
        self.population = None
        self.F = initial_F  # Differential evolution parameter
        self.CR = initial_CR # Crossover rate


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using Adaptive Archive DE.

        Args:
            objective_function (callable): The objective function to minimize.
            acceptance_threshold (float): Threshold for accepting a solution.

        Returns:
            tuple: A tuple containing the best solution, its fitness, and
                   a dictionary containing optimization information.
        """

        self.eval_count = 0

        # Initialize population
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        fitness = objective_function(self.population)
        self.eval_count += self.population_size
        
        self.best_solution_overall = self.population[np.argmin(fitness)]
        self.best_fitness_overall = np.min(fitness)

        while self.eval_count < self.budget:
            # Generate offspring using differential evolution
            offspring = self.generate_offspring(objective_function)
            
            # Evaluate offspring
            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            # Update archive
            self.update_archive(offspring, offspring_fitness)

            # Select individuals for the next generation
            self.population, fitness = self.select_next_generation(offspring, offspring_fitness, fitness)
            
            # Update best solution found so far
            best_index = np.argmin(fitness)
            if fitness[best_index] < self.best_fitness_overall:
                self.best_fitness_overall = fitness[best_index]
                self.best_solution_overall = self.population[best_index]

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'archive_size': len(self.archive)
        }

        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def generate_offspring(self, objective_function: callable) -> np.ndarray:
        """
        Generates offspring using differential evolution with archive guidance.
        """
        offspring = np.zeros((self.population_size, self.dim))

        for i in range(self.population_size):
            # Select pbest from archive or population
            if self.archive:
                pbest = random.choice(self.archive)[0]  # Use archive individual
            else:
                 pbest = self.population[np.argmin(objective_function(self.population))] #Fallback if the archive is empty

            # Ensure a, b, c are different and not equal to i
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b = random.sample(indices, 2)

            # Differential evolution mutation
            mutation_vector = pbest + self.F * (self.population[a] - self.population[b])

            # Crossover operation
            for j in range(self.dim):
                if random.random() < self.CR:
                    offspring[i][j] = mutation_vector[j]
                else:
                    offspring[i][j] = self.population[i][j]

            # Clip to bounds
            offspring[i] = np.clip(offspring[i], self.lower_bounds, self.upper_bounds)

        return offspring

    def update_archive(self, offspring, offspring_fitness):
        """
        Updates the archive with new solutions, prioritizing diversity.
        """
        for i in range(len(offspring)):
            # If the archive isn't full just add the vector
            if len(self.archive) < self.archive_size:
                self.archive.append((offspring[i], offspring_fitness[i]))
            else:
                #Replace the worst value with the offspring value if the offspring's fitness is better
                worst_index = np.argmax([f for _, f in self.archive])
                if offspring_fitness[i] < self.archive[worst_index][1]:
                    self.archive[worst_index] = (offspring[i], offspring_fitness[i])
                else:
                    pass

    def select_next_generation(self, offspring, offspring_fitness, fitness):
        """Selects the next population based on fitness."""
        combined_population = np.concatenate((self.population, offspring))
        combined_fitness = np.concatenate((fitness, offspring_fitness))
        indices = np.argsort(combined_fitness)[:self.population_size]
        return combined_population[indices], combined_fitness[indices]
```

### Rank 3 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptiveIslandArchiveEA
# Description: Integrates island model with adaptive Gaussian mutation and an archive for enhanced exploration.
# Code:
```python
import numpy as np
import random

# Name: AdaptiveIslandArchiveEA
# Description: Integrates island model with adaptive Gaussian mutation and an archive for enhanced exploration.
# Code:
class AdaptiveIslandArchiveEA:
    """
    Combines island model EA with adaptive Gaussian mutation and solution archive
    to efficiently explore and exploit multi-modal landscapes.
    """

    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 4, population_size: int = 50, archive_size: int = 100,
                 initial_sigma: float = 0.5, sigma_decay: float = 0.98,
                 migration_interval: int = 100, migration_size: int = 5):
        """
        Initializes the AdaptiveIslandArchiveEA optimizer.

        Args:
            budget (int): Total function evaluation budget.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): Lower bounds of the search space.
            upper_bounds (list[float]): Upper bounds of the search space.
            num_islands (int): Number of independent populations (islands).
            population_size (int): Number of individuals in each island's population.
            archive_size (int): Maximum size of the solution archive.
            initial_sigma (float): Initial standard deviation for Gaussian mutation (as fraction of bounds).
            sigma_decay (float): Decay rate for sigma over generations.
            migration_interval (int): Interval (in generations) at which migration occurs.
            migration_size (int): Number of individuals to migrate between islands.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.num_islands = num_islands
        self.population_size = population_size
        self.archive_size = archive_size
        self.initial_sigma = initial_sigma * (self.upper_bounds - self.lower_bounds)
        self.sigma_decay = sigma_decay
        self.migration_interval = migration_interval
        self.migration_size = migration_size

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize islands and archives. Each island has its own population and archive.
        self.islands = []
        self.archives = []  # List of NumPy arrays; one array per island with cols: solution + fitness
        self.sigmas = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds,
                                            size=(self.population_size, self.dim))
            self.islands.append(population)
            self.archives.append(np.empty((0, self.dim + 1)))  # Solution + fitness
            self.sigmas.append(self.initial_sigma.copy())

        self.island_best_solutions = [None] * self.num_islands
        self.island_best_fitnesses = [float('inf')] * self.num_islands


    def _evaluate_population(self, objective_function: callable, population: np.ndarray) -> np.ndarray:
        """
        Evaluates the fitness of each individual in a population.

        Args:
            objective_function (callable): The objective function to evaluate.
            population (np.ndarray): A 2D NumPy array representing the population.

        Returns:
            np.ndarray: A 1D NumPy array of fitness values.
        """
        fitness_values = objective_function(population)
        self.eval_count += len(population)
        return fitness_values

    def _tournament_selection(self, population: np.ndarray, fitness_values: np.ndarray, tournament_size: int = 5) -> np.ndarray:
        """
        Performs tournament selection.

        Args:
            population (np.ndarray): The population.
            fitness_values (np.ndarray): Fitness values for the population.
            tournament_size (int): Number of individuals in each tournament.

        Returns:
            np.ndarray: The selected parents.
        """
        selected_indices = []
        for _ in range(self.population_size):
            tournament_indices = np.random.choice(len(population), tournament_size, replace=False)
            winner_index = tournament_indices[np.argmin(fitness_values[tournament_indices])]
            selected_indices.append(winner_index)
        return population[selected_indices]


    def _gaussian_mutation(self, population: np.ndarray, sigma: np.ndarray) -> np.ndarray:
        """
        Applies Gaussian mutation to the population.

        Args:
            population (np.ndarray): The population.
            sigma (np.ndarray): Standard deviation for Gaussian mutation.

        Returns:
            np.ndarray: The mutated population.
        """
        mutation = np.random.normal(0, sigma, size=population.shape)
        mutated_population = population + mutation
        return np.clip(mutated_population, self.lower_bounds, self.upper_bounds)

    def _update_archive(self, island_index: int, population: np.ndarray, fitness_values: np.ndarray):
        """
        Updates the archive with new solutions.

        Args:
            island_index (int): The index of the island being updated.
            population (np.ndarray): The population.
            fitness_values (np.ndarray): Fitness values for the population.
        """
        combined = np.column_stack((population, fitness_values))  # Solutions + fitness
        archive = self.archives[island_index]

        # Remove duplicate solutions by comparing with the previous archive
        new_archive = []
        for sol in combined:
            already_present = any(np.allclose(sol[:-1], arch[:-1], atol=1e-8) for arch in archive)
            if not already_present:
                new_archive.append(sol)
        new_archive = np.array(new_archive)

        if(len(new_archive) > 0):
            archive = np.vstack((archive, new_archive))
            archive = archive[archive[:, -1].argsort()] # sort archive by fitness

        self.archives[island_index] = archive[:self.archive_size]



    def _migrate(self):
        """
        Migrates individuals between islands. Selects best individuals and migrates them.
        """
        for i in range(self.num_islands):
            source_island_index = i
            destination_island_index = random.choice([j for j in range(self.num_islands) if j != i])

            # Select the best individuals in the source island *archive*.
            if len(self.archives[source_island_index]) > 0:
                migrants = self.archives[source_island_index][:self.migration_size, :-1]  # Best solutions (excluding fitness)
            else:  # If the archive is empty, select randomly from the population
                migrants = self.islands[source_island_index][np.random.choice(self.population_size, self.migration_size, replace=False)]
            
            #Replace random individuals in the destination island population.
            replace_indices = np.random.choice(self.population_size, self.migration_size, replace=False)
            self.islands[destination_island_index][replace_indices] = migrants

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Runs the adaptive island EA optimization process.

        Args:
            objective_function (callable): The function to minimize.
            acceptance_threshold (float): Stop if the best fitness reaches this value.

        Returns:
            tuple: (best_solution, best_fitness, optimization_info)
        """
        self.eval_count = 0
        for island_index in range(self.num_islands):
            self.island_best_solutions[island_index] = None
            self.archives[island_index] = np.empty((0, self.dim + 1))
            self.sigmas[island_index] = self.initial_sigma.copy()


        self.best_fitness_overall = float('inf')

        generation = 0
        while self.eval_count < self.budget:
            generation += 1

            for island_index in range(self.num_islands):
                # Evaluate population
                fitness_values = self._evaluate_population(objective_function, self.islands[island_index])

                # Update best solution for the island
                best_index = np.argmin(fitness_values)
                if fitness_values[best_index] < self.island_best_fitnesses[island_index]:
                    self.island_best_fitnesses[island_index] = fitness_values[best_index]
                    self.island_best_solutions[island_index] = self.islands[island_index][best_index].copy()

                    # Update overall best solution
                    if fitness_values[best_index] < self.best_fitness_overall:
                        self.best_fitness_overall = fitness_values[best_index]
                        self.best_solution_overall = self.islands[island_index][best_index].copy()

                if self.best_fitness_overall <= acceptance_threshold:
                    break  # Early stopping

                # Update Archive before selection as this is part of environment selection
                self._update_archive(island_index, self.islands[island_index], fitness_values)

                # Selection by tournament before generating offspring population
                parents = self._tournament_selection(self.islands[island_index], fitness_values)

                # Create offspring
                offspring = self._gaussian_mutation(parents, self.sigmas[island_index])
                offspring_fitness = self._evaluate_population(objective_function, offspring)
                
                # Replacement : replace current population with offspring
                self.islands[island_index] = offspring

                # Decay sigma
                self.sigmas[island_index] *= self.sigma_decay


            if generation % self.migration_interval == 0:
                self._migrate()

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'generations': generation
        }

        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 4 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptArchiveGuidedEvolution
# Description: Uses an archive with DE-like mutation guided by past successful solutions, combined with adaptive sigma.
# Code:
```python
import numpy as np

# Name: AdaptArchiveGuidedEvolution
# Description: Uses an archive with DE-like mutation guided by past successful solutions, combined with adaptive sigma.
# Code:
class AdaptArchiveGuidedEvolution:
    """
    AdaptArchiveGuidedEvolution: Combines an archive of successful solutions with
    DE-like mutation and adaptive Gaussian sampling for robust multimodal optimization.
    """

    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        self.population_size = 100
        self.archive_size = 100  # Reduced archive size since Gaussian sampling adds exploration
        self.archive = []
        self.sigma = 0.2 * (self.upper_bounds - self.lower_bounds)  # Start with narrower sigma
        self.sigma_decay = 0.995
        self.F = 0.7  #Fixed Differential evolution parameters

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)

        self.best_fitness_overall = objective_function(self.best_solution_overall.reshape(1, -1))[0]
        self.eval_count += 1

        population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        fitness_values = objective_function(population)
        self.eval_count += self.population_size
        self._update_best(population, fitness_values)

        self.archive = self._update_archive(population, fitness_values)

        while self.eval_count < self.budget:
            #Guided mutation by archive
            archive_guided_offspring = self._archive_guided_mutation(population)
            # Adaptive Gaussian mutation: additional exploratory moves
            gaussian_offspring = self._gaussian_mutation(population)

            # Combine mutations and evaluate
            offspring = np.vstack((archive_guided_offspring, gaussian_offspring))

            offspring = np.clip(offspring, self.lower_bounds, self.upper_bounds)

            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            population, fitness_values = self._select_next_generation(
                population, fitness_values, offspring, offspring_fitness
            )
            self._update_best(population, fitness_values)

            self.archive = self._update_archive(population, fitness_values)
            self.sigma *= self.sigma_decay


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }

        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def _archive_guided_mutation(self, population):
        num_offspring = len(population)
        offspring = np.zeros_like(population)
        for i in range(num_offspring):
            # Select three random indices from the population and archive
            indices = np.random.choice(len(population), 2, replace=False)  # Indices within population
            archive_index = np.random.randint(len(self.archive)) if self.archive else indices[0]  # Index within the archive or random selection

            x_r1 = population[indices[0]]
            x_r2 = population[indices[1]]
            if self.archive:
              x_pbest = self.archive[archive_index][:-1] #remove fitness from archive entry if archive not empty.
            else:
              x_pbest = population[indices[0]]

            offspring[i] = population[i] + self.F * (x_pbest - population[i]) + self.F * (x_r1 - x_r2) # DE mutation.

        return offspring
    def _gaussian_mutation(self, population):
        # Standard deviation
        return population + np.random.normal(0, self.sigma, size=population.shape)

    def _update_archive(self, population, fitness_values):

        combined = np.column_stack((population, fitness_values))

        # Convert to list for easier manipulation
        new_archive = self.archive[:]

        for sol in combined:
            # Check if solution already exists (with tolerance)
            already_present = any(np.allclose(sol[:-1], arch[:-1], atol=1e-8) for arch in new_archive)
            if not already_present:
                new_archive.append(sol)

        # Sort and truncate
        new_archive.sort(key=lambda x: x[-1])
        self.archive = new_archive[:self.archive_size] #Update archive
        return self.archive

    def _select_next_generation(self, population, fitness_values, offspring, offspring_fitness):
        combined_pop = np.vstack((population, offspring))
        combined_fit = np.concatenate((fitness_values, offspring_fitness))
        sorted_indices = np.argsort(combined_fit)
        next_gen = combined_pop[sorted_indices[:self.population_size]]
        next_fit = combined_fit[sorted_indices[:self.population_size]]
        return next_gen, next_fit

    def _update_best(self, population, fitness_values):
        best_index = np.argmin(fitness_values)
        if fitness_values[best_index] < self.best_fitness_overall:
            self.best_fitness_overall = fitness_values[best_index]
            self.best_solution_overall = population[best_index]
```

### Rank 5 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: ArchipelagoArchiveDE
# Description: Uses an island model with archive-based mutation and migration for multimodal optimization.
# Code:
```python
import numpy as np
import random

# Name: ArchipelagoArchiveDE
# Description: Uses an island model with archive-based mutation and migration for multimodal optimization.

class ArchipelagoArchiveDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, archive_size: int = 10,
                 crossover_rate: float = 0.7, differential_weight: float = 0.5, migration_interval: int = 500,
                 migration_amount: int = 2, archive_prob: float = 0.1):
        """
        Initializes the ArchipelagoArchiveDE optimizer.

        Args:
            budget (int): Total function evaluation budget.
            dim (int): Dimensionality of the problem.
            lower_bounds (list[float]): Lower bounds for each dimension.
            upper_bounds (list[float]): Upper bounds for each dimension.
            num_islands (int): Number of islands in the archipelago.
            population_size (int): Population size for each island.
            archive_size (int): Size of the archive for each island.
            crossover_rate (float): Crossover rate for differential evolution.
            differential_weight (float): Differential weight for differential evolution.
            migration_interval (int): Interval (evaluations) at which migration occurs.
            migration_amount (int): Number of individuals to migrate.
            archive_prob (float): Probability of using archive vector during mutation.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.num_islands = num_islands
        self.population_size = population_size
        self.archive_size = archive_size
        self.crossover_rate = crossover_rate
        self.differential_weight = differential_weight
        self.migration_interval = migration_interval
        self.migration_amount = migration_amount
        self.archive_prob = archive_prob

        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds,
                                            (self.population_size, self.dim))
            archive = np.random.uniform(self.lower_bounds, self.upper_bounds,
                                            (self.archive_size, self.dim))
            self.islands.append({
                'population': population,
                'fitness': np.full(self.population_size, float('inf')),
                'best_solution': None,
                'best_fitness': float('inf'),
                'archive': archive,
                'archive_fitness': np.full(self.archive_size, float('inf')) # Archive fitness
            })

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Performs optimization using the Archipelago Archive Differential Evolution algorithm.

        Args:
            objective_function (callable): The objective function to minimize. Accepts a 2D NumPy array (N, dim) and returns 1D numpy array of N fitness values
            acceptance_threshold (float): Threshold for early stopping (not used).

        Returns:
            tuple: (best_solution, best_fitness, optimization_info)
        """
        self.eval_count = 0  # Reset for this run
        if self.dim > 0:
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        else:
            self.best_solution_overall = np.array([])
        self.best_fitness_overall = float('inf')

        # Initialize island populations and archives and evaluate fitness
        for island in self.islands:
            island['fitness'] = objective_function(island['population'])
            self.eval_count += self.population_size
            best_index = np.argmin(island['fitness'])
            island['best_solution'] = island['population'][best_index].copy()
            island['best_fitness'] = island['fitness'][best_index]

            island['archive_fitness'] = np.full(self.archive_size, float('inf')) # Reset archive fitness

            if island['best_fitness'] < self.best_fitness_overall:
                self.best_fitness_overall = island['best_fitness']
                self.best_solution_overall = island['best_solution'].copy()
            
            # Initialize archive based on initial population.
            for k in range(self.archive_size):
                idx = random.randint(0, self.population_size-1)
                island['archive'][k] = island['population'][idx].copy()
                island['archive_fitness'][k] = island['fitness'][idx]

        generation = 0
        while self.eval_count < self.budget:
            generation += 1

            for i, island in enumerate(self.islands):
                new_population = np.zeros_like(island['population'])
                for j in range(self.population_size):
                    # Differential Evolution Mutation with Archive
                    idxs = [idx for idx in range(self.population_size) if idx != j]
                    a, b, c = random.sample(idxs, 3)

                    if random.random() < self.archive_prob:
                        # Use a vector from the archive
                        arc_idx = random.randint(0, self.archive_size - 1)
                        mutant = island['population'][a] + self.differential_weight * (island['population'][b] - island['archive'][arc_idx])
                    else:
                        # Standard DE mutation
                        mutant = island['population'][a] + self.differential_weight * (island['population'][b] - island['population'][c])

                    mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

                    trial_vector = np.zeros(self.dim)
                    for k in range(self.dim):
                        if random.random() < self.crossover_rate or k == random.randint(0, self.dim - 1):
                            trial_vector[k] = mutant[k]
                        else:
                            trial_vector[k] = island['population'][j][k]

                    new_population[j] = trial_vector

                # Evaluate new population
                new_fitness = objective_function(new_population)
                self.eval_count += self.population_size

                # Selection and Archive Update
                for j in range(self.population_size):
                    if new_fitness[j] < island['fitness'][j]:
                        island['population'][j] = new_population[j].copy()
                        island['fitness'][j] = new_fitness[j]

                        if new_fitness[j] < island['best_fitness']:
                            island['best_solution'] = island['population'][j].copy()
                            island['best_fitness'] = new_fitness[j]

                            if new_fitness[j] < self.best_fitness_overall:
                                self.best_fitness_overall = new_fitness[j]
                                self.best_solution_overall = island['population'][j].copy()
                    
                    # Update archive: replace a random element with the new trial vector.
                    archive_index = random.randint(0, self.archive_size - 1)
                    if new_fitness[j] < island['archive_fitness'][archive_index]:
                        island['archive'][archive_index] = new_population[j].copy()
                        island['archive_fitness'][archive_index] = new_fitness[j]

            # Migration
            if generation % self.migration_interval == 0:
                # Sort islands by best fitness
                sorted_islands = sorted(self.islands, key=lambda x: x['best_fitness'])

                # Migrate best individuals from top islands to worst islands
                for i in range(self.migration_amount):
                    source_island = sorted_islands[i]
                    target_island = sorted_islands[self.num_islands - 1 - i]

                    # Replace random individuals in the target island with copies of the best individuals from the source island
                    for _ in range(self.migration_amount):
                        replace_index = random.randint(0, self.population_size - 1)
                        target_island['population'][replace_index] = source_island['best_solution'].copy()
                        target_island['fitness'][replace_index] = objective_function(target_island['population'][replace_index:replace_index+1])[0] # Evaluate the migrated individual
                        self.eval_count += 1

                        if target_island['fitness'][replace_index] < target_island['best_fitness']:
                          target_island['best_fitness'] = target_island['fitness'][replace_index]
                          target_island['best_solution'] = target_island['population'][replace_index].copy()

                        # also migrating archive for the migrated individual
                        archive_index = random.randint(0, self.archive_size-1)
                        target_island['archive'][archive_index] = source_island['best_solution'].copy()
                        target_island['archive_fitness'][archive_index] = source_island['best_fitness'] # Best Fitness

                    if self.eval_count >= self.budget:
                        break;  # Check budget after each migration step


        if self.best_solution_overall is None and self.dim > 0:  # Fallback
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
            self.best_fitness_overall = objective_function(self.best_solution_overall.reshape(1,-1))[0]
            self.eval_count += 1


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'num_islands': self.num_islands,
            'population_size': self.population_size,
            'crossover_rate': self.crossover_rate,
            'differential_weight': self.differential_weight,
            'migration_interval': self.migration_interval,
            'migration_amount': self.migration_amount,
            'archive_size': self.archive_size,
            'archive_prob': self.archive_prob
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
```

### Rank 6 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: ArchivalAdaptiveGaussianDE
# Description: Combines DE with an archive and adaptive Gaussian mutation for enhanced global exploration in deceptive landscapes.
# Code:
```python
import numpy as np
import random

# Name: ArchivalAdaptiveGaussianDE
# Description: Combines DE with an archive and adaptive Gaussian mutation for enhanced global exploration in deceptive landscapes.
# Code:
class ArchivalAdaptiveGaussianDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 population_size_factor: float = 10, archive_size_factor: float = 5, initial_sigma_factor: float = 0.2):
        """
        Initializes the ArchivalAdaptiveGaussianDE optimizer.

        Args:
            budget: The maximum number of function evaluations.
            dim: The dimensionality of the problem.
            lower_bounds: The lower bounds of the search space.
            upper_bounds: The upper bounds of the search space.
            population_size_factor: Factor to determine population size based on dim.
            archive_size_factor: Factor to determine archive size based on dim.
            initial_sigma_factor: Factor to determine initial sigma for Gaussian mutation.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.population_size = int(population_size_factor * self.dim)
        self.archive_size = int(archive_size_factor * self.dim)
        self.archive = []
        self.population = None
        self.sigma = initial_sigma_factor * (self.upper_bounds - self.lower_bounds)  # Initial Standard Deviation

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8,
                 archive_update_prob: float = 0.9, sigma_decay: float = 0.99) -> tuple:
        """
        Optimizes the given objective function using Archival Adaptive Gaussian DE.

        Args:
            objective_function: The function to be optimized.  Takes a 2D NumPy array X (shape (N, dim)) and returns a 1D NumPy array of N fitness values.
            acceptance_threshold:  DEPRECATED/UNUSED Stopping criterion based on fitness improvement
            archive_update_prob: The probability of updating the archive with a new solution.
            sigma_decay: The decay rate for the Gaussian mutation sigma.

        Returns:
            A tuple containing the best solution, its fitness, and optimization information.
        """
        self.eval_count = 0
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        fitness = objective_function(self.population)
        self.eval_count += self.population_size

        self.best_solution_overall = self.population[np.argmin(fitness)]
        self.best_fitness_overall = np.min(fitness)

        while self.eval_count < self.budget:
            offspring = self.generate_offspring(self.population, fitness)
            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            # Update archive
            self.update_archive(offspring, offspring_fitness, archive_update_prob)

            # Select best solutions for next generation
            combined_population = np.concatenate((self.population, offspring))
            combined_fitness = np.concatenate((fitness, offspring_fitness))
            indices = np.argsort(combined_fitness)
            self.population = combined_population[indices[:self.population_size]]
            fitness = combined_fitness[indices[:self.population_size]]

            # Update best solution
            best_index = np.argmin(fitness)
            if fitness[best_index] < self.best_fitness_overall:
                self.best_solution_overall = self.population[best_index]
                self.best_fitness_overall = fitness[best_index]
            
            # Decay sigma
            self.sigma *= sigma_decay

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'archive_size': len(self.archive)
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def generate_offspring(self, population, fitness):
        """Generates offspring using Differential Evolution with Gaussian mutation."""
        offspring = np.zeros((self.population_size, self.dim))
        for i in range(self.population_size):
            # DE part: Select random individuals
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            
            # Archive Guided: Use archive for pbest
            if self.archive:
                pbest_idx = random.randint(0, len(self.archive) - 1)
                pbest = self.archive[pbest_idx][0]
            else:
                pbest = population[np.argmin(fitness)]
            
            # Gaussian mutation instead of DE mutation part
            gaussian_mutation = np.random.normal(0, self.sigma, self.dim)

            offspring[i] = population[i] + 0.5 * (pbest - population[i]) + 0.5 * (population[a] - population[b]) + gaussian_mutation
            offspring[i] = np.clip(offspring[i], self.lower_bounds, self.upper_bounds)

        return offspring

    def update_archive(self, offspring, offspring_fitness, archive_update_prob):
         """Updates the archive with new solutions based on probability."""
         for i in range(len(offspring)):
              if random.random() < archive_update_prob:
                   if len(self.archive) < self.archive_size:
                        self.archive.append((offspring[i], offspring_fitness[i]))
                   else:
                        # Replace worst in archive
                        worst_index = np.argmax([f for _, f in self.archive])
                        if offspring_fitness[i] < self.archive[worst_index][1]:
                             self.archive[worst_index] = (offspring[i], offspring_fitness[i])
```

### Rank 7 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: IslandArchiveDifferentialEvolution
# Description: Combines island model with archive and adaptive differential evolution for multimodal exploration.
# Code:
```python
import numpy as np
import random

# Name: IslandArchiveDifferentialEvolution
# Description: Combines island model with archive and adaptive differential evolution for multimodal exploration.
# Code:
class IslandArchiveDifferentialEvolution:
    """
    Implements an island model with a local archive and adaptive differential evolution
    on each island to explore and exploit multiple basins of attraction.
    """

    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, archive_size: int = 10,
                 crossover_rate: float = 0.7, initial_differential_weight: float = 0.5,
                 migration_interval: int = 500, migration_amount: int = 2,
                 differential_weight_decay: float = 0.99):
        """
        Initializes the IslandArchiveDifferentialEvolution optimizer.

        Args:
            budget (int): Total function evaluation budget.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): Lower bounds of the search space.
            upper_bounds (list[float]): Upper bounds of the search space.
            num_islands (int): Number of independent populations (islands).
            population_size (int): Number of individuals in each island's population.
            archive_size (int): Size of the local archive for each island.
            crossover_rate (float): Probability of crossover in differential evolution.
            initial_differential_weight (float): Initial value of the differential weight (F).
            migration_interval (int): Interval (in evaluations) at which migration occurs.
            migration_amount (int): Number of individuals to migrate between islands.
            differential_weight_decay (float): Decay rate for the differential weight (F) per generation.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.num_islands = num_islands
        self.population_size = population_size
        self.archive_size = archive_size
        self.crossover_rate = crossover_rate
        self.initial_differential_weight = initial_differential_weight
        self.differential_weight = initial_differential_weight
        self.migration_interval = migration_interval
        self.migration_amount = migration_amount
        self.differential_weight_decay = differential_weight_decay  # Add decay parameter

        # Initialize islands
        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds,
                                            (self.population_size, self.dim))
            archive = np.zeros((self.archive_size, self.dim))
            archive_fitness = np.full(self.archive_size, float('inf')) #Archive fitness value
            self.islands.append({
                'population': population,
                'fitness': np.full(self.population_size, float('inf')),
                'best_solution': None,
                'best_fitness': float('inf'),
                'archive': archive,
                'archive_fitness': archive_fitness
            })

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        if self.dim > 0:
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        else:
            self.best_solution_overall = np.array([])
        self.best_fitness_overall = float('inf')

        # Initialize island populations and evaluate fitness + update archive
        for island in self.islands:
            island['fitness'] = objective_function(island['population'])
            self.eval_count += self.population_size
            best_index = np.argmin(island['fitness'])
            island['best_solution'] = island['population'][best_index].copy()
            island['best_fitness'] = island['fitness'][best_index]

            # Update archive with initial population
            self._update_archive(island, island['population'], island['fitness'])

            if island['best_fitness'] < self.best_fitness_overall:
                self.best_fitness_overall = island['best_fitness']
                self.best_solution_overall = island['best_solution'].copy()


        generation = 0
        while self.eval_count < self.budget:
            generation += 1
            self.differential_weight = self.initial_differential_weight * (self.differential_weight_decay ** generation) # Decay F

            for i, island in enumerate(self.islands):
                new_population = np.zeros_like(island['population'])
                new_fitness = np.zeros(self.population_size)

                for j in range(self.population_size):
                    # Differential Evolution Mutation: Use archive or population
                    if random.random() < 0.5:  #  Use Archive (adaptive strategy)
                      # select from population + archive
                        combined_population = np.concatenate((island['population'], island['archive']))
                        combined_fitness = np.concatenate((island['fitness'], island['archive_fitness'])) # dummy
                        
                        idxs = [idx for idx in range(len(combined_population)) if idx != j ]
                        a, b, c = random.sample(idxs, 3)

                        mutant = combined_population[a] + self.differential_weight * (combined_population[b] - combined_population[c]) # Use population or archive
                    
                    else: # Original differential evolution with F and crossover (adaptive strategy)
                        idxs = [idx for idx in range(self.population_size) if idx != j]
                        a, b, c = random.sample(idxs, 3)

                        mutant = island['population'][a] + self.differential_weight * (island['population'][b] - island['population'][c])
                    
                    mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

                    trial_vector = np.zeros(self.dim)
                    for k in range(self.dim):
                        if random.random() < self.crossover_rate or k == random.randint(0, self.dim - 1):
                            trial_vector[k] = mutant[k]
                        else:
                            trial_vector[k] = island['population'][j][k]

                    new_population[j] = trial_vector
                    new_fitness[j] = objective_function(new_population[j].reshape(1, -1))[0]
                    self.eval_count += 1
                    
                    # Selection and archive update
                    if new_fitness[j] < island['fitness'][j]:
                        island['population'][j] = new_population[j].copy()
                        island['fitness'][j] = new_fitness[j]
                        
                        # Local Archive update
                        self._update_archive(island, new_population[j].reshape(1,-1), np.array([new_fitness[j]])) # Adding one individual

                        if new_fitness[j] < island['best_fitness']:
                            island['best_solution'] = island['population'][j].copy()
                            island['best_fitness'] = new_fitness[j]

                            if new_fitness[j] < self.best_fitness_overall:
                                self.best_fitness_overall = new_fitness[j]
                                self.best_solution_overall = island['population'][j].copy()


            # Migration
            if generation % self.migration_interval == 0:
                self._migrate()


        if self.best_solution_overall is None and self.dim > 0:  # Fallback
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
    
    def _update_archive(self, island, solutions, fitness_values):
        """Updates the archive with new solutions."""
        archive = island['archive']
        archive_fitness = island['archive_fitness']
        
        for i in range(len(solutions)):
            solution = solutions[i]
            fitness = fitness_values[i]
            
            if fitness < np.max(archive_fitness):  # If better than worst in archive
                worst_index = np.argmax(archive_fitness)
                archive[worst_index] = solution.copy()
                archive_fitness[worst_index] = fitness
                
        island['archive'] = archive
        island['archive_fitness'] = archive_fitness
    

    def _migrate(self):
        """Migrates individuals between islands based on best fitness."""
        # Sort islands by best fitness
        sorted_islands = sorted(self.islands, key=lambda x: x['best_fitness'])

        # Migrate best individuals from top islands to worst islands
        for i in range(self.migration_amount):
            source_island = sorted_islands[i]
            target_island = sorted_islands[self.num_islands - 1 - i]

            # Replace random individuals in the target island with copies of the best individuals from the source island
            for _ in range(self.migration_amount):
                replace_index = random.randint(0, self.population_size - 1)
                target_island['population'][replace_index] = source_island['best_solution'].copy()

                # Evaluate migrated individual and Update
                target_island['fitness'][replace_index] = objective_function(target_island['population'][replace_index:replace_index+1])[0]

                # Local Archive Update
                self._update_archive(target_island, target_island['population'][replace_index:replace_index+1], target_island['fitness'][replace_index:replace_index+1])
                
                if target_island['fitness'][replace_index] < target_island['best_fitness']:
                    target_island['best_fitness'] = target_island['fitness'][replace_index]
                    target_island['best_solution'] = target_island['population'][replace_index].copy()
```

### Rank 8 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: IslandModelEnhancedDE
# Description: Implements a multi-island differential evolution with migration to promote global exploration in multimodal landscapes.
# Code:
```python
import numpy as np
import random

# Name: IslandModelEnhancedDE
# Description: Implements a multi-island differential evolution with migration to promote global exploration in multimodal landscapes.
# Code:
class IslandModelEnhancedDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size_per_island: int = 50, migration_interval: int = 1000,
                 migration_rate: float = 0.2, F: float = 0.7, CR: float = 0.9):
        """
        Initializes the IslandModelEnhancedDE algorithm.

        Args:
            budget (int): Total function evaluation budget.
            dim (int): Dimensionality of the problem.
            lower_bounds (list[float]): Lower bounds of the search space.
            upper_bounds (list[float]): Upper bounds of the search space.
            num_islands (int): Number of independent islands.
            population_size_per_island (int): Population size for each island.
            migration_interval (int): Number of evaluations between migration events.
            migration_rate (float): Fraction of the population to migrate.
            F (float): Differential evolution scaling factor.
            CR (float): Crossover rate for differential evolution.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.num_islands = num_islands
        self.population_size_per_island = population_size_per_island
        self.migration_interval = migration_interval
        self.migration_rate = migration_rate
        self.F = F
        self.CR = CR

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize islands
        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds,
                                            size=(self.population_size_per_island, self.dim))
            self.islands.append({
                'population': population,
                'fitness': np.full(self.population_size_per_island, float('inf')), # Initialize fitness to infinity
                'best_solution': None,
                'best_fitness': float('inf')
            })

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the objective function using the island model differential evolution.

        Args:
            objective_function (callable): The function to minimize.
            acceptance_threshold (float): Acceptance threshold for convergence.

        Returns:
            tuple: (best_solution, best_fitness, optimization_info)
        """
        self.eval_count = 0

        # Evaluate initial populations
        for i in range(self.num_islands):
            fitness = objective_function(self.islands[i]['population'])
            self.islands[i]['fitness'] = fitness
            self.eval_count += self.population_size_per_island
            best_index = np.argmin(fitness)
            self.islands[i]['best_solution'] = self.islands[i]['population'][best_index]
            self.islands[i]['best_fitness'] = fitness[best_index]

            if self.islands[i]['best_fitness'] < self.best_fitness_overall:
                self.best_fitness_overall = self.islands[i]['best_fitness']
                self.best_solution_overall = self.islands[i]['best_solution']

        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                # Differential Evolution on each island
                offspring = self.generate_offspring(self.islands[i]['population'])
                offspring_fitness = objective_function(offspring)
                self.eval_count += self.population_size_per_island #Since the way this is defined, size is constant

                # Selection
                for j in range(self.population_size_per_island):
                    if offspring_fitness[j] < self.islands[i]['fitness'][j]:
                        self.islands[i]['population'][j] = offspring[j]
                        self.islands[i]['fitness'][j] = offspring_fitness[j]

                # Update best solution on the island
                best_index = np.argmin(self.islands[i]['fitness'])
                if self.islands[i]['fitness'][best_index] < self.islands[i]['best_fitness']:
                    self.islands[i]['best_fitness'] = self.islands[i]['fitness'][best_index]
                    self.islands[i]['best_solution'] = self.islands[i]['population'][best_index]

                    # Update global best solution
                    if self.islands[i]['best_fitness'] < self.best_fitness_overall:
                        self.best_fitness_overall = self.islands[i]['best_fitness']
                        self.best_solution_overall = self.islands[i]['best_solution']

            # Migration
            if self.eval_count % self.migration_interval == 0:
                self.migrate()

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'num_islands': self.num_islands,
            'population_size_per_island': self.population_size_per_island,
            'migration_interval': self.migration_interval,
            'migration_rate': self.migration_rate,
            'F': self.F,
            'CR': self.CR
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def generate_offspring(self, population: np.ndarray) -> np.ndarray:
        """
        Generates offspring using differential evolution.

        Args:
            population (np.ndarray): The current population.

        Returns:
            np.ndarray: The generated offspring.
        """
        num_individuals = population.shape[0]
        offspring = np.zeros_like(population)

        for i in range(num_individuals):
            # Select three distinct individuals
            indices = list(range(num_individuals))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)

            # Mutation and crossover
            mutant = population[a] + self.F * (population[b] - population[c])
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)  # boundary handling

            # Crossover
            for j in range(self.dim):
                if random.random() < self.CR:
                    offspring[i, j] = mutant[j]
                else:
                    offspring[i, j] = population[i, j]

        return offspring

    def migrate(self):
        """
        Migrates individuals between islands.
        """
        # Sort islands by their best fitness (ascending)
        sorted_island_indices = sorted(range(self.num_islands), key=lambda i: self.islands[i]['best_fitness'])

        num_migrants = int(self.population_size_per_island * self.migration_rate)

        # Migrate from better islands to worse islands
        for i in range(self.num_islands // 2):  # Only migrate between half the islands
            source_island_index = sorted_island_indices[i] # Best to worst (migrator)
            destination_island_index = sorted_island_indices[self.num_islands - 1 - i]  #Worst to best (migrates to)
           # print(f"Migrating {num_migrants} from island {source_island_index} to island {destination_island_index}")
            # Select migrants from source island (best individuals)
            migrant_indices = np.argsort(self.islands[source_island_index]['fitness'])[:num_migrants]
            migrants = self.islands[source_island_index]['population'][migrant_indices].copy()

            # Replace random individuals in the destination island with the migrants
            replace_indices = random.sample(range(self.population_size_per_island), num_migrants)
            self.islands[destination_island_index]['population'][replace_indices] = migrants

            # Re-evaluate fitness of migrated individuals
            migrated_fitness = objective_function(migrants)
            self.eval_count += num_migrants

            self.islands[destination_island_index]['fitness'][replace_indices] = migrated_fitness

            #Update the best solutons after migration
            best_index = np.argmin(self.islands[destination_island_index]['fitness'])
            self.islands[destination_island_index]['best_solution'] = self.islands[destination_island_index]['population'][best_index]
            self.islands[destination_island_index]['best_fitness'] = self.islands[destination_island_index]['fitness'][best_index]
```



### Guide
Keep in mind, this is a list of design heuristics ranked from best to worst. The first algorithm in the list is the best performing on average, and the last is the worst.
Your response must be in Markdown format and contain nothing else. It must have the following structure:

"**Analysis:**
**Experience:**"

In there:
+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.
Example: "Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:"

+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).

I'm going to tip $999K for a better heuristics! Let's think step by step.
2025-06-25 08:51:55 INFO Full response text: **Analysis:**

Comparing (AdaptiveArchipelagoDE) vs (IslandModelEnhancedDE), we see AdaptiveArchipelagoDE utilizes an archive to guide mutation, and adaptive F/CR values, whereas IslandModelEnhancedDE uses standard DE mutation and fixed F/CR with simple island migration.

Comparing (AdaptiveArchiveDE) vs (ArchivalAdaptiveGaussianDE), AdaptiveArchiveDE features DE with an archive and dynamic population selection, while ArchivalAdaptiveGaussianDE incorporates DE with archive and adaptive Gaussian mutation.

Comparing (AdaptiveIslandArchiveEA) vs (IslandArchiveDifferentialEvolution), AdaptiveIslandArchiveEA integrates an island model with adaptive Gaussian mutation and an archive, while IslandArchiveDifferentialEvolution combines an island model with DE, crossover and archive management, plus some adaptive features. AdaptiveIslandArchiveEA features tournament selection and adaptive sigma, both of which might help with global exploration.

Comparing (AdaptArchiveGuidedEvolution) vs (ArchipelagoArchiveDE), AdaptArchiveGuidedEvolution utilizes an archive-guided mutation and adaptive sigma, while ArchipelagoArchiveDE uses an island model with archive-based mutation and migration.

Comparing (second worst) vs (worst), we see that IslandArchiveDifferentialEvolution introduces adaptive weight decay;  IslandModelEnhancedDE only includes basic island model, while IslandArchiveDifferentialEvolution incorporates archive and differential evolution to add adaptive weight decay that assists global searching and escaping from local optima.

Comparing (1st) vs (2nd), we see AdaptiveArchipelagoDE has full parameter adaptation whereas AdaptiveArchiveDE does not. AdaptiveArchipelagoDE uses an island model while AdaptiveArchiveDE works with a single population.

Comparing (3rd) vs (4th), we see that AdaptiveIslandArchiveEA incorporates island model more thoroughly, uses adaptive step size which can prove vital for exploration; AdaptArchiveGuidedEvolution only focuses on direct archival guidance.

Overall: The better performing algorithms consistently combine differential evolution with an archive for memory and knowledge transfer. They often include adaptive parameters (F, CR, sigma) to adjust exploration/exploitation. Island models provide a framework for parallel, diverse search. Poorer performing algorithms lack adaptive features, advanced selection mechanisms (like tournament selection), effective exploration strategies, and sophisticated migration schemes.

**Experience:**

Effective global optimization in deceptive landscapes requires a blend of memory, exploration, and adaptation. Archive-guided mutation enhances exploitation of past successes, while adaptive parameters dynamically tune the balance between exploration and exploitation. Island models offer diversity and parallelism to better search distinct basins of attraction. Implement some parameter auto-tuning to improve the result.

2025-06-25 08:51:56 INFO Full response text: Okay, here's a reframing of "current self-reflection" focused on improved heuristic design for deceptive landscapes, incorporating your feedback and reward!

**Keywords:** Memory exploitation, exploration-exploitation balance, adaptive parameters, diversity maintenance, parallel search.

**Advice:** Design heuristics that intelligently remember promising regions, dynamically adjust exploration intensity, leverage island models for diversification, and incorporate mechanisms for parameter self-tuning.

**Avoid:** Overly complex adaptation mechanisms, focusing solely on normalized diversity.

**Explanation:** The goal is a flexible, self-adjusting search strategy that effectively exploits past successes while maintaining sufficient diversity to escape local optima in deceptive problem spaces.

2025-06-25 08:51:56 INFO Generating offspring via Crossover...
2025-06-25 08:56:26 INFO Crossover Prompt: **(CR: Capacity and Role)**
Act as an expert in designing algorithms for deceptive, multi-component landscapes. Your specialty is creating strategies that use multi-population or island models to perform aggressive global exploration.

**(I: Insight)**
Your objective is to design a novel optimization algorithm for the GNBG benchmark. The most difficult functions (f16-f24) have multiple, separate basins of attraction where the global optimum can be hidden. An algorithm must be able to discover and explore these competing regions to succeed.

**(S: Statement & P: Personality)**
Provide a complete, novel Python class that implements a multi-population or island-based search strategy to solve this challenge. The class must have an `__init__(...)` and `optimize(...)` method as specified in the main task description.


### Better code
IslandModelEnhancedDE
import numpy as np
import random

# Name: IslandModelEnhancedDE
# Description: Implements a multi-island differential evolution with migration to promote global exploration in multimodal landscapes.
# Code:
class IslandModelEnhancedDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size_per_island: int = 50, migration_interval: int = 1000,
                 migration_rate: float = 0.2, F: float = 0.7, CR: float = 0.9):
        """
        Initializes the IslandModelEnhancedDE algorithm.

        Args:
            budget (int): Total function evaluation budget.
            dim (int): Dimensionality of the problem.
            lower_bounds (list[float]): Lower bounds of the search space.
            upper_bounds (list[float]): Upper bounds of the search space.
            num_islands (int): Number of independent islands.
            population_size_per_island (int): Population size for each island.
            migration_interval (int): Number of evaluations between migration events.
            migration_rate (float): Fraction of the population to migrate.
            F (float): Differential evolution scaling factor.
            CR (float): Crossover rate for differential evolution.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.num_islands = num_islands
        self.population_size_per_island = population_size_per_island
        self.migration_interval = migration_interval
        self.migration_rate = migration_rate
        self.F = F
        self.CR = CR

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize islands
        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds,
                                            size=(self.population_size_per_island, self.dim))
            self.islands.append({
                'population': population,
                'fitness': np.full(self.population_size_per_island, float('inf')), # Initialize fitness to infinity
                'best_solution': None,
                'best_fitness': float('inf')
            })

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the objective function using the island model differential evolution.

        Args:
            objective_function (callable): The function to minimize.
            acceptance_threshold (float): Acceptance threshold for convergence.

        Returns:
            tuple: (best_solution, best_fitness, optimization_info)
        """
        self.eval_count = 0

        # Evaluate initial populations
        for i in range(self.num_islands):
            fitness = objective_function(self.islands[i]['population'])
            self.islands[i]['fitness'] = fitness
            self.eval_count += self.population_size_per_island
            best_index = np.argmin(fitness)
            self.islands[i]['best_solution'] = self.islands[i]['population'][best_index]
            self.islands[i]['best_fitness'] = fitness[best_index]

            if self.islands[i]['best_fitness'] < self.best_fitness_overall:
                self.best_fitness_overall = self.islands[i]['best_fitness']
                self.best_solution_overall = self.islands[i]['best_solution']

        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                # Differential Evolution on each island
                offspring = self.generate_offspring(self.islands[i]['population'])
                offspring_fitness = objective_function(offspring)
                self.eval_count += self.population_size_per_island #Since the way this is defined, size is constant

                # Selection
                for j in range(self.population_size_per_island):
                    if offspring_fitness[j] < self.islands[i]['fitness'][j]:
                        self.islands[i]['population'][j] = offspring[j]
                        self.islands[i]['fitness'][j] = offspring_fitness[j]

                # Update best solution on the island
                best_index = np.argmin(self.islands[i]['fitness'])
                if self.islands[i]['fitness'][best_index] < self.islands[i]['best_fitness']:
                    self.islands[i]['best_fitness'] = self.islands[i]['fitness'][best_index]
                    self.islands[i]['best_solution'] = self.islands[i]['population'][best_index]

                    # Update global best solution
                    if self.islands[i]['best_fitness'] < self.best_fitness_overall:
                        self.best_fitness_overall = self.islands[i]['best_fitness']
                        self.best_solution_overall = self.islands[i]['best_solution']

            # Migration
            if self.eval_count % self.migration_interval == 0:
                self.migrate()

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'num_islands': self.num_islands,
            'population_size_per_island': self.population_size_per_island,
            'migration_interval': self.migration_interval,
            'migration_rate': self.migration_rate,
            'F': self.F,
            'CR': self.CR
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def generate_offspring(self, population: np.ndarray) -> np.ndarray:
        """
        Generates offspring using differential evolution.

        Args:
            population (np.ndarray): The current population.

        Returns:
            np.ndarray: The generated offspring.
        """
        num_individuals = population.shape[0]
        offspring = np.zeros_like(population)

        for i in range(num_individuals):
            # Select three distinct individuals
            indices = list(range(num_individuals))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)

            # Mutation and crossover
            mutant = population[a] + self.F * (population[b] - population[c])
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)  # boundary handling

            # Crossover
            for j in range(self.dim):
                if random.random() < self.CR:
                    offspring[i, j] = mutant[j]
                else:
                    offspring[i, j] = population[i, j]

        return offspring

    def migrate(self):
        """
        Migrates individuals between islands.
        """
        # Sort islands by their best fitness (ascending)
        sorted_island_indices = sorted(range(self.num_islands), key=lambda i: self.islands[i]['best_fitness'])

        num_migrants = int(self.population_size_per_island * self.migration_rate)

        # Migrate from better islands to worse islands
        for i in range(self.num_islands // 2):  # Only migrate between half the islands
            source_island_index = sorted_island_indices[i] # Best to worst (migrator)
            destination_island_index = sorted_island_indices[self.num_islands - 1 - i]  #Worst to best (migrates to)
           # print(f"Migrating {num_migrants} from island {source_island_index} to island {destination_island_index}")
            # Select migrants from source island (best individuals)
            migrant_indices = np.argsort(self.islands[source_island_index]['fitness'])[:num_migrants]
            migrants = self.islands[source_island_index]['population'][migrant_indices].copy()

            # Replace random individuals in the destination island with the migrants
            replace_indices = random.sample(range(self.population_size_per_island), num_migrants)
            self.islands[destination_island_index]['population'][replace_indices] = migrants

            # Re-evaluate fitness of migrated individuals
            migrated_fitness = objective_function(migrants)
            self.eval_count += num_migrants

            self.islands[destination_island_index]['fitness'][replace_indices] = migrated_fitness

            #Update the best solutons after migration
            best_index = np.argmin(self.islands[destination_island_index]['fitness'])
            self.islands[destination_island_index]['best_solution'] = self.islands[destination_island_index]['population'][best_index]
            self.islands[destination_island_index]['best_fitness'] = self.islands[destination_island_index]['fitness'][best_index]

### Worse code
AdaptiveArchiveDE
import numpy as np
import random

# Name: AdaptiveArchiveDE
# Description: Integrates adaptive differential evolution with an archive for enhanced exploration and exploitation in multimodal optimization.
# Code:
class AdaptiveArchiveDE:
    """
    Combines adaptive differential evolution with an archive-based strategy
    to balance exploration and exploitation, enhancing its ability to navigate
    multimodal landscapes effectively.
    """
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 population_size: int = 50, archive_size: int = 100, initial_F: float = 0.5, initial_CR: float = 0.9):
        """
        Initializes the AdaptiveArchiveDE algorithm.

        Args:
            budget (int): The maximum number of function evaluations.
            dim (int): The dimensionality of the problem.
            lower_bounds (list[float]): A list of lower bounds for each dimension.
            upper_bounds (list[float]): A list of upper bounds for each dimension.
            population_size (int): The number of individuals in the population.
            archive_size (int): The maximum size of the archive.
            initial_F (float): Initial differential evolution scale factor.
            initial_CR (float): Initial crossover rate.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.population_size = population_size
        self.archive_size = archive_size
        self.archive = []
        self.population = None
        self.F = initial_F  # Differential evolution parameter
        self.CR = initial_CR # Crossover rate


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using Adaptive Archive DE.

        Args:
            objective_function (callable): The objective function to minimize.
            acceptance_threshold (float): Threshold for accepting a solution.

        Returns:
            tuple: A tuple containing the best solution, its fitness, and
                   a dictionary containing optimization information.
        """

        self.eval_count = 0

        # Initialize population
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        fitness = objective_function(self.population)
        self.eval_count += self.population_size
        
        self.best_solution_overall = self.population[np.argmin(fitness)]
        self.best_fitness_overall = np.min(fitness)

        while self.eval_count < self.budget:
            # Generate offspring using differential evolution
            offspring = self.generate_offspring(objective_function)
            
            # Evaluate offspring
            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            # Update archive
            self.update_archive(offspring, offspring_fitness)

            # Select individuals for the next generation
            self.population, fitness = self.select_next_generation(offspring, offspring_fitness, fitness)
            
            # Update best solution found so far
            best_index = np.argmin(fitness)
            if fitness[best_index] < self.best_fitness_overall:
                self.best_fitness_overall = fitness[best_index]
                self.best_solution_overall = self.population[best_index]

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'archive_size': len(self.archive)
        }

        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def generate_offspring(self, objective_function: callable) -> np.ndarray:
        """
        Generates offspring using differential evolution with archive guidance.
        """
        offspring = np.zeros((self.population_size, self.dim))

        for i in range(self.population_size):
            # Select pbest from archive or population
            if self.archive:
                pbest = random.choice(self.archive)[0]  # Use archive individual
            else:
                 pbest = self.population[np.argmin(objective_function(self.population))] #Fallback if the archive is empty

            # Ensure a, b, c are different and not equal to i
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b = random.sample(indices, 2)

            # Differential evolution mutation
            mutation_vector = pbest + self.F * (self.population[a] - self.population[b])

            # Crossover operation
            for j in range(self.dim):
                if random.random() < self.CR:
                    offspring[i][j] = mutation_vector[j]
                else:
                    offspring[i][j] = self.population[i][j]

            # Clip to bounds
            offspring[i] = np.clip(offspring[i], self.lower_bounds, self.upper_bounds)

        return offspring

    def update_archive(self, offspring, offspring_fitness):
        """
        Updates the archive with new solutions, prioritizing diversity.
        """
        for i in range(len(offspring)):
            # If the archive isn't full just add the vector
            if len(self.archive) < self.archive_size:
                self.archive.append((offspring[i], offspring_fitness[i]))
            else:
                #Replace the worst value with the offspring value if the offspring's fitness is better
                worst_index = np.argmax([f for _, f in self.archive])
                if offspring_fitness[i] < self.archive[worst_index][1]:
                    self.archive[worst_index] = (offspring[i], offspring_fitness[i])
                else:
                    pass

    def select_next_generation(self, offspring, offspring_fitness, fitness):
        """Selects the next population based on fitness."""
        combined_population = np.concatenate((self.population, offspring))
        combined_fitness = np.concatenate((fitness, offspring_fitness))
        indices = np.argsort(combined_fitness)[:self.population_size]
        return combined_population[indices], combined_fitness[indices]

### Analyze & experience
- Comparing (AdaptiveArchipelagoDE) vs (IslandModelEnhancedDE), we see AdaptiveArchipelagoDE utilizes an archive to guide mutation, and adaptive F/CR values, whereas IslandModelEnhancedDE uses standard DE mutation and fixed F/CR with simple island migration.

Comparing (AdaptiveArchiveDE) vs (ArchivalAdaptiveGaussianDE), AdaptiveArchiveDE features DE with an archive and dynamic population selection, while ArchivalAdaptiveGaussianDE incorporates DE with archive and adaptive Gaussian mutation.

Comparing (AdaptiveIslandArchiveEA) vs (IslandArchiveDifferentialEvolution), AdaptiveIslandArchiveEA integrates an island model with adaptive Gaussian mutation and an archive, while IslandArchiveDifferentialEvolution combines an island model with DE, crossover and archive management, plus some adaptive features. AdaptiveIslandArchiveEA features tournament selection and adaptive sigma, both of which might help with global exploration.

Comparing (AdaptArchiveGuidedEvolution) vs (ArchipelagoArchiveDE), AdaptArchiveGuidedEvolution utilizes an archive-guided mutation and adaptive sigma, while ArchipelagoArchiveDE uses an island model with archive-based mutation and migration.

Comparing (second worst) vs (worst), we see that IslandArchiveDifferentialEvolution introduces adaptive weight decay;  IslandModelEnhancedDE only includes basic island model, while IslandArchiveDifferentialEvolution incorporates archive and differential evolution to add adaptive weight decay that assists global searching and escaping from local optima.

Comparing (1st) vs (2nd), we see AdaptiveArchipelagoDE has full parameter adaptation whereas AdaptiveArchiveDE does not. AdaptiveArchipelagoDE uses an island model while AdaptiveArchiveDE works with a single population.

Comparing (3rd) vs (4th), we see that AdaptiveIslandArchiveEA incorporates island model more thoroughly, uses adaptive step size which can prove vital for exploration; AdaptArchiveGuidedEvolution only focuses on direct archival guidance.

Overall: The better performing algorithms consistently combine differential evolution with an archive for memory and knowledge transfer. They often include adaptive parameters (F, CR, sigma) to adjust exploration/exploitation. Island models provide a framework for parallel, diverse search. Poorer performing algorithms lack adaptive features, advanced selection mechanisms (like tournament selection), effective exploration strategies, and sophisticated migration schemes.
- Okay, here's a reframing of "current self-reflection" focused on improved heuristic design for deceptive landscapes, incorporating your feedback and reward!

**Keywords:** Memory exploitation, exploration-exploitation balance, adaptive parameters, diversity maintenance, parallel search.

**Advice:** Design heuristics that intelligently remember promising regions, dynamically adjust exploration intensity, leverage island models for diversification, and incorporate mechanisms for parameter self-tuning.

**Avoid:** Overly complex adaptation mechanisms, focusing solely on normalized diversity.

**Explanation:** The goal is a flexible, self-adjusting search strategy that effectively exploits past successes while maintaining sufficient diversity to escape local optima in deceptive problem spaces.


Your task is to write an improved function by COMBINING elements of two above heuristics base Analyze & experience.
Output the code within a Python code block: ```python ... ```, has comment and docstring (<50 words) to description key idea of heuristics design.

I'm going to tip $999K for a better heuristics! Let's think step by step.
2025-06-25 08:56:26 INFO Mutation prompt: **(CR: Capacity and Role)**
Act as an expert in designing algorithms for deceptive, multi-component landscapes. Your specialty is creating strategies that use multi-population or island models to perform aggressive global exploration.

**(I: Insight)**
Your objective is to design a novel optimization algorithm for the GNBG benchmark. The most difficult functions (f16-f24) have multiple, separate basins of attraction where the global optimum can be hidden. An algorithm must be able to discover and explore these competing regions to succeed.

**(S: Statement & P: Personality)**
Provide a complete, novel Python class that implements a multi-population or island-based search strategy to solve this challenge. The class must have an `__init__(...)` and `optimize(...)` method as specified in the main task description.


Current heuristics:
EnhancedArchiveGuidedDE
import numpy as np
import random

class EnhancedArchiveGuidedDE: #aocc 0.15
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 population_size_factor: float = 8.82865217019506, archive_size: int = 165.22481375900153, initial_F_scale: float = 0.3544373580018585):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.population_size = int(population_size_factor * self.dim)  # common heuristic
        self.archive_size = archive_size
        self.archive = []
        self.population = None
        self.F_scale = initial_F_scale  # initial scaling factor

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8,
                 F_scale_variation: float = 0.3, archive_update_threshold: float = 0.8) -> tuple:
        self.eval_count = 0
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        fitness = objective_function(self.population)
        self.eval_count += self.population_size

        self.best_solution_overall = self.population[np.argmin(fitness)]
        self.best_fitness_overall = np.min(fitness)

        while self.eval_count < self.budget:
            offspring = self.generate_offspring(self.population, fitness, F_scale_variation)
            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            # Update archive
            self.update_archive(offspring, offspring_fitness, archive_update_threshold)

            # Select best solutions for next generation
            combined_population = np.concatenate((self.population, offspring))
            combined_fitness = np.concatenate((fitness, offspring_fitness))
            indices = np.argsort(combined_fitness)
            self.population = combined_population[indices[:self.population_size]]
            fitness = combined_fitness[indices[:self.population_size]]

            # Update best solution
            self.best_solution_overall = self.population[np.argmin(fitness)]
            self.best_fitness_overall = np.min(fitness)

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'archive_size': len(self.archive)
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def generate_offspring(self, population, fitness, F_scale_variation):
        offspring = np.zeros((self.population_size, self.dim))
        # Adaptive scaling factor
        self.F_scale = 0.5 + F_scale_variation * np.random.rand()  # scale factor with slight variation

        for i in range(self.population_size):
            # Select pbest from archive (if available)
            if self.archive:
                pbest_index = np.random.choice(len(self.archive))
                pbest = self.archive[pbest_index][0]
            else:
                pbest = population[np.argmin(fitness)]

            a, b, c = random.sample(range(self.population_size), 3)
            while a == i or b == i or c == i:
                a, b, c = random.sample(range(self.population_size), 3)

            offspring[i] = population[i] + self.F_scale * (pbest - population[i] + population[a] - population[b])
            offspring[i] = np.clip(offspring[i], self.lower_bounds, self.upper_bounds)  # Boundary handling

        return offspring

    def update_archive(self, offspring, offspring_fitness, archive_update_threshold):
        for i in range(len(offspring)):
            if len(self.archive) < self.archive_size:
                self.archive.append((offspring[i], offspring_fitness[i]))
            else:
                # Prioritize diversity in archive
                worst_index = np.argmax([f for _, f in self.archive])
                if offspring_fitness[i] < self.archive[worst_index][1] or len(self.archive) < self.archive_size * archive_update_threshold:
                    self.archive[worst_index] = (offspring[i], offspring_fitness[i])

Now, think outside the box write a mutated function better than current version.
You can use some hints below:
- Okay, here's a reframing of "current self-reflection" focused on improved heuristic design for deceptive landscapes, incorporating your feedback and reward!

**Keywords:** Memory exploitation, exploration-exploitation balance, adaptive parameters, diversity maintenance, parallel search.

**Advice:** Design heuristics that intelligently remember promising regions, dynamically adjust exploration intensity, leverage island models for diversification, and incorporate mechanisms for parameter self-tuning.

**Avoid:** Overly complex adaptation mechanisms, focusing solely on normalized diversity.

**Explanation:** The goal is a flexible, self-adjusting search strategy that effectively exploits past successes while maintaining sufficient diversity to escape local optima in deceptive problem spaces.


Output code only and enclose your code with Python code block: ```python ... ```.
I'm going to tip $999K for a better solution!
2025-06-25 08:59:16 INFO Perform Harmony Search...
2025-06-25 08:59:23 WARNING No replacements made in template string. Returning None.
2025-06-25 08:59:30 WARNING No replacements made in template string. Returning None.
2025-06-25 08:59:36 WARNING No replacements made in template string. Returning None.
2025-06-25 08:59:36 INFO Generation 2, best so far: 0.3904505301102681
2025-06-25 08:59:36 INFO Population length is: 9
2025-06-25 08:59:36 INFO --- Performing Long-Term Reflection at Generation 3 ---
2025-06-25 08:59:36 INFO Reflection Prompt: ### Problem Description
**(CR: Capacity and Role)**
Act as an expert in designing algorithms for deceptive, multi-component landscapes. Your specialty is creating strategies that use multi-population or island models to perform aggressive global exploration.

**(I: Insight)**
Your objective is to design a novel optimization algorithm for the GNBG benchmark. The most difficult functions (f16-f24) have multiple, separate basins of attraction where the global optimum can be hidden. An algorithm must be able to discover and explore these competing regions to succeed.

**(S: Statement & P: Personality)**
Provide a complete, novel Python class that implements a multi-population or island-based search strategy to solve this challenge. The class must have an `__init__(...)` and `optimize(...)` method as specified in the main task description.

### List heuristics
Below is a list of design heuristics ranked from best to worst based on their AOCC score on group function 3 of GNBG benchmark, where higher is better. To enable a detailed analysis of their specializations, the performance breakdown on each of the three GNBG function groups is also provided.
### Rank 1 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptIslandArchiveGaussianDE
# Description: Island model with adaptive Gaussian mutation, archive, and migration for multi-basin landscapes.
# Code:
```python
import numpy as np
import random

# Name: AdaptIslandArchiveGaussianDE
# Description: Island model with adaptive Gaussian mutation, archive, and migration for multi-basin landscapes.
# Code:
class AdaptIslandArchiveGaussianDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size_factor: float = 10, archive_size_factor: float = 5,
                 migration_interval: int = 50, migration_size: int = 2):
        """
        Initializes the AdaptIslandArchiveGaussianDE algorithm.

        Args:
            budget (int): The maximum number of function evaluations.
            dim (int): The dimensionality of the problem.
            lower_bounds (list[float]): A list of lower bounds for each dimension.
            upper_bounds (list[float]): A list of upper bounds for each dimension.
            num_islands (int, optional): The number of islands in the island model. Defaults to 5.
            population_size_factor (float, optional): The factor to multiply the dimension by to get the population size for each island. Defaults to 10.
            archive_size_factor (float, optional): The factor to multiply the dimension by to get the archive size for each island. Defaults to 5.
            migration_interval (int, optional): The number of generations between migrations. Defaults to 50.
            migration_size (int, optional): The number of individuals to migrate between islands. Defaults to 2.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = int(population_size_factor * self.dim)
        self.archive_size = int(archive_size_factor * self.dim)
        self.migration_interval = migration_interval
        self.migration_size = migration_size

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.islands = []
        for _ in range(self.num_islands):
            self.islands.append({
                'population': np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim)),
                'fitness': None,
                'archive': [],
                'best_solution': None,
                'best_fitness': float('inf'),
                'sigma': 0.1  # Initial step size for Gaussian mutation
            })

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the AdaptIslandArchiveGaussianDE algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float, optional): The acceptance threshold for considering a solution as optimal. Defaults to 1e-8.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0

        for island in self.islands:
            island['fitness'] = objective_function(island['population'])
            self.eval_count += self.population_size
            island['best_solution'] = island['population'][np.argmin(island['fitness'])]
            island['best_fitness'] = np.min(island['fitness'])

            if island['best_fitness'] < self.best_fitness_overall:
                self.best_fitness_overall = island['best_fitness']
                self.best_solution_overall = island['best_solution']

        generation = 0
        while self.eval_count < self.budget:
            for i, island in enumerate(self.islands):
                # Generate offspring using adaptive Gaussian mutation and archive
                offspring = self.generate_offspring(island)
                offspring_fitness = objective_function(offspring)
                self.eval_count += len(offspring)

                # Update archive
                self.update_archive(island, offspring, offspring_fitness)

                # Select survivors (new population) using tournament selection
                island['population'], island['fitness'] = self.tournament_selection(island['population'], island['fitness'], offspring, offspring_fitness)

                # Update best solution for the island
                island['best_solution'] = island['population'][np.argmin(island['fitness'])]
                island['best_fitness'] = np.min(island['fitness'])

                #Update global best
                if island['best_fitness'] < self.best_fitness_overall:
                    self.best_fitness_overall = island['best_fitness']
                    self.best_solution_overall = island['best_solution']

                # Adapt sigma
                self.adapt_sigma(island)

            # Migration
            if generation % self.migration_interval == 0 and self.num_islands > 1:
                self.migrate_individuals()

            generation += 1

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def generate_offspring(self, island):
        """Generates offspring using adaptive Gaussian mutation and the archive."""
        offspring = np.zeros((self.population_size, self.dim))
        for i in range(self.population_size):
            #Base vector from population
            base_vector = island['population'][i]
            
            # Mutation using pbest
            if island['archive']:
                pbest_index = np.random.choice(len(island['archive']))
                pbest = island['archive'][pbest_index][0]
            else:
                pbest = island['population'][np.argmin(island['fitness'])]
            
            # Adaptive gaussian mutation based on base vector and best
            offspring[i] = base_vector + island['sigma'] * np.random.normal(0, 1, self.dim) + 0.1*(pbest - base_vector)
            offspring[i] = np.clip(offspring[i], self.lower_bounds, self.upper_bounds)

        return offspring

    def update_archive(self, island, offspring, offspring_fitness):
         """Update the archive with new individuals"""
         for i in range(len(offspring)):
            if len(island['archive']) < self.archive_size:
                island['archive'].append((offspring[i], offspring_fitness[i]))
            else:
                # Replace worst element in archive if offspring is better
                worst_index = np.argmax([f for _, f in island['archive']])
                if offspring_fitness[i] < island['archive'][worst_index][1]:
                    island['archive'][worst_index] = (offspring[i], offspring_fitness[i])

    def tournament_selection(self, population, fitness, offspring, offspring_fitness, tournament_size=2):
        """Selects the next generation using tournament selection."""
        combined_population = np.concatenate((population, offspring))
        combined_fitness = np.concatenate((fitness, offspring_fitness))
        new_population = np.zeros((self.population_size, self.dim))
        new_fitness = np.zeros(self.population_size)

        for i in range(self.population_size):
            # Select tournament participants
            indices = np.random.choice(len(combined_population), tournament_size, replace=False)
            tournament_fitness = combined_fitness[indices]
            winner_index = indices[np.argmin(tournament_fitness)]
            new_population[i] = combined_population[winner_index]
            new_fitness[i] = combined_fitness[winner_index]

        return new_population, new_fitness
    
    def adapt_sigma(self, island):
        """Adapt sigma based on island fitness improvement"""
        if len(island['archive']) > 2:
             archive_fitness = np.array([fitness for _, fitness in island['archive']])
             if np.std(archive_fitness) > 0.00001:
                 island['sigma'] *= 0.9  #Reduce if improving and maintaining exploration
             else:
                  island['sigma'] *= 1.1 #In crease exploration if stagnation appears

        island['sigma'] = np.clip(island['sigma'], 0.0001, 0.5) #Clamp for avoid extremes


    def migrate_individuals(self):
        """Migrates individuals between islands."""
        # Select random islands
        island_indices = list(range(self.num_islands))
        random.shuffle(island_indices)

        for i in range(0, self.num_islands, 2): #Migrate in pairs
            if i + 1 < self.num_islands:
                # Select individuals to migrate from island 1 to island 2
                island1_index = island_indices[i]
                island2_index = island_indices[i+1]
                island1 = self.islands[island1_index]
                island2 = self.islands[island2_index]

                # Select best individuals to migrate
                indices1 = np.argsort(island1['fitness'])[:self.migration_size]
                migrants1 = island1['population'][indices1]

                #Replace individuals on island 2
                indices2 = np.random.choice(self.population_size, self.migration_size, replace=False)
                island2['population'][indices2] = migrants1
                island2['fitness'][indices2] = objective_function(migrants1)

                # Same for the reverse direction
                indices2 = np.argsort(island2['fitness'])[:self.migration_size]
                migrants2 = island2['population'][indices2]

                indices1 = np.random.choice(self.population_size, self.migration_size, replace=False)
                island1['population'][indices1] = migrants2
                island1['fitness'][indices1] = objective_function(migrants2)
```

### Rank 2 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptiveArchipelagoDE_v2
# Description: Combines island-based DE with archive, adaptive F/CR, and migration for aggressive multimodal exploration.
# Code:
```python
import numpy as np
import random

# Name: AdaptiveArchipelagoDE_v2
# Description: Combines island-based DE with archive, adaptive F/CR, and migration for aggressive multimodal exploration.
# Code:
class AdaptiveArchipelagoDE_v2:
    """
    Implements an island model with archive, adaptive differential evolution, and migration
    to aggressively explore and exploit multiple basins of attraction in deceptive landscapes.
    """

    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, archive_size: int = 20,
                 initial_F: float = 0.5, initial_CR: float = 0.7, migration_interval: int = 500,
                 migration_amount: int = 2, F_adapt_rate: float = 0.1, CR_adapt_rate: float = 0.1):
        """
        Initializes the AdaptiveArchipelagoDE optimizer.

        Args:
            budget (int): Total function evaluation budget.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): Lower bounds of the search space.
            upper_bounds (list[float]): Upper bounds of the search space.
            num_islands (int): Number of independent populations (islands).
            population_size (int): Number of individuals in each island's population.
            archive_size (int): Size of the local archive for each island.
            initial_F (float): Initial value of the differential weight (F).
            initial_CR (float): Initial value of the crossover rate (CR).
            migration_interval (int): Interval (in evaluations) at which migration occurs.
            migration_amount (int): Number of individuals to migrate between islands.
            F_adapt_rate (float): Learning rate for adapting F.
            CR_adapt_rate (float): Learning rate for adapting CR.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.num_islands = num_islands
        self.population_size = population_size
        self.archive_size = archive_size
        self.initial_F = initial_F
        self.initial_CR = initial_CR
        self.migration_interval = migration_interval
        self.migration_amount = migration_amount
        self.F_adapt_rate = F_adapt_rate
        self.CR_adapt_rate = CR_adapt_rate

        # Initialize islands
        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds,
                                            (self.population_size, self.dim))
            archive = []
            self.islands.append({
                'population': population,
                'fitness': np.full(self.population_size, float('inf')),
                'best_solution': None,
                'best_fitness': float('inf'),
                'archive': archive,
                'F': self.initial_F,
                'CR': self.initial_CR
            })

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        if self.dim > 0:
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        else:
            self.best_solution_overall = np.array([])
        self.best_fitness_overall = float('inf')

        # Initialize island populations
        for island in self.islands:
            island['fitness'] = objective_function(island['population'])
            self.eval_count += self.population_size
            best_index = np.argmin(island['fitness'])
            island['best_solution'] = island['population'][best_index].copy()
            island['best_fitness'] = island['fitness'][best_index]

            if island['best_fitness'] < self.best_fitness_overall:
                self.best_fitness_overall = island['best_fitness']
                self.best_solution_overall = island['best_solution'].copy()

        generation = 0
        while self.eval_count < self.budget:
            generation += 1

            for i, island in enumerate(self.islands):
                new_population = np.zeros_like(island['population'])
                new_fitness = np.zeros(self.population_size)
                successful_F = []
                successful_CR = []

                for j in range(self.population_size):
                    # Adaptive F and CR: Sample from normal distribution centered on current values
                    F = np.clip(np.random.normal(island['F'], self.F_adapt_rate), 0.1, 1.0)  #F bounds 0.1 to 1
                    CR = np.clip(np.random.normal(island['CR'], self.CR_adapt_rate), 0.1, 1.0)

                    # Differential Evolution Mutation
                    if island['archive']:
                        # Select a pbest solution from the archive or population
                        if random.random() < 0.5: # Adaptive use of archive
                            pbest = random.choice(island['archive'])[0]
                        else:
                            pbest = island['population'][np.argmin(island['fitness'])]  #Best member
                    else:
                        pbest = island['population'][np.argmin(island['fitness'])] #If archive is empty uses population best

                    idxs = [idx for idx in range(self.population_size) if idx != j]
                    a, b = random.sample(idxs, 2)

                    mutant = pbest + F * (island['population'][a] - island['population'][b])
                    mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

                    # Crossover
                    trial_vector = np.zeros(self.dim)
                    for k in range(self.dim):
                        if random.random() < CR or k == random.randint(0, self.dim - 1):
                            trial_vector[k] = mutant[k]
                        else:
                            trial_vector[k] = island['population'][j][k]

                    new_population[j] = trial_vector
                    new_fitness[j] = objective_function(new_population[j].reshape(1, -1))[0]
                    self.eval_count += 1

                    # Selection
                    if new_fitness[j] < island['fitness'][j]:
                        successful_F.append(F)
                        successful_CR.append(CR)
                        
                        island['population'][j] = new_population[j].copy()
                        island['fitness'][j] = new_fitness[j]

                        # Archive Update
                        island['archive'].append((new_population[j].copy(), new_fitness[j]))
                        if len(island['archive']) > self.archive_size:
                            worst_archive_index = np.argmax([f for _, f in island['archive']])
                            del island['archive'][worst_archive_index] #Remove the archive value with the worst index.

                        if new_fitness[j] < island['best_fitness']:
                            island['best_solution'] = island['population'][j].copy()
                            island['best_fitness'] = new_fitness[j]

                            if new_fitness[j] < self.best_fitness_overall:
                                self.best_fitness_overall = new_fitness[j]
                                self.best_solution_overall = island['population'][j].copy()

                # Adapt F and CR
                if successful_F:
                    island['F'] = 0.9 * island['F'] + 0.1 * np.mean(successful_F) #Adjust mean and rate of change.
                if successful_CR:
                    island['CR'] = 0.9 * island['CR'] + 0.1 * np.mean(successful_CR)

            # Migration
            if generation % self.migration_interval == 0:
                self._migrate()

        if self.best_solution_overall is None and self.dim > 0:  # Fallback
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def _migrate(self):
        """Migrates individuals between islands based on best fitness."""
        # Sort islands by best fitness
        sorted_islands = sorted(self.islands, key=lambda x: x['best_fitness'])

        # Migrate best individuals from top islands to worst islands
        for i in range(self.migration_amount):
            source_island = sorted_islands[i]
            target_island = sorted_islands[self.num_islands - 1 - i]

            # Replace random individuals in the target island with copies of the best individuals from the source island
            for _ in range(self.migration_amount):
                replace_index = random.randint(0, self.population_size - 1)
                target_island['population'][replace_index] = source_island['best_solution'].copy()

                # Re-evaluate the fitness of the migrated individual
                target_island['fitness'][replace_index] = objective_function(target_island['population'][replace_index:replace_index+1])[0]
                self.eval_count += 1

                # Archive Update on target island.
                target_island['archive'].append((target_island['population'][replace_index].copy(),target_island['fitness'][replace_index]))
                if len(target_island['archive']) > self.archive_size:
                  worst_archive_index = np.argmax([f for _, f in target_island['archive']])
                  del target_island['archive'][worst_archive_index]

                # Update best fitness if necessary
                if target_island['fitness'][replace_index] < target_island['best_fitness']:
                    target_island['best_fitness'] = target_island['fitness'][replace_index]
                    target_island['best_solution'] = target_island['population'][replace_index].copy()
```

### Rank 3 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptiveArchipelagoArchiveDE
# Description: Combines island model with adaptive DE, archive, and migration for deceptive landscapes.
# Code:
```python
import numpy as np
import random

# Name: AdaptiveArchipelagoArchiveDE
# Description: Combines island model with adaptive DE, archive, and migration for deceptive landscapes.
# Code:
class AdaptiveArchipelagoArchiveDE:
    """
    Implements an island model with adaptive differential evolution and archive
    to explore multiple basins of attraction effectively. Features adaptive F/CR.
    """

    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, archive_size: int = 10,
                 initial_F: float = 0.5, initial_CR: float = 0.7, migration_interval: int = 500,
                 migration_amount: int = 2, F_adaptation_rate: float = 0.1,
                 CR_adaptation_rate: float = 0.1):
        """
        Initializes the AdaptiveArchipelagoArchiveDE optimizer.

        Args:
            budget (int): Total function evaluation budget.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): Lower bounds of the search space.
            upper_bounds (list[float]): Upper bounds of the search space.
            num_islands (int): Number of independent populations (islands).
            population_size (int): Number of individuals in each island's population.
            archive_size (int): Size of the local archive for each island.
            initial_F (float): Initial value of the differential weight (F).
            initial_CR (float): Initial value of the crossover rate (CR).
            migration_interval (int): Interval (in evaluations) at which migration occurs.
            migration_amount (int): Number of individuals to migrate between islands.
            F_adaptation_rate (float): Rate at which F adapts.
            CR_adaptation_rate (float): Rate at which CR adapts.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.num_islands = num_islands
        self.population_size = population_size
        self.archive_size = archive_size
        self.initial_F = initial_F
        self.initial_CR = initial_CR
        self.migration_interval = migration_interval
        self.migration_amount = migration_amount
        self.F_adaptation_rate = F_adaptation_rate
        self.CR_adaptation_rate = CR_adaptation_rate

        # Initialize islands
        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds,
                                            (self.population_size, self.dim))
            archive = np.zeros((self.archive_size, self.dim))
            archive_fitness = np.full(self.archive_size, float('inf'))
            self.islands.append({
                'population': population,
                'fitness': np.full(self.population_size, float('inf')),
                'best_solution': None,
                'best_fitness': float('inf'),
                'archive': archive,
                'archive_fitness': archive_fitness,
                'F': self.initial_F,
                'CR': self.initial_CR
            })

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        if self.dim > 0:
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        else:
            self.best_solution_overall = np.array([])
        self.best_fitness_overall = float('inf')

        # Initialize island populations and evaluate fitness + update archive
        for island in self.islands:
            island['fitness'] = objective_function(island['population'])
            self.eval_count += self.population_size
            best_index = np.argmin(island['fitness'])
            island['best_solution'] = island['population'][best_index].copy()
            island['best_fitness'] = island['fitness'][best_index]

            # Update archive with initial population
            self._update_archive(island, island['population'], island['fitness'])

            if island['best_fitness'] < self.best_fitness_overall:
                self.best_fitness_overall = island['best_fitness']
                self.best_solution_overall = island['best_solution'].copy()

        generation = 0
        while self.eval_count < self.budget:
            generation += 1

            for i, island in enumerate(self.islands):
                new_population = np.zeros_like(island['population'])
                new_fitness = np.zeros(self.population_size)

                for j in range(self.population_size):
                    # Select random indices for DE
                    idxs = [idx for idx in range(self.population_size) if idx != j]
                    a, b, c = random.sample(idxs, 3)

                    # Mutation
                    mutant = island['population'][a] + island['F'] * (island['population'][b] - island['population'][c])
                    mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

                    # Crossover
                    trial_vector = np.zeros(self.dim)
                    for k in range(self.dim):
                        if random.random() < island['CR'] or k == random.randint(0, self.dim - 1):
                            trial_vector[k] = mutant[k]
                        else:
                            trial_vector[k] = island['population'][j][k]

                    new_population[j] = trial_vector
                    new_fitness[j] = objective_function(new_population[j].reshape(1, -1))[0]
                    self.eval_count += 1

                    # Selection and Archive Update
                    if new_fitness[j] < island['fitness'][j]:
                        #Adapt F and CR
                        if new_fitness[j] < island['fitness'][j]:
                            island['F'] += self.F_adaptation_rate * (1 - island['F']) # F increases on success
                            island['CR'] += self.CR_adaptation_rate * (1- island['CR']) #CR increases on sucess

                        island['population'][j] = new_population[j].copy()
                        island['fitness'][j] = new_fitness[j]
                        self._update_archive(island, new_population[j].reshape(1, -1), np.array([new_fitness[j]]))

                        if new_fitness[j] < island['best_fitness']:
                            island['best_solution'] = island['population'][j].copy()
                            island['best_fitness'] = new_fitness[j]

                            if new_fitness[j] < self.best_fitness_overall:
                                self.best_fitness_overall = new_fitness[j]
                                self.best_solution_overall = island['population'][j].copy()
                    else:
                         island['F'] *= (1- self.F_adaptation_rate) # F decreases on failure
                         island['CR'] *= (1 -self.CR_adaptation_rate) # CR decreases on failures



            # Migration
            if generation % self.migration_interval == 0:
                self._migrate()

        if self.best_solution_overall is None and self.dim > 0:  # Fallback
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def _update_archive(self, island, solutions, fitness_values):
        """Updates the archive with new solutions."""
        archive = island['archive']
        archive_fitness = island['archive_fitness']

        for i in range(len(solutions)):
            solution = solutions[i]
            fitness = fitness_values[i]

            if fitness < np.max(archive_fitness):  # If better than worst in archive
                worst_index = np.argmax(archive_fitness)
                archive[worst_index] = solution.copy()
                archive_fitness[worst_index] = fitness

        island['archive'] = archive
        island['archive_fitness'] = archive_fitness

    def _migrate(self):
        """Migrates individuals between islands based on best fitness."""
        # Sort islands by best fitness
        sorted_islands = sorted(self.islands, key=lambda x: x['best_fitness'])

        # Migrate best individuals from top islands to worst islands
        for i in range(self.migration_amount):
            source_island = sorted_islands[i]
            target_island = sorted_islands[self.num_islands - 1 - i]

            # Replace random individuals in the target island with copies of the best individuals from the source island
            for _ in range(self.migration_amount):
                replace_index = random.randint(0, self.population_size - 1)
                target_island['population'][replace_index] = source_island['best_solution'].copy()

                # Evaluate migrated individual
                target_island['fitness'][replace_index] = objective_function(target_island['population'][replace_index:replace_index+1])[0]
                self._update_archive(target_island, target_island['population'][replace_index:replace_index+1], target_island['fitness'][replace_index:replace_index+1])

                if target_island['fitness'][replace_index] < target_island['best_fitness']:
                    target_island['best_fitness'] = target_island['fitness'][replace_index]
                    target_island['best_solution'] = target_island['population'][replace_index].copy()
                    if target_island['fitness'][replace_index] < self.best_fitness_overall:
                           self.best_fitness_overall = target_island['fitness'][replace_index]
                           self.best_solution_overall = target_island['population'][replace_index].copy()
```

### Rank 4 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptiveIslandArchipelagoDE
# Description: An island model DE with archive, adaptive parameters, and migration for exploring multimodal landscapes.
# Code:
```python
import numpy as np
import random

# Name: AdaptiveIslandArchipelagoDE
# Description: An island model DE with archive, adaptive parameters, and migration for exploring multimodal landscapes.
# Code:
class AdaptiveIslandArchipelagoDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size_per_island: int = 50, migration_interval: int = 1000,
                 migration_rate: float = 0.2, archive_size: int = 100):
        """
        Initializes the AdaptiveIslandArchipelagoDE algorithm.

        Args:
            budget (int): Total function evaluation budget.
            dim (int): Dimensionality of the problem.
            lower_bounds (list[float]): Lower bounds of the search space.
            upper_bounds (list[float]): Upper bounds of the search space.
            num_islands (int): Number of independent islands.
            population_size_per_island (int): Population size for each island.
            migration_interval (int): Number of evaluations between migration events.
            migration_rate (float): Fraction of the population to migrate.
            archive_size (int): Size of the archive for storing successful solutions.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.num_islands = num_islands
        self.population_size_per_island = population_size_per_island
        self.migration_interval = migration_interval
        self.migration_rate = migration_rate
        self.archive_size = archive_size

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize islands
        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds,
                                            size=(self.population_size_per_island, self.dim))
            self.islands.append({
                'population': population,
                'fitness': np.full(self.population_size_per_island, float('inf')),
                'best_solution': None,
                'best_fitness': float('inf'),
                'archive': []  # Each island has its own archive
            })

        # Adaptive parameters (initial values)
        self.F = 0.7
        self.CR = 0.9
        self.F_adaptive_rate = 0.1
        self.CR_adaptive_rate = 0.1

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the objective function using the adaptive island archipelago DE.

        Args:
            objective_function (callable): The function to minimize.
            acceptance_threshold (float): Acceptance threshold for convergence.

        Returns:
            tuple: (best_solution, best_fitness, optimization_info)
        """
        self.eval_count = 0

        # Evaluate initial populations
        for i in range(self.num_islands):
            fitness = objective_function(self.islands[i]['population'])
            self.islands[i]['fitness'] = fitness
            self.eval_count += self.population_size_per_island
            best_index = np.argmin(fitness)
            self.islands[i]['best_solution'] = self.islands[i]['population'][best_index]
            self.islands[i]['best_fitness'] = fitness[best_index]

            if self.islands[i]['best_fitness'] < self.best_fitness_overall:
                self.best_fitness_overall = self.islands[i]['best_fitness']
                self.best_solution_overall = self.islands[i]['best_solution']

            #Initialize archive
            self.islands[i]['archive'] = self._update_archive(self.islands[i]['population'], self.islands[i]['fitness'],i)


        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                # Adaptive Differential Evolution on each island
                offspring = self.generate_offspring(self.islands[i]['population'], i)
                offspring_fitness = objective_function(offspring)
                self.eval_count += self.population_size_per_island

                # Selection
                for j in range(self.population_size_per_island):
                    if offspring_fitness[j] < self.islands[i]['fitness'][j]:
                        self.islands[i]['population'][j] = offspring[j]
                        self.islands[i]['fitness'][j] = offspring_fitness[j]
                        #Adapt CR and F based on success.
                        self._adapt_parameters(i, offspring_fitness[j])


                # Update best solution on the island
                best_index = np.argmin(self.islands[i]['fitness'])
                if self.islands[i]['fitness'][best_index] < self.islands[i]['best_fitness']:
                    self.islands[i]['best_fitness'] = self.islands[i]['fitness'][best_index]
                    self.islands[i]['best_solution'] = self.islands[i]['population'][best_index]

                    # Update global best solution
                    if self.islands[i]['best_fitness'] < self.best_fitness_overall:
                        self.best_fitness_overall = self.islands[i]['best_fitness']
                        self.best_solution_overall = self.islands[i]['best_solution']

                # Update archive
                self.islands[i]['archive'] = self._update_archive(self.islands[i]['population'], self.islands[i]['fitness'], i)


            # Migration
            if self.eval_count % self.migration_interval == 0:
                self.migrate()

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'num_islands': self.num_islands,
            'population_size_per_island': self.population_size_per_island,
            'migration_interval': self.migration_interval,
            'migration_rate': self.migration_rate,
            'F': self.F,
            'CR': self.CR
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def generate_offspring(self, population: np.ndarray, island_index : int) -> np.ndarray:
        """
        Generates offspring using differential evolution, guided by the archive.

        Args:
            population (np.ndarray): The current population.
            island_index (int): The index of the island.

        Returns:
            np.ndarray: The generated offspring.
        """
        num_individuals = population.shape[0]
        offspring = np.zeros_like(population)

        for i in range(num_individuals):
            # Select three distinct individuals
            indices = list(range(num_individuals))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)

            #Mutation Strategy: DE/current-to-best/1
            mutant = population[i] + self.F * (self.islands[island_index]['best_solution']- population[i]) + self.F * (population[a] - population[b])
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)  # boundary handling

            # Crossover
            for j in range(self.dim):
                if random.random() < self.CR:
                    offspring[i, j] = mutant[j]
                else:
                    offspring[i, j] = population[i, j]

        return offspring


    def migrate(self):
        """
        Migrates individuals between islands.
        """
        # Sort islands by their best fitness (ascending)
        sorted_island_indices = sorted(range(self.num_islands), key=lambda i: self.islands[i]['best_fitness'])

        num_migrants = int(self.population_size_per_island * self.migration_rate)

        # Migrate from better islands to worse islands
        for i in range(self.num_islands // 2):  # Only migrate between half the islands
            source_island_index = sorted_island_indices[i] # Best to worst (migrator)
            destination_island_index = sorted_island_indices[self.num_islands - 1 - i]  #Worst to best (migrates to)

            # Select migrants from source island (best individuals)
            migrant_indices = np.argsort(self.islands[source_island_index]['fitness'])[:num_migrants]
            migrants = self.islands[source_island_index]['population'][migrant_indices].copy()

            # Replace random individuals in the destination island with the migrants
            replace_indices = random.sample(range(self.population_size_per_island), num_migrants)
            self.islands[destination_island_index]['population'][replace_indices] = migrants

            # Re-evaluate fitness of migrated individuals
            migrated_fitness = objective_function(migrants)
            self.eval_count += num_migrants

            self.islands[destination_island_index]['fitness'][replace_indices] = migrated_fitness

            #Update the best solutons after migration
            best_index = np.argmin(self.islands[destination_island_index]['fitness'])
            self.islands[destination_island_index]['best_solution'] = self.islands[destination_island_index]['population'][best_index]
            self.islands[destination_island_index]['best_fitness'] = self.islands[destination_island_index]['fitness'][best_index]

    def _adapt_parameters(self, island_index, offspring_fitness):
          #Simple Adaptive F and CR.  If an offspring is better than the mean, consider it a success,
        mean_fitness = np.mean(self.islands[island_index]['fitness'])
        if offspring_fitness < mean_fitness: #Success
            self.F = min(1.0, self.F * (1 + self.F_adaptive_rate))
            self.CR = min(1.0, self.CR * (1 + self.CR_adaptive_rate))
        else:
            self.F = max(0.1, self.F * (1 - self.F_adaptive_rate))
            self.CR = max(0.1, self.CR * (1 - self.CR_adaptive_rate))


    def _update_archive(self, population, fitness_values, island_index):
      combined = np.column_stack((population, fitness_values))

      # Convert to list for easier manipulation
      new_archive = self.islands[island_index]['archive'][:]

      for sol in combined:
          # Check if solution already exists (with tolerance)
          already_present = any(np.allclose(sol[:-1], arch[:-1], atol=1e-8) for arch in new_archive)
          if not already_present:
              new_archive.append(sol)

      # Sort and truncate
      new_archive.sort(key=lambda x: x[-1])
      self.islands[island_index]['archive'] = new_archive[:self.archive_size] #Update archive
      return self.islands[island_index]['archive']
```

### Rank 5 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptIslandArchiveDE
# Description: Island model DE with archive, adaptive F/CR, and worst-member replacement upon migration for global search.
# Code:
```python
import numpy as np
import random

# Name: AdaptIslandArchiveDE
# Description: Island model DE with archive, adaptive F/CR, and worst-member replacement upon migration for global search.
# Code:
class AdaptIslandArchiveDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        """
        Initializes the AdaptIslandArchiveDE algorithm.

        Args:
            budget (int): The maximum number of function evaluations.
            dim (int): The dimensionality of the problem.
            lower_bounds (list[float]): The lower bounds of the search space.
            upper_bounds (list[float]): The upper bounds of the search space.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Island model parameters
        self.num_islands = 5  # Number of islands
        self.population_size = 50  # Population size per island
        self.migration_interval = 50  # Migration interval (evaluations)
        self.migration_rate = 0.2  # Fraction of population to migrate

        # DE parameters (per island)
        self.F_scale = 0.7  # Differential weight
        self.CR = 0.9  # Crossover rate
        self.F_scale_adapt = 0.1 #Adaptive Differential weight
        self.CR_adapt = 0.1 #Adaptive Crossover Rate

        # Archive
        self.archive_size = 100
        self.archive = []

        # Island populations (initialized in optimize)
        self.islands_population = None
        self.islands_fitness = None

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using AdaptIslandArchiveDE.

        Args:
            objective_function (callable): The objective function to minimize.
            acceptance_threshold (float, optional): The acceptance threshold for the best fitness. Defaults to 1e-8.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0
        self.best_fitness_overall = float('inf')

        # Initialize islands
        self.islands_population = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.islands_fitness = [objective_function(pop) for pop in self.islands_population]
        self.eval_count += self.num_islands * self.population_size

        # Initial archive update
        for i in range(self.num_islands):
            self.archive = self._update_archive(self.islands_population[i], self.islands_fitness[i])
            best_idx = np.argmin(self.islands_fitness[i])
            if self.islands_fitness[i][best_idx] < self.best_fitness_overall:
                self.best_fitness_overall = self.islands_fitness[i][best_idx]
                self.best_solution_overall = self.islands_population[i][best_idx].copy()

        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                # DE mutation with archive guidance
                offspring = self._archive_guided_mutation(i)
                offspring = np.clip(offspring, self.lower_bounds, self.upper_bounds) # Boundary handling

                offspring_fitness = objective_function(offspring)
                self.eval_count += len(offspring)

                # Selection
                combined_population = np.vstack((self.islands_population[i], offspring))
                combined_fitness = np.concatenate((self.islands_fitness[i], offspring_fitness))
                sorted_indices = np.argsort(combined_fitness)[:self.population_size]
                self.islands_population[i] = combined_population[sorted_indices]
                self.islands_fitness[i] = combined_fitness[sorted_indices]

                # Update best solution
                best_idx = np.argmin(self.islands_fitness[i])
                if self.islands_fitness[i][best_idx] < self.best_fitness_overall:
                    self.best_fitness_overall = self.islands_fitness[i][best_idx]
                    self.best_solution_overall = self.islands_population[i][best_idx].copy()

                # Update archive
                self.archive = self._update_archive(self.islands_population[i], self.islands_fitness[i])

                # Tune F and CR: Simple adaptation
                if np.random.rand() < self.F_scale_adapt :
                    self.F_scale = np.random.uniform(0.2, 0.9)
                if np.random.rand() < self.CR_adapt:
                     self.CR = np.random.uniform(0.1, 0.9)

            # Migration
            if self.eval_count % self.migration_interval == 0:
                self._migrate_individuals()

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }

        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def _archive_guided_mutation(self, island_index: int):
         """
         Performs DE mutation guided by the archive.

         Args:
             island_index (int): The index of the island to perform mutation on.

         Returns:
             numpy.ndarray: The offspring population.
         """
         population = self.islands_population[island_index]
         num_individuals = len(population)
         offspring = np.zeros_like(population)

         for i in range(num_individuals):
             # Choose random indices for mutation, ensuring they are distinct
             idxs = [idx for idx in np.random.choice(num_individuals, size=2, replace=False) if idx != i]
             idx_a, idx_b = idxs[0], idxs[1]

             # Choose pbest index either the best one in the island or in archive.
             if len(self.archive) > 0 and np.random.rand() < 0.5:
                  arch_idx = np.random.choice(len(self.archive))
                  pbest = self.archive[arch_idx][:-1] # remove fitness
             else:
                  pbest = population[np.argmin(self.islands_fitness[island_index])]

             # DE mutation: v = x_i + F * (pbest - x_i) + F * (x_a - x_b)
             mutant = population[i] + self.F_scale * (pbest - population[i]) + self.F_scale * (population[idx_a] - population[idx_b])

             # Crossover
             jrand = np.random.randint(self.dim) # at least one parameter is changed
             for j in range(self.dim):
                 if np.random.rand() > self.CR and j != jrand:
                     mutant[j] = population[i][j] # keep parent chromosomes rather then mutation

             offspring[i] = mutant

         return offspring

    def _migrate_individuals(self):
        """
        Migrates individuals between islands based on the migration rate.
        """
        num_to_migrate = int(self.population_size * self.migration_rate)

        for i in range(self.num_islands):
            # Select migrants from current island
            migrant_indices = np.argsort(self.islands_fitness[i])[-num_to_migrate:] # Worst members
            migrants = self.islands_population[i][migrant_indices]
            migrant_fitnesses = self.islands_fitness[i][migrant_indices]

            # Choose a destination island (different from current)
            destination_island = (i + 1) % self.num_islands

            # Replace individuals in the destination island with migrants
            replace_indices = np.argsort(self.islands_fitness[destination_island])[:num_to_migrate]  #replace best members
            self.islands_population[destination_island][replace_indices] = migrants
            self.islands_fitness[destination_island][replace_indices] = migrant_fitnesses

            #Keep the best solution overall; the archive may not
            best_idx = np.argmin(self.islands_fitness[destination_island])
            if self.islands_fitness[destination_island][best_idx] < self.best_fitness_overall:
                self.best_fitness_overall = self.islands_fitness[destination_island][best_idx]
                self.best_solution_overall = self.islands_population[destination_island][best_idx].copy()


    def _update_archive(self, population, fitness_values):
        """
        Updates the archive with new individuals.

        Args:
            population (numpy.ndarray): The population to add to the archive.
            fitness_values (numpy.ndarray): The fitness values of the population.

        Returns:
            numpy.ndarray: The updated archive.
        """
        combined = np.column_stack((population, fitness_values))
        new_archive = self.archive.copy()
        for sol in combined:
            already_present = False
            for arch in new_archive:
                 if len(arch) > 0 and np.allclose(sol[:-1], arch[:-1], atol=1e-6):
                     already_present = True
                     break #Found. Move to next
            if not already_present:
                new_archive.append(sol)
        new_archive.sort(key=lambda x: x[-1]) # Sort archive

        return new_archive[:self.archive_size] #Return archive
```

### Rank 6 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: AdaptiveIslandArchiveDifferentialEvolution
# Description: Island model with adaptive DE, archive, and decaying diversity pressure for multimodal search.
# Code:
```python
import numpy as np
import random

# Name: AdaptiveIslandArchiveDifferentialEvolution
# Description: Island model with adaptive DE, archive, and decaying diversity pressure for multimodal search.
# Code:
class AdaptiveIslandArchiveDifferentialEvolution:
    """
    Implements an island model with adaptive differential evolution, a local archive, and a diversity mechanism
    on each island for robust exploration and exploitation of multimodal landscapes.
    """

    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, archive_size: int = 10,
                 initial_crossover_rate: float = 0.7, initial_differential_weight: float = 0.5,
                 migration_interval: int = 500, migration_amount: int = 2,
                 differential_weight_decay: float = 0.99, diversity_decay: float = 0.999):
        """
        Initializes the AdaptiveIslandArchiveDifferentialEvolution optimizer.

        Args:
            budget (int): Total function evaluation budget.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): Lower bounds of the search space.
            upper_bounds (list[float]): Upper bounds of the search space.
            num_islands (int): Number of independent populations (islands).
            population_size (int): Number of individuals in each island's population.
            archive_size (int): Size of the local archive for each island.
            initial_crossover_rate (float): Initial probability of crossover in differential evolution.
            initial_differential_weight (float): Initial value of the differential weight (F).
            migration_interval (int): Interval (in evaluations) at which migration occurs.
            migration_amount (int): Number of individuals to migrate between islands.
            differential_weight_decay (float): Decay rate for the differential weight (F) per generation.
            diversity_decay (float): Decay rate for the diversity pressure term.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.num_islands = num_islands
        self.population_size = population_size
        self.archive_size = archive_size
        self.initial_crossover_rate = initial_crossover_rate
        self.crossover_rate = initial_crossover_rate
        self.initial_differential_weight = initial_differential_weight
        self.differential_weight = initial_differential_weight
        self.migration_interval = migration_interval
        self.migration_amount = migration_amount
        self.differential_weight_decay = differential_weight_decay
        self.diversity_decay = diversity_decay # Decay for diversity

        # Initialize islands
        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds,
                                            (self.population_size, self.dim))
            archive = np.zeros((self.archive_size, self.dim))
            archive_fitness = np.full(self.archive_size, float('inf'))
            self.islands.append({
                'population': population,
                'fitness': np.full(self.population_size, float('inf')),
                'best_solution': None,
                'best_fitness': float('inf'),
                'archive': archive,
                'archive_fitness': archive_fitness
            })
        
        self.diversity_pressure = 1.0

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        if self.dim > 0:
           self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        else:
           self.best_solution_overall = np.array([])
        self.best_fitness_overall = float('inf')

        # Initialize island populations and evaluate fitness + update archive
        for island in self.islands:
            island['fitness'] = objective_function(island['population'])
            self.eval_count += self.population_size
            best_index = np.argmin(island['fitness'])
            island['best_solution'] = island['population'][best_index].copy()
            island['best_fitness'] = island['fitness'][best_index]

            # Update archive with initial population
            self._update_archive(island, island['population'], island['fitness'])

            if island['best_fitness'] < self.best_fitness_overall:
                self.best_fitness_overall = island['best_fitness']
                self.best_solution_overall = island['best_solution'].copy()

        generation = 0
        while self.eval_count < self.budget:
            generation += 1
            self.differential_weight = self.initial_differential_weight * (self.differential_weight_decay ** generation)
            self.crossover_rate = self.initial_crossover_rate # No Adaptation for test run
            self.diversity_pressure *= self.diversity_decay

            for i, island in enumerate(self.islands):
                new_population = np.zeros_like(island['population'])
                new_fitness = np.zeros(self.population_size)

                for j in range(self.population_size):
                    # Adaptive DE Mutation: Use archive with chance
                    if random.random() < 0.5:  # Use archive
                        combined_population = np.concatenate((island['population'], island['archive']))
                        #combined_fitness = np.concatenate((island['fitness'], island['archive_fitness'])) # Not used currently

                        idxs = [idx for idx in range(len(combined_population)) if idx != j]
                        if len(idxs) < 3:  #Handle case where archive + population is small
                          idxs = [idx for idx in range(len(island['population'])) if idx !=j]
                          if len(idxs) >=3:
                            population_only = True
                            a, b, c = random.sample(idxs, 3)
                            mutant = island['population'][a] + self.differential_weight * (island['population'][b] - island['population'][c])
                          else:
                            mutant = island['population'][j].copy() #No progress possible in this case
                            #print("Very degenerate situation for diversity")
                            
                        else:
                          population_only = False
                          a, b, c = random.sample(idxs, 3)
                          mutant = combined_population[a] + self.differential_weight * (combined_population[b] - combined_population[c])

                    else:  # original de
                        idxs = [idx for idx in range(self.population_size) if idx != j]
                        a, b, c = random.sample(idxs, 3)
                        mutant = island['population'][a] + self.differential_weight * (island['population'][b] - island['population'][c])

                    mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

                    trial_vector = np.zeros(self.dim)
                    for k in range(self.dim):
                        if random.random() < self.crossover_rate or k == random.randint(0, self.dim - 1):
                            trial_vector[k] = mutant[k]
                        else:
                            trial_vector[k] = island['population'][j][k]
                    
                    # Diversity pressure
                    distance_to_others = np.linalg.norm(island['population'] - trial_vector, axis=1)
                    diversity_term = self.diversity_pressure * np.mean(distance_to_others)

                    new_population[j] = trial_vector
                    new_fitness[j] = objective_function(new_population[j].reshape(1, -1))[0] + diversity_term
                    self.eval_count += 1

                    # Selection and archive update
                    if new_fitness[j] < island['fitness'][j]:
                        island['population'][j] = new_population[j].copy()
                        island['fitness'][j] = new_fitness[j] - diversity_term # Important: remove diversity term for later fitness comparisons

                        # Local Archive update
                        self._update_archive(island, new_population[j].reshape(1,-1), np.array([new_fitness[j] - diversity_term]))

                        if new_fitness[j] - diversity_term < island['best_fitness']:
                            island['best_solution'] = island['population'][j].copy()
                            island['best_fitness'] = new_fitness[j] - diversity_term

                            if new_fitness[j] - diversity_term < self.best_fitness_overall:
                                self.best_fitness_overall = new_fitness[j] - diversity_term
                                self.best_solution_overall = island['population'][j].copy()


            # Migration
            if generation % self.migration_interval == 0:
                self._migrate()

        if self.best_solution_overall is None and self.dim > 0:  # Fallback
           self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def _update_archive(self, island, solutions, fitness_values):
        """Updates the archive with new solutions."""
        archive = island['archive']
        archive_fitness = island['archive_fitness']

        for i in range(len(solutions)):
            solution = solutions[i]
            fitness = fitness_values[i]

            if fitness < np.max(archive_fitness):  # if better than worst in the archive
                worst_index = np.argmax(archive_fitness)
                archive[worst_index] = solution.copy()
                archive_fitness[worst_index] = fitness

        island['archive'] = archive
        island['archive_fitness'] = archive_fitness

    def _migrate(self):
        """Migrates individuals between islands based on best fitness."""
        # Sort islands by best fitness
        sorted_islands = sorted(self.islands, key=lambda x: x['best_fitness'])

        # Migrate best individuals from top islands to worst islands
        for i in range(self.migration_amount):
            source_island = sorted_islands[i]
            target_island = sorted_islands[self.num_islands - 1 - i]

            # Replace random individuals in the target island with copies of the best individuals from the source island
            for _ in range(self.migration_amount):
                replace_index = random.randint(0, self.population_size - 1)
                target_island['population'][replace_index] = source_island['best_solution'].copy()

                # Evaluate migrated individual and Update
                target_island['fitness'][replace_index] = objective_function(target_island['population'][replace_index:replace_index+1])[0]

                # Local Archive Update
                self._update_archive(target_island, target_island['population'][replace_index:replace_index+1], target_island['fitness'][replace_index:replace_index+1])

                if target_island['fitness'][replace_index] < target_island['best_fitness']:
                    target_island['best_fitness'] = target_island['fitness'][replace_index]
                    target_island['best_solution'] = target_island['population'][replace_index].copy()
```

### Rank 7 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: IslandModelAdaptiveArchiveDE
# Description: Combines island model DE with an archive and adaptive F/CR for exploration and exploitation of multimodal spaces.
# Code:
```python
import numpy as np
import random

# Name: IslandModelAdaptiveArchiveDE
# Description: Combines island model DE with an archive and adaptive F/CR for exploration and exploitation of multimodal spaces.
# Code:
class IslandModelAdaptiveArchiveDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size_per_island: int = 50, archive_size: int = 100,
                 migration_interval: int = 1000, migration_rate: float = 0.2, initial_F: float = 0.5, initial_CR: float = 0.9):
        """
        Initializes the IslandModelAdaptiveArchiveDE algorithm.

        Args:
            budget (int): Total function evaluation budget.
            dim (int): Dimensionality of the problem.
            lower_bounds (list[float]): Lower bounds of the search space.
            upper_bounds (list[float]): Upper bounds of the search space.
            num_islands (int): Number of independent islands.
            population_size_per_island (int): Population size for each island.
            archive_size (int): Maximum size of the archive in each island
            migration_interval (int): Number of evaluations between migration events.
            migration_rate (float): Fraction of the population to migrate.
            initial_F (float): Initial differential evolution scaling factor.
            initial_CR (float): Initial crossover rate.
        """
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.num_islands = num_islands
        self.population_size_per_island = population_size_per_island
        self.archive_size = archive_size
        self.migration_interval = migration_interval
        self.migration_rate = migration_rate
        self.initial_F = initial_F
        self.initial_CR = initial_CR

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize islands
        self.islands = []
        for _ in range(self.num_islands):
            population = np.random.uniform(self.lower_bounds, self.upper_bounds,
                                            size=(self.population_size_per_island, self.dim))
            self.islands.append({
                'population': population,
                'fitness': np.full(self.population_size_per_island, float('inf')), # Initialize fitness to infinity
                'best_solution': None,
                'best_fitness': float('inf'),
                'archive': [],
                'F': self.initial_F,
                'CR': self.initial_CR
            })

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the objective function using the island model with adaptive DE and archive.

        Args:
            objective_function (callable): The function to minimize.
            acceptance_threshold (float): Acceptance threshold for convergence.

        Returns:
            tuple: (best_solution, best_fitness, optimization_info)
        """
        self.eval_count = 0

        # Evaluate initial populations
        for i in range(self.num_islands):
            fitness = objective_function(self.islands[i]['population'])
            self.islands[i]['fitness'] = fitness
            self.eval_count += self.population_size_per_island
            best_index = np.argmin(fitness)
            self.islands[i]['best_solution'] = self.islands[i]['population'][best_index]
            self.islands[i]['best_fitness'] = fitness[best_index]

            if self.islands[i]['best_fitness'] < self.best_fitness_overall:
                self.best_fitness_overall = self.islands[i]['best_fitness']
                self.best_solution_overall = self.islands[i]['best_solution']

            # Initialize archive
            for j in range(self.population_size_per_island):
                self.update_archive(i, self.islands[i]['population'][j], self.islands[i]['fitness'][j])
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                # Adaptive Differential Evolution on each island, using archive
                offspring = self.generate_offspring(i, objective_function)
                offspring_fitness = objective_function(offspring)
                self.eval_count += self.population_size_per_island

                # Selection and archive update
                for j in range(self.population_size_per_island):
                    if offspring_fitness[j] < self.islands[i]['fitness'][j]:
                        self.islands[i]['population'][j] = offspring[j]
                        self.islands[i]['fitness'][j] = offspring_fitness[j]

                    self.update_archive(i, offspring[j], offspring_fitness[j])

                # Update best solution on the island
                best_index = np.argmin(self.islands[i]['fitness'])
                if self.islands[i]['fitness'][best_index] < self.islands[i]['best_fitness']:
                    self.islands[i]['best_fitness'] = self.islands[i]['fitness'][best_index]
                    self.islands[i]['best_solution'] = self.islands[i]['population'][best_index]

                    # Update global best solution
                    if self.islands[i]['best_fitness'] < self.best_fitness_overall:
                        self.best_fitness_overall = self.islands[i]['best_fitness']
                        self.best_solution_overall = self.islands[i]['best_solution']

                # Adaptive F/CR (simple adaptation)
                self.islands[i]['F'] = 0.5 * (1 + random.random()) #F ranges from .5 - 1.0
                self.islands[i]['CR'] = random.random()  #CR ranges from 0 - 1.0


            # Migration
            if self.eval_count % self.migration_interval == 0:
                self.migrate()

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'num_islands': self.num_islands,
            'population_size_per_island': self.population_size_per_island,
            'archive_size': self.archive_size,
            'migration_interval': self.migration_interval,
            'migration_rate': self.migration_rate,
            'initial_F': self.initial_F,
            'initial_CR': self.initial_CR
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def generate_offspring(self, island_index: int, objective_function: callable) -> np.ndarray:
        """
        Generates offspring using differential evolution, guided by the archive.

        Args:
            island_index (int): The index of the current island.
            objective_function (callable): Objective function to be minimized

        Returns:
            np.ndarray: The generated offspring.
        """
        population = self.islands[island_index]['population']
        archive = self.islands[island_index]['archive']
        num_individuals = population.shape[0]
        offspring = np.zeros_like(population)
        F = self.islands[island_index]['F']
        CR = self.islands[island_index]['CR']

        for i in range(num_individuals):
            # Select pbest - archive or population.  Prioritize the archive if possible.
            if archive:
                 pbest = random.choice(archive)[0] # Archive individual
            else:
                pbest = population[np.argmin(objective_function(population))]

            # Select three distinct individuals - mutation
            indices = list(range(num_individuals))
            indices.remove(i)
            a, b = random.sample(indices, 2)

            # Differential evolution mutation with archive guidance
            mutant = pbest + F * (population[a] - population[b])
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)  # boundary handling

            # Crossover
            for j in range(self.dim):
                if random.random() < CR:
                    offspring[i, j] = mutant[j]
                else:
                    offspring[i, j] = population[i, j]
        return offspring
    def update_archive(self, island_index, individual, fitness):
        """
        Updates the archive of the specified island.
        """
        archive = self.islands[island_index]['archive']
        archive_size = self.archive_size

        if len(archive) < archive_size:
             archive.append((individual, fitness))
        else:
            worst_index = np.argmax([f for _, f in archive])
            if fitness < archive[worst_index][1]:
                archive[worst_index] = (individual, fitness)
        self.islands[island_index]['archive'] = archive

    def migrate(self):
        """
        Migrates individuals between islands.
        """
        # Sort islands by their best fitness (ascending)
        sorted_island_indices = sorted(range(self.num_islands), key=lambda i: self.islands[i]['best_fitness'])

        num_migrants = int(self.population_size_per_island * self.migration_rate)

        # Migrate from better islands to worse islands
        for i in range(self.num_islands // 2):  # Only migrate between half the islands
            source_island_index = sorted_island_indices[i] # Best islands (migrator)
            destination_island_index = sorted_island_indices[self.num_islands - 1 - i]  # Worst islands (migrates to)

            # Select migrants from source island (best individuals)
            migrant_indices = np.argsort(self.islands[source_island_index]['fitness'])[:num_migrants]
            migrants = self.islands[source_island_index]['population'][migrant_indices].copy()

            # Replace random individuals in the destination island with the migrants
            replace_indices = random.sample(range(self.population_size_per_island), num_migrants)
            self.islands[destination_island_index]['population'][replace_indices] = migrants

            # Re-evaluate fitness of migrated individuals
            migrated_fitness = objective_function(migrants)
            self.eval_count += num_migrants
            self.islands[destination_island_index]['fitness'][replace_indices] = migrated_fitness

            #Update the best solutions after migration
            best_index = np.argmin(self.islands[destination_island_index]['fitness'])
            self.islands[destination_island_index]['best_solution'] = self.islands[destination_island_index]['population'][best_index]
            self.islands[destination_island_index]['best_fitness'] = self.islands[destination_island_index]['fitness'][best_index]
```

### Rank 8 (Overall AOCC Score on Multimodal instances with multiple components: 0.0000e+00# Name: IslandAdaptiveDE
# Description: A multi-island differential evolution algorithm with adaptive parameters and archive-based exploration, designed for deceptive landscapes.
# Code:
```python
import numpy as np
import random

# Name: IslandAdaptiveDE
# Description: A multi-island differential evolution algorithm with adaptive parameters and archive-based exploration, designed for deceptive landscapes.
# Code:
class IslandAdaptiveDE:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size_factor: float = 20,
                 archive_size_factor: float = 2.0, migration_interval: int = 500,
                 initial_F_scale: float = 0.7, initial_CR: float = 0.5,
                 local_search_prob: float = 0.1):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.num_islands = num_islands
        self.population_size = int(population_size_factor * self.dim)
        self.archive_size = int(archive_size_factor * self.population_size)
        self.migration_interval = migration_interval
        self.initial_F_scale = initial_F_scale
        self.initial_CR = initial_CR
        self.local_search_prob = local_search_prob  # Probability of triggering local search

        self.islands = []
        for _ in range(self.num_islands):
            self.islands.append({
                'population': np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim)),
                'fitness': np.full(self.population_size, float('inf')),
                'archive': [],
                'F_scale': self.initial_F_scale,
                'CR': self.initial_CR,
                'success_F': [],
                'success_CR': []

            })

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0

        # Initial evaluation
        for island in self.islands:
            island['fitness'] = objective_function(island['population'])
            self.eval_count += self.population_size

            best_index = np.argmin(island['fitness'])
            if island['fitness'][best_index] < self.best_fitness_overall:
                self.best_fitness_overall = island['fitness'][best_index]
                self.best_solution_overall = island['population'][best_index].copy() #important .copy()
        
        generation = 0  # Track generations for migration

        while self.eval_count < self.budget:
            generation += 1
            for i, island in enumerate(self.islands):
                offspring, offspring_fitness = self.generate_offspring(island, objective_function)

                # Update archive
                self.update_archive(island, offspring, offspring_fitness)

                # Selection (replace worse parents with offspring)
                for j in range(self.population_size):
                    if offspring_fitness[j] < island['fitness'][j]:
                        island['population'][j] = offspring[j]
                        island['fitness'][j] = offspring_fitness[j]
                        island['success_F'].append(island['F_scale'])
                        island['success_CR'].append(island['CR'])

                # Update parameters (adaptive F and CR)
                self.update_parameters(island)

                # Local Search (optional for exploitation refinement)
                if random.random() < self.local_search_prob:
                    self.perform_local_search(island, objective_function)

                # Update best solution
                best_index = np.argmin(island['fitness'])
                if island['fitness'][best_index] < self.best_fitness_overall:
                    self.best_fitness_overall = island['fitness'][best_index]
                    self.best_solution_overall = island['population'][best_index].copy()  #important .copy()

            # Migration (exchange individuals between islands)
            if generation % self.migration_interval == 0 and self.num_islands > 1:
                self.migrate_individuals()
            
        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'num_islands': self.num_islands,
            'population_size': self.population_size,
            'archive_size': [len(island['archive']) for island in self.islands]

        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info


    def generate_offspring(self, island, objective_function):
        population = island['population']
        archive = island['archive']
        F_scale = island['F_scale']
        CR = island['CR']
        population_size = self.population_size
        dim = self.dim

        offspring = np.zeros((population_size, dim))
        offspring_fitness = np.zeros(population_size)

        for i in range(population_size):
            # Select indices for mutation
            idxs = [idx for idx in range(population_size) if idx != i]
            a, b, c = random.sample(idxs, 3)

            # Crossover
            for j in range(dim):
                if random.random() < CR or j == random.randint(0, dim - 1):
                    # Use archive or pbest?
                    if archive and random.random() < 0.5:  # 50% chance to use archive
                       rand_archive_idx = random.randint(0, len(archive)-1)
                       pbest = archive[rand_archive_idx][0]

                    else:
                        pbest = population[np.argmin(island['fitness'])]

                    offspring[i, j] = population[i, j] + F_scale * (pbest[j] - population[i, j] + population[a, j] - population[b, j])
                else:
                    offspring[i, j] = population[i, j]

            # Boundary handling
            offspring[i] = np.clip(offspring[i], self.lower_bounds, self.upper_bounds)

        offspring_fitness = objective_function(offspring)
        self.eval_count += population_size
        return offspring, offspring_fitness


    def update_archive(self, island, offspring, offspring_fitness):
        archive = island['archive']
        archive_size = self.archive_size

        for i in range(len(offspring)):
            if len(archive) < archive_size:
                archive.append((offspring[i], offspring_fitness[i]))
            else:
                worst_index = np.argmax([f for _, f in archive])
                if offspring_fitness[i] < archive[worst_index][1]:
                    archive[worst_index] = (offspring[i], offspring_fitness[i])

    def update_parameters(self, island):
        # Adaptive F and CR using success history
        if island['success_F']:
            island['F_scale'] = self.update_scale(island['success_F'], island['F_scale']) #self.cauchy_mutation(np.mean(island['success_F']), 0.1)
            island['success_F'] = []

        if island['success_CR']:
            island['CR'] = self.update_crossover(island['success_CR'], island['CR']) #self.normal_mutation(np.mean(island['success_CR']), 0.1)
            island['success_CR'] = []

        # Keep F and CR within bounds.
        island['F_scale'] = np.clip(island['F_scale'], 0.1, 1.0)
        island['CR'] = np.clip(island['CR'], 0.1, 0.9)
    
    def update_scale(self, success_values, current_value):
         # Lehmer mean for successful F values
         try:
             new_value = np.mean(np.array(success_values)**2) / np.mean(success_values)

             # Dampen adaptation
             new_value = 0.8 * current_value + 0.2 * new_value
         except:
             new_value = current_value
         return new_value

    def update_crossover(self, success_values, current_value):
        # Mean of successful CR values
        try:
          new_value = np.mean(success_values)
          # Dampen adaptation
          new_value = 0.8 * current_value + 0.2 * new_value
        except:
          new_value = current_value
        return new_value

    def cauchy_mutation(self, loc, scale):
        return loc + scale * np.random.standard_cauchy()

    def normal_mutation(self, loc, scale):
        return np.random.normal(loc, scale)
    def migrate_individuals(self):
        # Simple migration: exchange best individuals between adjacent islands
        for i in range(self.num_islands):
            # Select a random island to migrate to
            j = (i + 1) % self.num_islands

            # Find the best individual on island i
            best_idx_i = np.argmin(self.islands[i]['fitness'])
            best_individual_i = self.islands[i]['population'][best_idx_i].copy() #.copy()

            # Find a random individual to replace on island j
            replace_idx_j = random.randint(0, self.population_size - 1)

            # Replace the random individual on island j with the best individual from island i
            self.islands[j]['population'][replace_idx_j] = best_individual_i
            self.islands[j]['fitness'][replace_idx_j] = self.islands[i]['fitness'][best_idx_i] # Ensure fitness is updated too

    def perform_local_search(self, island, objective_function):
       # Select a subset of the population for local search
       num_individuals = int(0.1 * self.population_size)  # e.g., 10% of the population
       indices = random.sample(range(self.population_size), num_individuals)

       for i in indices:
           current_solution = island['population'][i].copy()
           current_fitness = island['fitness'][i]

           # Apply a local search operator (e.g., Gaussian mutation)
           new_solution = current_solution + np.random.normal(0, 0.05 * (self.upper_bounds - self.lower_bounds)) # adjust exploration radius as needed
           new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)
           new_fitness = objective_function(np.array([new_solution]))[0] #evaluate one solution at a time
           self.eval_count += 1

           # Accept the new solution if it's better
           if new_fitness < current_fitness:
                island['population'][i] = new_solution
                island['fitness'][i] = new_fitness
```



### Guide
Keep in mind, this is a list of design heuristics ranked from best to worst. The first algorithm in the list is the best performing on average, and the last is the worst.
Your response must be in Markdown format and contain nothing else. It must have the following structure:

"**Analysis:**
**Experience:**"

In there:
+ Meticulously analyze comments, docstrings and source code of several pairs (Better code - Worse code) in List heuristics to fill values for **Analysis:**.
Example: "Comparing (best) vs (worst), we see ...;  (second best) vs (second worst) ...; Comparing (1st) vs (2nd), we see ...; (3rd) vs (4th) ...; Comparing (second worst) vs (worst), we see ...; Overall:"

+ Self-reflect to extract useful experience for design better heuristics and fill to **Experience:** (<60 words).

I'm going to tip $999K for a better heuristics! Let's think step by step.
2025-06-25 08:59:42 INFO Full response text: **Analysis:**
Comparing (Rank 1) vs (Rank 8), we see rank 1 incorporates adaptive sigma for Gaussian mutation while rank 8 uses adaptive F and CR in DE.  Rank 1 has population tournament selection while Rank 8 direct comparison between offspring and population . Migration schemes differ, Rank 1 uses random island pairings while Rank 8 uses adjacent island migrations.

Comparing (Rank 2) vs (Rank 7) we see Rank 2 utilizes adaptive F/CR centered on current values sampled from a normal distribution whilst Rank 7 does basic F and CR adaptation.  Rank 2 includes adaptation rates as parameters that can be modified, and uses 0.9 of previous values and adaptation rate to provide nuanced control on success/failure, while rank 7 only implements diversity decay. Rank 2 sorts islands to send best to worst fitness solutions while Rank 7 sends worst fitness to the front. Rank 2 features pbest selection (archive or population) with an adaptive strategy, against a simpler constant-probability use in Rank 7.

Comparing (Rank 3) vs (Rank 4), rank 3 has decaying F and CR based on failure or diversity pressure, and also explicit diversity pressure within fitness functions while Rank 4 does not decay diversity explicitly. Archive is updated for new individuals in both, but in Rank 3 we do diversity selection against solutions with equal diversity, a tie breaker, during archive updates.

Comparing (Rank 5) vs (Rank 6), Rank 6 incorporates diversity pressure within fitness functions and diversity decay. Rank 5 tunes F/CR and makes sure it stays within certain bounds.

Comparing (Rank 7) vs (Rank 8), Rank 7 focuses on simpler archive updates with fixed initial parameters that work at a broader level. While Rank 8 performs local search with gaussian mutation, and it adapts F/CR with success to tune individual island parameters.

Overall: Better algorithms generally leverage archives more effectively, adaptive parameter control (sigma, F, CR) beyond simple random modification, and explicit mechanisms for maintaining diversity (decay, pressure), or use pbest, adaptive sampling from archive using a weighted approach. Migration strategies, when ranking highly, employ sorting to send better individuals to worse islands more deliberately. Sophistication in adapting F/CR (using normal distributions, success history, nuanced adaptation rates), and diversity management directly impact performance.

**Experience:**
To design better heuristics, prioritize adaptive mechanisms (F, CR, sigma), diversified archive utilization (selection weights), and migration schemes targeting diversity deficient islands by analyzing islands or their parameter tuning state. Exploring inclusion of other operators via a more sophisticated update schedule may be a good option to start with.

2025-06-25 08:59:44 INFO Full response text: Okay, let's craft an improved self-reflection strategy focusing on designing better heuristics. This will guide our heuristic design process by highlighting key areas and pitfalls.
**Keywords:** Memory utilization, Exploration-Exploitation balance, Adaptive parameter control, Diversity maintenance.

**Advice:** Prioritize the intelligent fusion of past search history, thorough parameter tuning mechanisms, and diversity maintenance on an island level. The overall search can be further improved by improving migration schemes using characteristics of the destination sub-population.

**Avoid:** Over-reliance on complex adaptation factors, minimal parameter adjustments, and neglecting memory mechanisms/techniques in islands.

**Explanation:** Aim for a balance of archive information, parameter adaptation, diversity and a good exploration-exploitation balance within the heuristic design. Heuristic improvements and algorithm updates can be deployed with minimal intervention needed.

2025-06-25 08:59:44 INFO Generating offspring via Crossover...
