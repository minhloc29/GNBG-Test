2025-06-24 07:03:58 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:03:58 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:03:58 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:03:58 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:03:58 ERROR Can not run the algorithm
2025-06-24 07:03:58 INFO Run function 6 complete. FEHistory len: 200, AOCC: 0.1468
2025-06-24 07:03:58 INFO FeHistory: [-183.44599823 -183.41317813 -183.38128644 -183.34922822 -183.31528976
 -183.41553779 -183.43563677 -183.33368956 -183.35924727 -183.38091534
 -183.37072074 -183.30961794 -183.32897791 -183.38806636 -183.26949501
 -183.38670131 -183.40044476 -183.39844055 -183.32946796 -183.35881678
 -183.34535577 -183.36643273 -183.34554278 -183.46245318 -183.35445368
 -183.32244117 -183.27498128 -183.32698183 -183.35245673 -183.3473953
 -183.28843818 -183.33802989 -183.32603386 -183.3261759  -183.44801023
 -183.32224964 -183.33890624 -183.32776358 -183.39522557 -183.42967993
 -183.28479888 -183.42374384 -183.34841266 -183.34724728 -183.38155279
 -183.36583503 -183.26812509 -183.42187262 -183.36264072 -183.35019716
 -183.34291338 -183.35784003 -183.36406478 -183.33326274 -183.31487359
 -183.29769548 -183.35765775 -183.31457876 -183.41671985 -183.35839015
 -183.36035132 -183.39617619 -183.41888778 -183.33868336 -183.36390226
 -183.3913535  -183.37049917 -183.34672805 -183.41595024 -183.41609209
 -183.27208169 -183.36588633 -183.36575854 -183.38492617 -183.30669681
 -183.3652985  -183.34753109 -183.27873682 -183.29494539 -183.31255995
 -183.38645997 -183.27979683 -183.28014392 -183.32076573 -183.40490586
 -183.3673588  -183.27147784 -183.33653505 -183.35485144 -183.34695236
 -183.31876245 -183.31426147 -183.40129948 -183.36815754 -183.29776043
 -183.4059854  -183.31635551 -183.29606833 -183.3367753  -183.28582159
 -183.31201141 -183.33469264 -183.31576578 -183.41351715 -183.30443336
 -183.33368771 -183.37647261 -183.27718848 -183.29870443 -183.31989079
 -183.25588621 -183.25946744 -183.30991834 -183.35004549 -183.25788821
 -183.45894366 -183.32909875 -183.35660224 -183.40699985 -183.40561473
 -183.26573261 -183.27078316 -183.34789553 -183.332326   -183.29853346
 -183.27689751 -183.27021409 -183.42493829 -183.29184517 -183.36397113
 -183.30229546 -183.31899049 -183.33038472 -183.38391371 -183.42271756
 -183.33081208 -183.28598658 -183.34222574 -183.37028479 -183.4102421
 -183.27716972 -183.3178205  -183.3142221  -183.33812336 -183.3200464
 -183.38391856 -183.30148722 -183.29452184 -183.36157505 -183.26995034
 -183.28121219 -183.30261415 -183.33203102 -183.33434494 -183.33189346
 -183.25996485 -183.33020862 -183.32684501 -183.33039936 -183.28719087
 -183.30571792 -183.37203308 -183.28857807 -183.26741038 -183.2913316
 -183.34322167 -183.32312235 -183.30787314 -183.31792635 -183.25327034
 -183.27364501 -183.31482307 -183.29906989 -183.27995454 -183.40782987
 -183.24703512 -183.3452285  -183.25609151 -183.35370056 -183.31836266
 -183.30550281 -183.32013066 -183.3337823  -183.35008625 -183.32188744
 -183.3023741  -183.34444794 -183.36272814 -183.31139951 -183.32155362
 -183.32483444 -183.3240045  -183.38583534 -183.29454518 -183.3344076
 -183.38991832 -183.3314131  -183.25381046 -183.34554207 -183.29691661]
2025-06-24 07:03:58 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:03:58 INFO Good algorithm:
Algorithm Name: AdaptiveMultimodalExploration
import numpy as np
import random

class AdaptiveMultimodalExploration:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        self.population_size = 100  # Adjust as needed
        self.population = None
        self.fitness_values = None
        self.F = 0.8  # Differential Evolution scaling factor
        self.CR = 0.9  # Crossover rate
        self.niche_radius = 0.1 * (self.upper_bounds[0] - self.lower_bounds[0]) # Initial niche radius. Adaptive later
        self.niches = []

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
        self.fitness_values = objective_function(self.population)
        self.eval_count += self.population_size
        self.best_solution_overall = self.population[np.argmin(self.fitness_values)]
        self.best_fitness_overall = np.min(self.fitness_values)

        while self.eval_count < self.budget:
            offspring = self.generate_offspring()
            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            # Selection with niching:
            combined_population = np.vstack((self.population, offspring))
            combined_fitness = np.concatenate((self.fitness_values, offspring_fitness))

            # Simple niching: only add if it's not too close to an existing niche
            new_niches = []
            for i in range(len(combined_population)):
                too_close = False
                for j in range(len(self.niches)):
                    if np.linalg.norm(combined_population[i] - self.niches[j][0]) < self.niche_radius:
                        too_close = True
                        break
                if not too_close:
                    new_niches.append( (combined_population[i], combined_fitness[i]) )
            
            #Adaptive Niche Radius
            if len(new_niches) > 0 :
                self.niche_radius = 0.5 * self.niche_radius + 0.5 * np.mean([np.linalg.norm(x[0]-y[0]) for x in new_niches for y in new_niches if np.any(x != y)])
            self.niches.extend(new_niches)

            #Keep best solutions, update population
            sorted_niches = sorted(self.niches, key=lambda x: x[1])
            self.niches = sorted_niches[:self.population_size]
            self.population = np.array([x[0] for x in self.niches])
            self.fitness_values = np.array([x[1] for x in self.niches])

            self.best_solution_overall = self.population[np.argmin(self.fitness_values)]
            self.best_fitness_overall = np.min(self.fitness_values)



        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'niches_found': len(self.niches)
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info


    def generate_offspring(self):
        offspring = np.zeros((self.population_size, self.dim))
        for i in range(self.population_size):
            a, b, c = random.sample(range(self.population_size), 3)
            while a == i or b == i or c == i:
                a, b, c = random.sample(range(self.population_size), 3)
            v = self.population[a] + self.F * (self.population[b] - self.population[c])
            for j in range(self.dim):
                if random.random() < self.CR:
                    offspring[i, j] = v[j]
                else:
                    offspring[i, j] = self.population[i, j]
            offspring[i] = np.clip(offspring[i], self.lower_bounds, self.upper_bounds)  # Bounds handling

        return offspring

2025-06-24 07:03:58 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:03:58 ERROR Can not run the algorithm
2025-06-24 07:03:58 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:03:58 INFO Run function 13 complete. FEHistory len: 200, AOCC: 0.0000
2025-06-24 07:03:58 INFO FeHistory: [3367338.92450776 1307322.91627964 1349613.65232211  677147.44905802
  864641.3962374  1545492.70518281 1533664.08157711 1943072.07872358
 1889845.7711796   748550.41793464 1042564.68646513  551596.28984781
 1384308.32600895 2237306.03519757 1662828.73896655 2216131.73603879
 2585427.46158718 1396791.77219773 1963624.81224645 2655423.12168157
 1756243.8249722  1225459.71897739 2190150.6046386  1442145.19151697
 1297084.12302981 1321288.52315363 4013170.16282912 2278307.29802119
 2195257.69877097 1658228.07985333 1880905.76301439  605118.67913506
  979892.80628507 3302161.76298435 1621094.46606252 1102581.47637996
 1080153.50816483 2803719.18525308 3155777.70237701  578411.9806363
  912307.02210161 2247913.12204165  670779.8334086   601510.5241492
 2325697.7052416  1774226.76395105 3156211.11008537 2130357.88324656
  659784.27599377 3211649.51287694 1685692.44379028  668171.47079312
 4802958.66944663 3673061.89292654 2196391.13797994 1512182.2600087
 2138160.75428705 1864853.71461145 3271968.88843529 1130819.63803005
  707876.32499512 3253365.95352731 2137468.86542162  674255.66159427
 1332215.20771585 3168729.83299241 1955367.97018653  788200.63202608
 1583232.85292594 2303783.92272062  743647.4451677  1525613.71765848
  645177.24419711 2817391.27432429  776574.54235985 1336493.55112663
 1303282.10143208 1775312.74618435 2314257.80197408 1655441.10825122
  708308.02544813 2795091.61241039 1297612.58988548 2643102.45634686
 1144695.60569827 4039582.65878515 1047238.16934653  764896.08637377
 1027820.8513139  1475247.73890459 2003755.2193551  1010958.94802199
 3434051.04615328 1685097.93421386 2404606.38858975  249954.90713296
 1860015.28329337 1118508.40647937 1425381.94535294 2453218.23008794
 4411520.86426229 4272186.42026897 2522412.85983335  604753.75119764
 3599461.72462997 1778902.61305542 2363998.12767675 1297499.33729885
 2305993.43908647 2841373.45063712 1408630.73693034 2920304.46966001
 4932191.20347784 2941976.04094429 2380978.69809161 4913043.04331478
 3612239.94524223 3654430.68110941 4502865.92853296 2266557.58026731
 2222855.28386178 2714150.91011004 5356528.57668712 2090990.9536838
 4967004.34402766 2424469.57973648 4246175.25566015 2272943.09293261
 2400365.7632263  2574483.06455571 1809817.22262105 1146931.02165909
 3317693.24495229 2820127.36696017 2667318.10826349 1735160.08668929
 1940777.70896872 2704316.77579252 1829487.3323051   831949.53068896
 1685492.37436804  882208.64807854 2656946.65957725  869297.4434725
  685332.72711173 2026731.75827173 2401211.6816722  4293993.77109997
 2313278.32577409 4505801.3450476   860745.31589595 2697785.87946396
 2343813.31120536 1456068.6803542  3501837.35265261 3127968.53270603
 1861942.67407669 3331106.2402641  3393850.47294905 2102226.00424518
 1260126.49044441 2817474.06288878  810643.32599717 2978128.18856061
 2117039.04424076 2245378.12960312 4120866.26712853 1201608.91646762
 1373082.93831993 2556928.19300679 3635357.63476201 4516323.05416867
 2496887.89691163 1776522.67330769 2601031.87812088 3879093.84500417
 2038231.33552922 3498841.62027292 2264190.47193935 1878157.34874931
 5500420.13379017 1873942.06064278 2020836.97517237 1528054.18164216
 1219119.58565665  766445.57272212 1538826.25873358 1735820.22010774
 4794121.94737338 3109559.2156128  4594368.21499179 1243333.36796845
 1086467.58638884 2390771.30855335 2261816.52105557 1431534.99541845
 4407129.95266175 1762177.82425391 2792697.90416151 1362026.10291806]
2025-06-24 07:03:58 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:03:58 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:03:58 ERROR Can not run the algorithm
2025-06-24 07:03:59 INFO Run function 18 complete. FEHistory len: 200, AOCC: 0.0000
2025-06-24 07:03:59 INFO FeHistory: [187646.51682112 131153.94610541 150377.46918389 163393.43812748
 179971.14904254 133214.93786655 106385.83181817 152220.01867745
 153496.65607974 158451.12303005 141587.31805632 138529.40558102
 136865.13000921 158405.63275834 145960.22113228  99383.61039278
  93881.08132955 182528.20363001 159727.3469178  162476.03847219
 104340.50011192 148364.48307382 154712.18483252 110822.19738
 190027.78981347 146959.76707036 113933.5201035  180972.01149828
 132922.69408088 134001.32486214 144710.61818568 221195.26562646
 145029.44801236 130195.08180138 108180.1333315  138373.36400844
 137429.70821175 132811.82310988 114020.50781855 164360.37068075
 154959.4919988  125523.10865155 126152.89922217 169663.69249627
 125449.92020937 175986.48411776 137724.34941823  94994.40272474
 195593.84264822 188448.92073629 190206.21333422 126960.90167811
 106655.92191324 137951.70410778 171490.28886264 202663.7333797
 178937.33173951 184463.89234154 163417.83829154 173365.99046195
 164810.97956005 150279.94676123 204063.80207651 177323.1005037
  83540.43277735 150305.19863375 141843.14639489 132641.45779687
 103538.37064764  87005.1018614  137906.45187039 191278.69002047
 131679.79629435 170100.66168891 139056.13626088 213788.75105025
 200409.76656661 120864.81761661 210928.08852306 137423.1658759
 174387.97587669 135655.21969617 166126.72078605 207452.7487042
 121224.45562457 220022.61219401  74039.1723084  120139.8992912
 117720.32005102 195173.55141375 140866.35707911 195546.06896098
 230831.36703322  55596.14319798 145178.51690258 150385.31132228
 165235.54867158 176066.57512055  86218.05993028 175831.98476133
 209926.93330284 217988.70717261 155450.17099147 151193.95144771
 161831.07888202 216218.32124642 176912.24563501 190725.47349185
 200139.4182695  108750.30104669 165797.89630181 158176.70562039
 261411.71616777 177013.06090294 220668.3643826  177312.67897284
 127102.33069448 232333.78126245 198253.98711484 139661.2189382
 134528.05553832 205770.63748812 157319.25556064 263879.48706614
 212833.81219777 229316.78880328 148537.46993898 146459.45484832
 222416.33986761 194882.36746194 259583.81889204 123342.94968749
 197038.45675908 210147.74001083  91630.92984051 203509.43651571
 225312.45866679 150726.75347701 242278.60190889 218831.05220228
 260747.0263858  172798.66420947 193667.92555797 145326.90549158
 143521.04889562 169558.76732342 168067.36112803 167386.35218452
 216847.78425278 197713.51971668 162754.70077313 268100.83148987
 165632.0698582  106967.29226945 166802.77780145 200483.68381642
 210777.83372896 130733.49664784 266348.38361977 157792.55505894
 194779.17047044 126136.35523888 120596.64758975 210757.02095639
 111976.77259235 175354.34861803 163248.45413282 152997.58189099
 209790.01779489 221095.59286866 175987.88474236 207460.90117453
 237900.24196526 171797.67346074 154195.29838692 219821.08506333
 156238.6330646  183672.06189758 177281.85063605 126382.30531503
 179335.70158382 229379.49108474 168562.67502096 176097.10194306
 275963.91385459 254945.72775748 202374.63813164 199560.44409201
 155008.28857383 135392.53578959 235760.18945861 128659.0308733
 155364.99654207 159456.50629803 166398.71418633 222181.77370943
 166167.16504176 182415.33543729 143112.62154903 159439.95001494]
2025-06-24 07:03:59 INFO Expected Optimum FE: -5000
2025-06-24 07:03:59 INFO Unimodal AOCC mean: 0.1468
2025-06-24 07:03:59 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:03:59 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 07:03:59 INFO AOCC mean: 0.0489
2025-06-24 07:03:59 INFO Weighed AOCC mean: 0.0147
2025-06-24 07:03:59 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:04:07 INFO Run function 6 complete. FEHistory len: 100000, AOCC: 0.1519
2025-06-24 07:04:07 INFO FeHistory: [-183.33660047 -183.30660611 -183.3285376  ... -183.79128793 -183.69165539
 -183.80386557]
2025-06-24 07:04:07 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:04:07 INFO Good algorithm:
Algorithm Name: AdaptiveMultimodalOptimizer
import numpy as np
import random

class AdaptiveMultimodalOptimizer:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        self.population_size = 100  # Adjust as needed
        self.population = None
        self.F = 0.8 # Differential Evolution scaling factor
        self.CR = 0.9 # Differential Evolution crossover rate
        self.mutation_rate = 0.1 # Initial mutation rate. This will be adapted.

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
        fitness_values = objective_function(self.population)
        self.eval_count += self.population_size
        best_index = np.argmin(fitness_values)
        self.best_solution_overall = self.population[best_index].copy()
        self.best_fitness_overall = fitness_values[best_index]


        while self.eval_count < self.budget:
            new_population = []
            for i in range(self.population_size):
                # Differential Evolution
                a, b, c = random.sample(range(self.population_size), 3)
                while a == i or b == i or c == i:
                    a, b, c = random.sample(range(self.population_size), 3)
                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])

                # Boundary handling
                mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

                # Crossover
                trial = np.copy(self.population[i])
                crossover_points = np.random.rand(self.dim) < self.CR
                trial[crossover_points] = mutant[crossover_points]

                # Adaptive Mutation to escape local optima (more likely when stuck)
                if self.eval_count > self.budget * 0.5: #increase mutation after half the budget
                    if random.random() < self.mutation_rate:
                        mutation_index = np.random.randint(0, self.dim)
                        trial[mutation_index] = np.random.uniform(self.lower_bounds[mutation_index], self.upper_bounds[mutation_index])


                trial_fitness = objective_function(trial.reshape(1, -1))[0]
                self.eval_count += 1

                if trial_fitness < fitness_values[i]:
                    new_population.append(trial)
                    fitness_values[i] = trial_fitness
                    if trial_fitness < self.best_fitness_overall:
                        self.best_fitness_overall = trial_fitness
                        self.best_solution_overall = trial.copy()
                else:
                    new_population.append(self.population[i])

            self.population = np.array(new_population)

            #Adapt Mutation Rate based on progress (very basic adaptation for example)
            if self.eval_count > self.budget * 0.7 and self.best_fitness_overall > acceptance_threshold:
              if self.best_fitness_overall < 0.9 * self.best_fitness_overall:
                  self.mutation_rate *=1.2
              else:
                  self.mutation_rate *= 0.8
                  self.mutation_rate = max(0.01, self.mutation_rate) #clamp mutation to avoid 0


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

2025-06-24 07:04:07 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:04:07 INFO Run function 6 complete. FEHistory len: 100000, AOCC: 0.1524
2025-06-24 07:04:07 INFO FeHistory: [-183.38220751 -183.28802275 -183.33777888 ... -183.80422297 -183.77349029
 -183.77796039]
2025-06-24 07:04:07 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:04:07 INFO Good algorithm:
Algorithm Name: AdaptiveMultimodalOptimizer
import numpy as np
import random

class AdaptiveMultimodalOptimizer:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        self.population_size = 100  # Adjust as needed
        self.population = None
        self.fitness_values = None
        self.F = 0.8  # Differential Evolution scaling factor
        self.CR = 0.9  # Differential Evolution crossover rate
        self.niche_radius = 0.5 # Initial niche radius, adaptive later.
        self.mutation_rate = 0.1 # Initial mutation rate.

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        self.fitness_values = objective_function(self.population)
        self.eval_count += self.population_size
        
        self.best_solution_overall = self.population[np.argmin(self.fitness_values)]
        self.best_fitness_overall = np.min(self.fitness_values)

        while self.eval_count < self.budget:
            # Differential Evolution
            offspring = np.zeros_like(self.population)
            for i in range(self.population_size):
                a, b, c = random.sample(range(self.population_size), 3)
                while a == i or b == i or c == i:
                    a, b, c = random.sample(range(self.population_size), 3)
                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])
                mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds) #Bound checking

                trial = np.zeros_like(self.population[i])
                for j in range(self.dim):
                    if random.random() < self.CR:
                        trial[j] = mutant[j]
                    else:
                        trial[j] = self.population[i][j]
                offspring[i] = trial


            offspring_fitness = objective_function(offspring)
            self.eval_count += self.population_size

            #Selection
            for i in range(self.population_size):
                if offspring_fitness[i] < self.fitness_values[i]:
                    self.population[i] = offspring[i]
                    self.fitness_values[i] = offspring_fitness[i]

            # Adaptive Niching and Mutation
            self.update_niche_and_mutation()

            # Update best solution
            best_index = np.argmin(self.fitness_values)
            if self.fitness_values[best_index] < self.best_fitness_overall:
                self.best_solution_overall = self.population[best_index]
                self.best_fitness_overall = self.fitness_values[best_index]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def update_niche_and_mutation(self):
        #Simple niching: reduce niche radius if many solutions are close, increase mutation rate
        distances = np.linalg.norm(self.population[:, np.newaxis, :] - self.population[np.newaxis, :, :], axis=2)
        close_pairs = np.sum(distances < self.niche_radius)

        if close_pairs > 0.8 * self.population_size * (self.population_size-1) / 2: # Many close solutions
            self.niche_radius *= 0.9
            self.mutation_rate *= 1.1 # Increase exploration
        else:
            self.niche_radius *= 1.1
            self.mutation_rate *= 0.9 # Reduce exploration



2025-06-24 07:04:07 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:04:08 INFO Run function 6 complete. FEHistory len: 100000, AOCC: 0.1566
2025-06-24 07:04:08 INFO FeHistory: [-183.33897723 -183.33917862 -183.322479   ... -183.8386142  -183.7375336
 -183.87590871]
2025-06-24 07:04:08 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:04:08 INFO Good algorithm:
Algorithm Name: AdaptiveDifferentialEvolutionWithClustering
import numpy as np
from sklearn.cluster import KMeans

class AdaptiveDifferentialEvolutionWithClustering:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        
        self.population_size = 100  # Adjust as needed
        self.F = 0.8 # Differential weight (can be adapted)
        self.CR = 0.9 # Crossover rate (can be adapted)
        self.cluster_count = 5 # Number of clusters for analysis

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        if self.dim > 0:
            self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
        else:
            self.population = np.array([])
        
        fitness_values = objective_function(self.population)
        self.eval_count += self.population_size
        
        self.best_solution_overall = self.population[np.argmin(fitness_values)]
        self.best_fitness_overall = np.min(fitness_values)

        generation = 0
        while self.eval_count < self.budget:
            generation += 1
            offspring = []
            offspring_fitness = []
            
            for i in range(self.population_size):
                # Differential Evolution mutation
                a, b, c = np.random.choice(np.arange(self.population_size), 3, replace=False)
                while a == i or b == i or c == i:  # Ensure different individuals
                    a, b, c = np.random.choice(np.arange(self.population_size), 3, replace=False)

                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])

                # Adaptive Mutation: Adjust F based on success rate
                
                # Boundary handling
                mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)


                # Crossover
                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.population[i])

                offspring.append(trial)


            offspring = np.array(offspring)
            offspring_fitness = objective_function(offspring)
            self.eval_count += self.population_size

            # Selection
            combined_population = np.vstack((self.population, offspring))
            combined_fitness = np.concatenate((fitness_values, offspring_fitness))
            
            sorted_indices = np.argsort(combined_fitness)
            self.population = combined_population[sorted_indices[:self.population_size]]
            fitness_values = combined_fitness[sorted_indices[:self.population_size]]
            

            #Clustering Analysis (Adaptive Strategy)
            if generation % 10 == 0: #check clustering every 10 generations. Adjust as needed
                kmeans = KMeans(n_clusters=self.cluster_count, random_state=0).fit(self.population)
                cluster_centers = kmeans.cluster_centers_
                
                if np.min(objective_function(cluster_centers)) < self.best_fitness_overall:
                   self.best_solution_overall = cluster_centers[np.argmin(objective_function(cluster_centers))]
                   self.best_fitness_overall = np.min(objective_function(cluster_centers))
                   
            
            self.best_solution_overall = self.population[np.argmin(fitness_values)]
            self.best_fitness_overall = np.min(fitness_values)

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'generations': generation
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

2025-06-24 07:04:08 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:04:09 INFO Run function 6 complete. FEHistory len: 100000, AOCC: 0.1524
2025-06-24 07:04:09 INFO FeHistory: [-183.38885795 -183.36136844 -183.27892248 ... -183.86039827 -183.77567523
 -183.70622941]
2025-06-24 07:04:09 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:04:09 INFO Good algorithm:
Algorithm Name: AdaptiveMultimodalOptimizer
# Name: AdaptiveMultimodalOptimizer
# Description: A hybrid evolutionary algorithm combining Differential Evolution with adaptive mutation and a local search to effectively tackle multimodal landscapes.

import numpy as np
import random

class AdaptiveMultimodalOptimizer:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        
        self.population_size = 100  # Adjust as needed
        self.F = 0.8  # Differential Evolution scaling factor
        self.CR = 0.9 # Crossover rate
        self.adaptation_rate = 0.1 #Rate of adapting mutation strength
        self.local_search_radius = 0.1 # parameter controlling local search intensity


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        if self.dim > 0:
            self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
        else:
            self.population = np.array([])
        
        self.fitness_values = np.full(self.population_size, float('inf'))


        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')


        #Initial Fitness Evaluation
        for i in range(self.population_size):
          self.fitness_values[i] = objective_function(self.population[i].reshape(1,-1))[0]
          self.eval_count += 1
          if self.fitness_values[i] < self.best_fitness_overall:
              self.best_fitness_overall = self.fitness_values[i]
              self.best_solution_overall = np.copy(self.population[i])


        mutation_strength = 1.0 # Initialize mutation strength

        while self.eval_count < self.budget:
            new_population = np.zeros_like(self.population)
            for i in range(self.population_size):
                #Differential Evolution Mutation
                a, b, c = random.sample(range(self.population_size), 3)
                while a == i or b == i or c == i:
                    a, b, c = random.sample(range(self.population_size), 3)
                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])

                #Clamp to bounds
                mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

                #Crossover
                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.population[i])


                #Adaptive Mutation
                trial += np.random.normal(0, mutation_strength, self.dim) #Add gaussian noise
                trial = np.clip(trial, self.lower_bounds, self.upper_bounds)

                #Evaluation and Selection
                fitness_trial = objective_function(trial.reshape(1, -1))[0]
                self.eval_count += 1
                if fitness_trial < self.fitness_values[i]:
                    new_population[i] = trial
                    self.fitness_values[i] = fitness_trial
                    if fitness_trial < self.best_fitness_overall:
                        self.best_fitness_overall = fitness_trial
                        self.best_solution_overall = np.copy(trial)
                else:
                    new_population[i] = self.population[i]

            self.population = new_population

            #Local Search (periodically)
            if self.eval_count % (self.budget // 10) == 0:
                self.local_search(objective_function)

            #Adaptive Mutation Strength Adjustment
            mutation_strength *= (1 - self.adaptation_rate) + self.adaptation_rate * np.random.rand()



        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def local_search(self, objective_function):
        neighbor = self.best_solution_overall + np.random.uniform(-self.local_search_radius, self.local_search_radius, self.dim)
        neighbor = np.clip(neighbor, self.lower_bounds, self.upper_bounds)
        fitness_neighbor = objective_function(neighbor.reshape(1, -1))[0]
        self.eval_count += 1
        if fitness_neighbor < self.best_fitness_overall:
            self.best_fitness_overall = fitness_neighbor
            self.best_solution_overall = np.copy(neighbor)

2025-06-24 07:04:09 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:04:17 INFO Run function 13 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:04:17 INFO FeHistory: [2942317.2207718  1422972.8817063  1938257.23306073 ... 2191627.0635373
  854696.38766292 1777051.77457536]
2025-06-24 07:04:17 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:04:17 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:04:17 INFO Run function 6 complete. FEHistory len: 100000, AOCC: 0.1474
2025-06-24 07:04:17 INFO FeHistory: [-183.34204401 -183.3876191  -183.30664722 ... -183.2410046  -183.33731776
 -183.19987195]
2025-06-24 07:04:17 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:04:17 INFO Good algorithm:
Algorithm Name: AdaptiveMultimodalOptimizer
import numpy as np
import random

class AdaptiveMultimodalOptimizer:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        self.population_size = 100  # Adjust as needed
        self.population = None
        self.fitness_values = None
        self.F = 0.8  # Differential evolution scaling factor
        self.CR = 0.9  # Differential evolution crossover rate
        self.niche_radius = 0.1 * (np.max(self.upper_bounds) - np.min(self.lower_bounds)) #Initial niche radius


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        self.fitness_values = objective_function(self.population)
        self.eval_count += self.population_size

        self.best_solution_overall = self.population[np.argmin(self.fitness_values)]
        self.best_fitness_overall = np.min(self.fitness_values)


        while self.eval_count < self.budget:
            offspring = self.generate_offspring()
            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            self.selection(offspring, offspring_fitness)
            self.adapt_parameters()
            self.niche_radius *= 0.99  # Gradually reduce niche radius

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info


    def generate_offspring(self):
        offspring = np.zeros((self.population_size, self.dim))
        for i in range(self.population_size):
            a, b, c = random.sample(range(self.population_size), 3)
            while a == i or b == i or c == i:
                a, b, c = random.sample(range(self.population_size), 3)
            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])

            # Bound handling
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

            for j in range(self.dim):
                if random.random() < self.CR:
                    offspring[i, j] = mutant[j]
                else:
                    offspring[i, j] = self.population[i, j]

        return offspring


    def selection(self, offspring, offspring_fitness):
        combined_population = np.concatenate((self.population, offspring))
        combined_fitness = np.concatenate((self.fitness_values, offspring_fitness))

        # Niching: Select diverse solutions
        selected_indices = []
        for i in range(self.population_size):
            best_index = np.argmin(combined_fitness)
            selected_indices.append(best_index)
            combined_fitness[best_index] = np.inf
            # Remove solutions in the niche of the selected solution
            for j in range(len(combined_fitness)):
                if combined_fitness[j] != np.inf and np.linalg.norm(combined_population[best_index] - combined_population[j]) < self.niche_radius:
                    combined_fitness[j] = np.inf


        self.population = combined_population[selected_indices]
        self.fitness_values = combined_fitness[selected_indices]
        
        if np.min(self.fitness_values) < self.best_fitness_overall:
            self.best_fitness_overall = np.min(self.fitness_values)
            self.best_solution_overall = self.population[np.argmin(self.fitness_values)]

    def adapt_parameters(self):
        #Simple adaptive strategy: Reduce F and increase CR if convergence is slow.
        if self.eval_count > self.budget * 0.5 and self.best_fitness_overall > 1e-2: #Adjust threshold as needed
            self.F *= 0.95
            self.CR *= 1.05

            self.F = max(0.2, self.F) #Keep F within reasonable bounds
            self.CR = min(0.99, self.CR)
2025-06-24 07:04:17 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:04:17 INFO Run function 13 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:04:17 INFO FeHistory: [2976502.04803023 3587255.41554904 1341583.72126034 ... 1770355.03790597
 2277764.42836261 2787355.57628156]
2025-06-24 07:04:17 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:04:17 INFO Run function 13 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:04:17 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:04:17 INFO FeHistory: [2738074.41290044 2422609.7999503  1485882.03143077 ... 2564128.3841174
 5883349.52994466 2433604.43537285]
2025-06-24 07:04:17 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:04:18 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:04:19 INFO Run function 13 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:04:19 INFO FeHistory: [1455640.74019922 1072221.58532523 3471275.08996037 ... 1074402.10039547
 1401416.8832151  1483019.42237388]
2025-06-24 07:04:19 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:04:19 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:04:36 INFO Run function 13 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:04:36 INFO FeHistory: [ 805358.13360505 1277921.83226684 2303302.59202245 ... 2728742.35404931
 3331092.7495709  1940639.88881041]
2025-06-24 07:04:36 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:04:36 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:04:45 INFO Run function 18 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:04:45 INFO FeHistory: [126362.23271405 108557.35922492 243701.66228434 ...  20501.98065331
   7445.66954249   7977.5524944 ]
2025-06-24 07:04:45 INFO Expected Optimum FE: -5000
2025-06-24 07:04:45 INFO Unimodal AOCC mean: 0.1566
2025-06-24 07:04:45 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:04:45 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 07:04:45 INFO AOCC mean: 0.0522
2025-06-24 07:04:45 INFO Weighed AOCC mean: 0.0157
2025-06-24 07:04:45 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:04:45 ERROR Can not run the algorithm
2025-06-24 07:04:46 INFO Run function 6 complete. FEHistory len: 144, AOCC: 0.1476
2025-06-24 07:04:46 INFO FeHistory: [-183.40532017 -183.37799926 -183.29997313 -183.32235259 -183.25541557
 -183.32202805 -183.38689237 -183.40967261 -183.40555884 -183.26425795
 -183.29172716 -183.36851001 -183.35033383 -183.3274311  -183.40351005
 -183.34167459 -183.34600708 -183.37641713 -183.38579196 -183.28922031
 -183.37420693 -183.22936441 -183.29881713 -183.35299082 -183.35489165
 -183.39965036 -183.42762478 -183.38176971 -183.29457173 -183.34451856
 -183.44501702 -183.33331311 -183.37553077 -183.31403646 -183.35573617
 -183.3674465  -183.39297695 -183.31002108 -183.27549742 -183.2922207
 -183.29293737 -183.50328649 -183.2911625  -183.43078128 -183.37802348
 -183.32102247 -183.34143942 -183.25000257 -183.32830941 -183.37401634
 -183.39948134 -183.28417896 -183.34491592 -183.32826691 -183.33969921
 -183.36235567 -183.35883303 -183.37898636 -183.38992406 -183.41347048
 -183.39133601 -183.30160665 -183.37152805 -183.339446   -183.36535738
 -183.40740803 -183.35427566 -183.33017058 -183.2914563  -183.30303069
 -183.43372748 -183.33920315 -183.30208304 -183.25602252 -183.32642234
 -183.39169578 -183.33777498 -183.30482807 -183.44067068 -183.38303791
 -183.4095386  -183.32928554 -183.27569854 -183.38168069 -183.41964662
 -183.35861551 -183.29399709 -183.3122887  -183.30588051 -183.2552954
 -183.32188049 -183.40498852 -183.3485273  -183.32250745 -183.36174825
 -183.35588996 -183.31836168 -183.41667046 -183.45245232 -183.35224159
 -183.28457034 -183.33159349 -183.3425999  -183.52256678 -183.24948064
 -183.26571921 -183.23330829 -183.32872362 -183.39387684 -183.43182174
 -183.34579586 -183.25733595 -183.27268716 -183.34396439 -183.32560101
 -183.35463271 -183.26405983 -183.28639494 -183.38956452 -183.31373337
 -183.33405941 -183.29212793 -183.30830551 -183.3095876  -183.39092793
 -183.35071324 -183.2365974  -183.29264943 -183.26880476 -183.33744029
 -183.22633635 -183.25335851 -183.35582616 -183.21404625 -183.33624047
 -183.2801882  -183.34608028 -183.23838872 -183.3193578  -183.37483826
 -183.26480968 -183.34972412 -183.26784674 -183.37403158]
2025-06-24 07:04:46 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:04:46 INFO Good algorithm:
Algorithm Name: AdaptiveMultimodalOptimizer
import numpy as np
import random

class AdaptiveMultimodalOptimizer:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        
        self.population_size = 100  # Adjust as needed
        self.population = None
        self.F = 0.8 # Differential evolution scaling factor
        self.CR = 0.9 # Differential evolution crossover rate

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
        fitness_values = objective_function(self.population)
        self.eval_count += self.population_size
        
        best_index = np.argmin(fitness_values)
        self.best_solution_overall = self.population[best_index].copy()
        self.best_fitness_overall = fitness_values[best_index]


        while self.eval_count < self.budget:
            new_population = []
            for i in range(self.population_size):
                # Differential Evolution Mutation
                a, b, c = random.sample(range(self.population_size), 3)
                while a == i or b == i or c == i:
                    a, b, c = random.sample(range(self.population_size), 3)
                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])

                # Levy Flight Mutation for Exploration (with probability 0.1)
                if random.random() < 0.1:
                    levy_step = self.levy_flight(self.dim)
                    mutant = mutant + levy_step

                # Crossover
                trial = np.zeros(self.dim)
                for j in range(self.dim):
                    if random.random() < self.CR:
                        trial[j] = mutant[j]
                    else:
                        trial[j] = self.population[i][j]

                #Boundary Handling
                trial = np.clip(trial, self.lower_bounds, self.upper_bounds)
                
                trial_fitness = objective_function(trial.reshape(1,-1))
                self.eval_count += 1
                
                if trial_fitness < fitness_values[i]:
                    new_population.append(trial)
                    fitness_values[i] = trial_fitness[0]
                    if trial_fitness < self.best_fitness_overall:
                        self.best_solution_overall = trial.copy()
                        self.best_fitness_overall = trial_fitness[0]
                else:
                    new_population.append(self.population[i])


            self.population = np.array(new_population)

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
    
    def levy_flight(self, dim):
        beta = 3/2
        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1/beta)
        u = np.random.normal(0, 1, dim)
        v = np.random.normal(0, 1, dim)
        step = u / (np.abs(v)**(1/beta))
        return step


2025-06-24 07:04:46 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:04:46 ERROR Can not run the algorithm
2025-06-24 07:04:46 INFO Run function 18 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:04:46 INFO FeHistory: [160130.17235757 151722.29538949 163447.88514808 ...  30243.19249981
   9261.0234127   13830.20964931]
2025-06-24 07:04:46 INFO Expected Optimum FE: -5000
2025-06-24 07:04:46 INFO Unimodal AOCC mean: 0.1524
2025-06-24 07:04:46 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:04:46 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 07:04:46 INFO AOCC mean: 0.0508
2025-06-24 07:04:46 INFO Weighed AOCC mean: 0.0152
2025-06-24 07:04:46 INFO Run function 13 complete. FEHistory len: 105, AOCC: 0.0000
2025-06-24 07:04:46 INFO FeHistory: [ 906811.38329464  654356.69921692 2154734.98231278 2203724.25475816
 2152486.33941246 1192287.17731235 1843941.43431382 1733700.93791852
 1564274.55946247  775377.77961408  986489.59389708 1516938.80411599
  429717.42266447 2789383.89162091 2162548.31363677 2531588.9734032
 2105418.89930728 2321703.26404645 2087099.88328307 1288345.47420705
  722446.57972681 2249093.70994722 2476542.00564075 1686118.88638126
 2187393.39807588 2066462.73218172 2883293.90895346 2595580.07492716
 3186692.04504134 1600368.27798418 2753644.89378039 1059812.5816751
 1137073.56522664 2585487.1064078   755197.14131511 3277224.38289991
 3766285.14483745 1022684.88425635 1106887.52526589 1179784.20979124
 2559845.24457207 1402563.570057   2424912.92385726 2218063.77348346
 1400628.07060057 1848073.65901261  796604.04582151 1306532.35573807
 1730618.78121407 1622531.36739635 2429116.26149165 1575276.4803677
 1720011.25733554 1213347.06248886 1090190.7907523  3811529.3129976
 2267360.71180355  960581.44163211  381827.87146241 2444784.12291736
 1107879.98823133 1531119.25728828 2935913.20762689 2068786.53648096
 2030443.05205237 1229622.70780965  243365.34091246 1610726.48579738
 1610781.02370496  787737.0483865   567823.28004247 1032304.67156752
 1482255.27838607 1475262.55354714 2413122.94777864 3333529.96177439
 1648333.54590026 1665693.41381229 1873053.31371221 2883371.71609684
 1767070.54169595 1205777.06201458 1540815.67080245 2597723.9238083
 2772816.37342245 1692654.46458541 1999373.89201354  818874.16996002
 2702286.11975058 2967508.78235681 2573415.87761498 1547123.52548281
  801868.22227127  696227.88039368  983754.48486208 2334070.55082002
  444500.58197808 2195264.43712989 2652393.10512907 2433671.73870313
 2972593.95420665 1175358.09350166 1710341.17770778 1366665.68618931
 3336396.17564521]
2025-06-24 07:04:46 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:04:46 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:04:46 INFO Run function 18 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:04:46 INFO FeHistory: [184175.09952684  99850.67427502 260349.99726659 ...  54577.75840837
  11228.71430061  19716.372542  ]
2025-06-24 07:04:46 INFO Expected Optimum FE: -5000
2025-06-24 07:04:46 INFO Unimodal AOCC mean: 0.1519
2025-06-24 07:04:46 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:04:46 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 07:04:46 INFO AOCC mean: 0.0506
2025-06-24 07:04:46 INFO Weighed AOCC mean: 0.0152
2025-06-24 07:04:46 ERROR Can not run the algorithm
2025-06-24 07:04:46 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:04:46 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:04:46 INFO Run function 18 complete. FEHistory len: 117, AOCC: 0.0000
2025-06-24 07:04:46 INFO FeHistory: [180841.58847762 167553.14152424 151534.463912   142679.01770872
  89930.59113603 142488.54790238 141786.3902927  126783.03181047
 157139.36699585 195951.57698386 174686.85981968 211438.26861264
 246532.30593078 137708.27348688 138076.30885637 250530.86876534
 154007.33389576 129998.1387017  219567.0405776  157134.10186894
 139011.7183295  133786.08133986 114519.39617544 158791.96261966
 191603.01817599 107911.06958595 126118.19363495 140504.43324908
 161460.1084909  135342.87282994 117287.89099364 130030.1027389
 148201.19355701 200440.68431748 110023.78845823 153200.80595573
 153608.7348873  174003.31604666 106108.41768874 147993.54829518
 154963.50456796 151039.66313873 143465.7285463  118192.99504977
 129954.55813888 135780.55783056 146853.99711829 151387.56920147
 154344.75744401 196332.97404959  97210.39475761 118965.69781517
 109238.05676131 141024.57082118 140968.22229537 106328.82048454
 145358.96336335  85912.80584832 126144.78578865 160480.13686097
 100248.75599334 156512.74380533 186708.559505   126958.56174769
 153642.68322167 225611.16395585 121054.9849854  141592.10962822
 185720.92387298 236016.49129285  98309.44335769 164275.20289421
 157546.80570223 208036.15314314 149462.2976049  178407.25407219
 166197.66101484 193424.8432038  123411.75223165 153128.56896118
 205213.49510969 111652.92152227 159395.3838065  127774.14078207
 133265.80424439 115154.51084938 139409.60171901 169718.88939709
  94856.73174924 220630.14304909 132075.23127881 262042.76306331
 178533.44958543 152447.7320455  112705.60164695 105040.22067039
 184636.15055391 176378.23182989 177611.83654318 160631.95313121
  91048.49901432 199808.34205339  96070.44015568 164425.46488305
 160229.16234387 164065.01377472 214006.4866871  231801.15238047
 153190.65279718 224919.25306705 195332.69277063 216908.02565564
 151995.51931866 196079.49174567 191552.53325956 167870.90666864
 120681.70032062]
2025-06-24 07:04:46 INFO Expected Optimum FE: -5000
2025-06-24 07:04:46 INFO Unimodal AOCC mean: 0.1476
2025-06-24 07:04:46 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:04:46 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 07:04:46 INFO AOCC mean: 0.0492
2025-06-24 07:04:46 INFO Weighed AOCC mean: 0.0148
2025-06-24 07:04:46 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:04:46 ERROR Can not run the algorithm
2025-06-24 07:04:47 INFO Run function 6 complete. FEHistory len: 108, AOCC: 0.1469
2025-06-24 07:04:47 INFO FeHistory: [-183.31898761 -183.36521162 -183.2626785  -183.37767507 -183.35441301
 -183.28885688 -183.35223894 -183.27497388 -183.33739674 -183.40351502
 -183.33284523 -183.23169451 -183.31259508 -183.32590911 -183.40485833
 -183.37148874 -183.29763114 -183.31583359 -183.37996627 -183.42741601
 -183.46400938 -183.31171179 -183.33659302 -183.34366938 -183.31777749
 -183.3515405  -183.3924222  -183.2768341  -183.41884922 -183.33344632
 -183.33053932 -183.2870868  -183.39514388 -183.31726886 -183.31102954
 -183.37310526 -183.42323376 -183.29653575 -183.31230147 -183.31974799
 -183.38107553 -183.32538364 -183.33310813 -183.27751697 -183.31174792
 -183.3840698  -183.36810484 -183.30380618 -183.34949757 -183.3675095
 -183.38937826 -183.38165469 -183.3302111  -183.32127011 -183.2591329
 -183.46733353 -183.39438065 -183.29095462 -183.42605548 -183.40380431
 -183.31076747 -183.283478   -183.35686727 -183.30099972 -183.42651278
 -183.30445373 -183.3739487  -183.39330723 -183.3450636  -183.40376135
 -183.31510091 -183.34532557 -183.45574512 -183.25984186 -183.37505712
 -183.30705663 -183.32819888 -183.25061109 -183.33262814 -183.35414265
 -183.34757225 -183.33595947 -183.34566906 -183.39058472 -183.37327095
 -183.40337214 -183.35106211 -183.35119837 -183.36577628 -183.38707199
 -183.3129073  -183.35627003 -183.29166308 -183.32140874 -183.40992061
 -183.31948392 -183.33845719 -183.38132295 -183.35888879 -183.34394805
 -183.29366335 -183.4147116  -183.32760853 -183.33720348 -183.35120436
 -183.29539561 -183.2964037  -183.28173379]
2025-06-24 07:04:47 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:04:47 INFO Good algorithm:
Algorithm Name: AdaptiveMultimodalOptimizer
# Name: AdaptiveMultimodalOptimizer
# Description: A hybrid evolutionary algorithm combining Differential Evolution with a Levy flight mutation strategy for escaping local optima and adaptive weighting to prioritize difficult multi-component problems.

import numpy as np
import random

class AdaptiveMultimodalOptimizer:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        
        self.population_size = 100  # Adjust as needed
        self.population = None
        self.F = 0.8  # Differential Evolution scaling factor
        self.CR = 0.9  # Crossover rate

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        if self.dim > 0:
            self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
        else:
            self.population = np.array([])

        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        
        fitness_values = objective_function(self.population)
        self.eval_count += self.population_size

        best_index = np.argmin(fitness_values)
        self.best_solution_overall = self.population[best_index]
        self.best_fitness_overall = fitness_values[best_index]


        while self.eval_count < self.budget:
            new_population = []
            for i in range(self.population_size):
                # Differential Evolution mutation
                a, b, c = random.sample(range(self.population_size), 3)
                while a == i or b == i or c == i:
                    a, b, c = random.sample(range(self.population_size), 3)
                mutant = self.population[a] + self.F * (self.population[b] - self.population[c])

                # Levy Flight Mutation for exploration
                if random.random() < 0.1:  # Probability of Levy flight
                    levy_step = self._levy_flight(self.dim)
                    mutant += levy_step

                # Boundary handling
                mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

                # Crossover
                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, self.population[i])

                # Evaluation
                trial_fitness = objective_function(trial.reshape(1, -1))[0]
                self.eval_count += 1
                
                if trial_fitness < fitness_values[i]:
                    new_population.append(trial)
                    fitness_values[i] = trial_fitness
                    if trial_fitness < self.best_fitness_overall:
                        self.best_solution_overall = trial
                        self.best_fitness_overall = trial_fitness
                else:
                    new_population.append(self.population[i])

            self.population = np.array(new_population)

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def _levy_flight(self, dim):
        # Levy flight using Mantegna's algorithm
        beta = 1.5
        sigma_u = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)
        sigma_v = 1
        u = np.random.normal(0, sigma_u, dim)
        v = np.random.normal(0, sigma_v, dim)
        step = u / (np.abs(v)**(1 / beta))
        return step * 0.01  # Scale the step to avoid overly large jumps

2025-06-24 07:04:47 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:04:47 ERROR Can not run the algorithm
2025-06-24 07:04:47 INFO Run function 13 complete. FEHistory len: 108, AOCC: 0.0000
2025-06-24 07:04:47 INFO FeHistory: [1001378.98451016  250373.29932338 4378567.75298895 2257402.61972602
 2665375.407024    402986.84526398 1458777.12578483 1831808.01690313
 1653644.88271063  902717.02275594 1654256.10715041 1400768.66098407
 1814219.66666225 1286798.14022538 1425996.34474057 5040823.76193015
 2786854.81529042 2794589.2756599  2558463.52929664  317459.04251933
  938992.37955951 1456533.30512503 1560957.42337902 2838687.63354268
 2279622.60225499 1165204.99306077 1363514.97365883 3329577.24030431
  740384.96855886  859137.27461545 1075235.87917593 1261613.84596448
 1579126.22792729 1204642.86327049  866963.54908372 1740669.42048778
 3132832.90936552 2123072.46446417 3408887.99430557 3399300.11709771
 1777453.58082159  735902.32952512  662956.10525448 1250868.54114438
 3898649.39557198 2532197.64745849 3289668.65535604  740139.32633599
 2992706.68981779 2010218.15923342 1256568.79140206 1711183.61155361
 1092563.23003763 2295227.20052907 2647565.98951989  940058.75363
  815319.04458738 1501007.04946371 2551807.84033203 1016858.1703453
 1654782.95991328 1180129.26691364  751089.47438872 1461171.35404335
 3504935.27409329 1918897.6144485  1744572.42262023  600135.7677526
  981100.11316629 1334151.65840451 4422930.2428808  1886121.91502818
 3088965.78854568 2000153.22192433 2497072.94609378 2268879.03746766
 1735621.89902381 1535524.8894299  1281828.13389225 1336702.58654965
  906814.40067383  368715.22487543 1228354.73178085 2548992.81375278
 2194806.53519338 2931746.81800688 3416045.3736616  2388865.82879089
 2650004.58674509 2518160.67914196 2021552.22595164 1517850.23023242
 2878364.13349583 3863114.71633356 1068361.62527942 4040763.20875458
 1441021.30163804 2641003.69881721 2027298.84802617 1468358.24158119
 1655226.05936371 1430113.65950194 1759204.74296553 2144259.71697895
 4584350.74558504 2093965.61973917  890921.33968302 2700591.05301535]
2025-06-24 07:04:47 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:04:47 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:04:47 ERROR Can not run the algorithm
2025-06-24 07:04:47 INFO Run function 18 complete. FEHistory len: 103, AOCC: 0.0000
2025-06-24 07:04:47 INFO FeHistory: [188407.0586865  179814.57699953 167438.81092379 148947.37105726
 179825.1127174  218263.27455316  93838.48341697 121801.63782032
 119502.1010016   75929.89947297 128850.14250001 211928.76825153
 140946.45537172 179183.9947142  133356.26881846 134818.4760499
 159095.74372098 110016.80800862 153428.51303749 161769.74350086
 229462.69393075 135887.88334816 215213.00294555 123614.58708158
 195791.7641728  150195.41660595 165059.20256723 112713.06427829
 168747.33973302 153424.4122242  140266.10507925 144111.84907539
 150849.63332558 134144.08479437 177161.85634473 120374.73166384
 163618.26660904 160320.43845945  80906.78214822 168904.54342934
 122169.53222104 111166.13461806 151261.48341352  92942.00661581
 175376.42956824 133593.57073095 148488.46907759 200298.05320769
 170816.22384894 222320.81220621 109519.65921882 215148.63589793
 124053.35843267 178042.20758197 168923.16550839 161116.00726418
 266158.95333979 100936.24894413 136794.98445662 150439.4651002
 124320.30205102 130795.70540931 144330.78777906 226716.50076594
 109623.46722122 100197.15976822 108711.94388845 197285.48894815
  98074.00329575 109448.95889351 159130.01463865 171019.41823778
 184965.22264973 112316.12502484 171416.55812155 148468.43817397
 131287.61112225 121606.23421913 181391.99544695 128157.76753
 145315.23891182 181512.28510689 253030.73904174  88937.07065153
 114514.35818372 134690.96692465 170592.55941074  81597.1834284
 170495.51496536 143187.78593929 195494.93851943 192535.62352266
 129338.97497159 168298.73019498 204096.48669042 142505.48166951
 188639.50215635 174455.73523239 169205.35063358 150988.63559616
 154799.41572617 137409.2071819  218572.52147016]
2025-06-24 07:04:47 INFO Expected Optimum FE: -5000
2025-06-24 07:04:47 INFO Unimodal AOCC mean: 0.1469
2025-06-24 07:04:47 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:04:47 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 07:04:47 INFO AOCC mean: 0.0490
2025-06-24 07:04:47 INFO Weighed AOCC mean: 0.0147
2025-06-24 07:04:47 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:04:47 ERROR Can not run the algorithm
2025-06-24 07:04:47 INFO Run function 6 complete. FEHistory len: 0, AOCC: 0.0000
2025-06-24 07:04:47 INFO FeHistory: []
2025-06-24 07:04:47 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:04:47 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:04:47 ERROR Can not run the algorithm
2025-06-24 07:04:47 INFO Run function 13 complete. FEHistory len: 0, AOCC: 0.0000
2025-06-24 07:04:47 INFO FeHistory: []
2025-06-24 07:04:47 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:04:47 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:04:47 ERROR Can not run the algorithm
2025-06-24 07:04:47 INFO Run function 18 complete. FEHistory len: 0, AOCC: 0.0000
2025-06-24 07:04:47 INFO FeHistory: []
2025-06-24 07:04:47 INFO Expected Optimum FE: -5000
2025-06-24 07:04:47 INFO Unimodal AOCC mean: 0.0000
2025-06-24 07:04:47 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:04:47 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 07:04:47 INFO AOCC mean: 0.0000
2025-06-24 07:04:47 INFO Weighed AOCC mean: 0.0000
2025-06-24 07:04:48 INFO Run function 18 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:04:48 INFO FeHistory: [157876.47336638 131395.25555538 130200.85846556 ...  31064.32676894
  23289.94490887  18387.03422305]
2025-06-24 07:04:48 INFO Expected Optimum FE: -5000
2025-06-24 07:04:48 INFO Unimodal AOCC mean: 0.1524
2025-06-24 07:04:48 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:04:48 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 07:04:48 INFO AOCC mean: 0.0508
2025-06-24 07:04:48 INFO Weighed AOCC mean: 0.0152
2025-06-24 07:04:53 INFO Run function 6 complete. FEHistory len: 100000, AOCC: 0.1612
2025-06-24 07:04:53 INFO FeHistory: [-183.35590616 -183.40133305 -183.29505733 ... -184.53961719 -184.53961719
 -184.53961719]
2025-06-24 07:04:53 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:04:53 INFO Good algorithm:
Algorithm Name: AdaptiveMultimodalOptimizer
import numpy as np
import random

class AdaptiveMultimodalOptimizer:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        self.population_size = 100 # Adjust as needed
        self.population = None
        self.fitness_values = None
        self.mutation_rate = 0.1  # Initial mutation rate
        self.mutation_decay = 0.99 # Decay factor for mutation rate

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        if self.dim > 0:
            self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
        else:
            self.population = np.array([])
        self.fitness_values = np.full(self.population_size, float('inf'))

        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        while self.eval_count < self.budget:
            self.fitness_values = objective_function(self.population)
            self.eval_count += self.population_size

            for i, fitness in enumerate(self.fitness_values):
                if fitness < self.best_fitness_overall:
                    self.best_fitness_overall = fitness
                    self.best_solution_overall = self.population[i]

            # Selection (tournament selection)
            parents = self.tournament_selection(self.fitness_values, self.population_size//2)

            # Recombination (uniform crossover)
            offspring = self.uniform_crossover(parents)

            # Mutation (adaptive)
            offspring = self.adaptive_mutation(offspring)

            #Population Diversification (adding random solutions to avoid premature convergence)
            num_diverse = int(0.1 * self.population_size) #10% diverse solutions
            diverse_solutions = np.random.uniform(self.lower_bounds, self.upper_bounds, (num_diverse, self.dim))
            self.population = np.vstack((parents, offspring, diverse_solutions))
            self.mutation_rate *= self.mutation_decay

        if self.best_solution_overall is None and self.dim > 0:
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'mutation_rate_final': self.mutation_rate
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def tournament_selection(self, fitnesses, num_parents):
        parents = []
        for _ in range(num_parents):
            competitors = random.sample(range(len(fitnesses)), 5) #Tournament size 5
            winner = min(competitors, key=lambda i: fitnesses[i])
            parents.append(self.population[winner])
        return np.array(parents)

    def uniform_crossover(self, parents):
        offspring = []
        for i in range(0, len(parents), 2):
            parent1 = parents[i]
            parent2 = parents[i+1]
            child1 = np.where(np.random.rand(self.dim) < 0.5, parent1, parent2)
            child2 = np.where(np.random.rand(self.dim) < 0.5, parent2, parent1)
            offspring.extend([child1, child2])
        return np.array(offspring)

    def adaptive_mutation(self, offspring):
        for i in range(len(offspring)):
            for j in range(self.dim):
                if np.random.rand() < self.mutation_rate:
                    offspring[i, j] += np.random.normal(0, (self.upper_bounds[j] - self.lower_bounds[j]) * 0.05) #Adaptive step size
                    offspring[i, j] = np.clip(offspring[i, j], self.lower_bounds[j], self.upper_bounds[j])
        return offspring
2025-06-24 07:04:53 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:05:00 INFO Run function 13 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:05:00 INFO FeHistory: [4.96195717e+05 3.21955263e+06 1.53433419e+06 ... 3.16532042e+03
 3.16532042e+03 3.16532042e+03]
2025-06-24 07:05:00 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:05:00 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:05:02 INFO Run function 6 complete. FEHistory len: 100000, AOCC: 0.1531
2025-06-24 07:05:02 INFO FeHistory: [-183.38704765 -183.44095451 -183.36841801 ... -183.94313003 -183.94313003
 -183.94313003]
2025-06-24 07:05:02 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:05:02 INFO Good algorithm:
Algorithm Name: AdaptiveMultimodalOptimizer
import numpy as np
import random

class AdaptiveMultimodalOptimizer:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        self.population_size = 100 # Adjust as needed
        self.population = None
        self.fitness_values = None
        self.mutation_rate = 0.5 # Initial mutation rate
        self.niche_radius = 10.0 # Initial niche radius

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
        self.fitness_values = objective_function(self.population)
        self.eval_count += self.population_size

        self.best_solution_overall, self.best_fitness_overall = self._update_best(self.population, self.fitness_values)


        while self.eval_count < self.budget:
            offspring = self._generate_offspring()
            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            self.population, self.fitness_values = self._selection(self.population, self.fitness_values, offspring, offspring_fitness)
            self.best_solution_overall, self.best_fitness_overall = self._update_best(self.population, self.fitness_values)

            # Adaptive mechanisms
            self._adapt_mutation_rate()
            self._adapt_niche_radius()


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def _generate_offspring(self):
        offspring = []
        for i in range(self.population_size):
            a, b, c = self._select_parents(3)
            mutant = self._mutate(a, b, c)
            offspring.append(mutant)
        return np.array(offspring)


    def _select_parents(self, num_parents):
        return random.sample(range(self.population_size), num_parents)

    def _mutate(self, a, b, c):
        mutant = self.population[a] + self.mutation_rate * (self.population[b] - self.population[c])
        mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)
        return mutant

    def _selection(self, population, fitnesses, offspring, offspring_fitnesses):
        combined_population = np.vstack((population, offspring))
        combined_fitnesses = np.concatenate((fitnesses, offspring_fitnesses))
        
        #Niching
        selected_population = []
        selected_fitnesses = []
        
        while len(selected_population) < self.population_size:
            best_index = np.argmin(combined_fitnesses)
            best_solution = combined_population[best_index]
            best_fitness = combined_fitnesses[best_index]

            is_unique = True
            for sol in selected_population:
                if np.linalg.norm(best_solution - sol) < self.niche_radius:
                    is_unique = False
                    break

            if is_unique:
                selected_population.append(best_solution)
                selected_fitnesses.append(best_fitness)

            combined_population = np.delete(combined_population, best_index, 0)
            combined_fitnesses = np.delete(combined_fitnesses, best_index)


        return np.array(selected_population), np.array(selected_fitnesses)

    def _update_best(self, population, fitnesses):
        best_index = np.argmin(fitnesses)
        best_solution = population[best_index]
        best_fitness = fitnesses[best_index]
        if best_fitness < self.best_fitness_overall:
            self.best_fitness_overall = best_fitness
            self.best_solution_overall = best_solution
        return best_solution, best_fitness


    def _adapt_mutation_rate(self):
        # Simple adaptation: reduce mutation rate if many evaluations without improvement
        if self.eval_count > 1000 and self.best_fitness_overall == float('inf'):
            self.mutation_rate *= 0.9 # reduce


    def _adapt_niche_radius(self):
        # Adjust niche radius based on exploration/exploitation balance
        # (More sophisticated adaptation could be implemented here)
        if self.eval_count > self.budget/2:
            self.niche_radius *= 0.8 # Reduce radius in later stages to focus exploitation
2025-06-24 07:05:02 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:05:12 INFO Run function 18 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:05:12 INFO FeHistory: [172455.99910247 115715.13425825 173042.10482808 ... 155412.63700056
 214528.1134703  173194.61973081]
2025-06-24 07:05:12 INFO Expected Optimum FE: -5000
2025-06-24 07:05:12 INFO Unimodal AOCC mean: 0.1474
2025-06-24 07:05:12 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:05:12 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 07:05:12 INFO AOCC mean: 0.0491
2025-06-24 07:05:12 INFO Weighed AOCC mean: 0.0147
2025-06-24 07:05:18 INFO Run function 13 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:05:18 INFO FeHistory: [ 975737.80566422 1988679.37456826 1441427.71061685 ...  399819.16668975
 1397520.36593637  867962.1145329 ]
2025-06-24 07:05:18 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:05:18 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:05:25 INFO Run function 18 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:05:25 INFO FeHistory: [165615.98819948 121692.83409768 189510.64485793 ...   6631.15239635
   6631.15239635   6631.15239635]
2025-06-24 07:05:25 INFO Expected Optimum FE: -5000
2025-06-24 07:05:25 INFO Unimodal AOCC mean: 0.1612
2025-06-24 07:05:25 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:05:25 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 07:05:25 INFO AOCC mean: 0.0537
2025-06-24 07:05:25 INFO Weighed AOCC mean: 0.0161
2025-06-24 07:05:51 INFO Run function 18 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:05:51 INFO FeHistory: [205213.48373462 138352.87850685 127719.39105183 ...  -2838.61958089
  -2838.61891013  -2838.61673002]
2025-06-24 07:05:51 INFO Expected Optimum FE: -5000
2025-06-24 07:05:51 INFO Unimodal AOCC mean: 0.1531
2025-06-24 07:05:51 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:05:51 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 07:05:51 INFO AOCC mean: 0.0510
2025-06-24 07:05:51 INFO Weighed AOCC mean: 0.0153
2025-06-24 07:07:37 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:07:37 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:07:37 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:07:37 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:07:37 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:07:46 INFO Run function 6 complete. FEHistory len: 100000, AOCC: 0.1741
2025-06-24 07:07:46 INFO FeHistory: [-183.36990138 -183.29819552 -183.32659852 ... -185.78275612 -185.79133551
 -185.79791927]
2025-06-24 07:07:46 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:07:46 INFO Good algorithm:
Algorithm Name: ArchiveGuidedAdaptiveDEwithClustering
import numpy as np
import random

# Name: ArchiveGuidedAdaptiveDEwithClustering
# Description: Hybrid DE with archive, adaptive scaling, and clustering to escape local optima in multimodal landscapes.
# Code:
class ArchiveGuidedAdaptiveDEwithClustering:
    """
    A hybrid differential evolution algorithm that uses an archive to store good solutions, 
    adapts the scaling factor, and incorporates clustering to improve exploration.
    """
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.population_size = 10 * self.dim
        self.archive_size = 200  # Increased archive size
        self.archive = []
        self.population = None
        self.F_scale = 0.5
        self.cluster_threshold = 0.1 #parameter for clustering

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        fitness = objective_function(self.population)
        self.eval_count += self.population_size

        self.best_solution_overall = self.population[np.argmin(fitness)]
        self.best_fitness_overall = np.min(fitness)

        while self.eval_count < self.budget:
            offspring = self.generate_offspring(self.population, fitness)
            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            self.update_archive(offspring, offspring_fitness)
            self.cluster_and_diversify() #new diversification strategy

            combined_population = np.concatenate((self.population, offspring))
            combined_fitness = np.concatenate((fitness, offspring_fitness))
            indices = np.argsort(combined_fitness)
            self.population = combined_population[indices[:self.population_size]]
            fitness = combined_fitness[indices[:self.population_size]]

            self.best_solution_overall = self.population[np.argmin(fitness)]
            self.best_fitness_overall = np.min(fitness)

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'archive_size': len(self.archive)
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def generate_offspring(self, population, fitness):
        offspring = np.zeros((self.population_size, self.dim))
        self.F_scale = 0.5 + 0.3 * np.random.rand()

        for i in range(self.population_size):
            if self.archive:
                pbest_index = np.random.choice(len(self.archive))
                pbest = self.archive[pbest_index][0]
            else:
                pbest = population[np.argmin(fitness)]

            a, b, c = random.sample(range(self.population_size), 3)
            while a == i or b == i or c == i:
                a, b, c = random.sample(range(self.population_size), 3)

            offspring[i] = population[i] + self.F_scale * (pbest - population[i] + population[a] - population[b])
            offspring[i] = np.clip(offspring[i], self.lower_bounds, self.upper_bounds)

        return offspring

    def update_archive(self, offspring, offspring_fitness):
        for i in range(len(offspring)):
            if len(self.archive) < self.archive_size:
                self.archive.append((offspring[i], offspring_fitness[i]))
            else:
                worst_index = np.argmax([f for _, f in self.archive])
                if offspring_fitness[i] < self.archive[worst_index][1]:
                    self.archive[worst_index] = (offspring[i], offspring_fitness[i])

    def cluster_and_diversify(self):
        if len(self.archive) > self.population_size:
            # Simple clustering based on Euclidean distance
            archive_points = np.array([x for x, _ in self.archive])
            distances = np.linalg.norm(archive_points[:, np.newaxis, :] - archive_points[np.newaxis, :, :], axis=2)
            
            #Identify clusters by thresholding
            clusters = []
            assigned = [False] * len(archive_points)
            for i in range(len(archive_points)):
                if not assigned[i]:
                    cluster = [i]
                    assigned[i] = True
                    for j in range(i + 1, len(archive_points)):
                        if not assigned[j] and distances[i, j] < self.cluster_threshold:
                            cluster.append(j)
                            assigned[j] = True
                    clusters.append(cluster)

            #Add diversity: Select one point from each cluster and replace with random
            selected_indices = [random.choice(cluster) for cluster in clusters]
            for index in selected_indices:
                self.archive[index] = (np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim), float('inf'))

2025-06-24 07:07:46 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:07:46 INFO Run function 6 complete. FEHistory len: 100000, AOCC: 0.1756
2025-06-24 07:07:46 INFO FeHistory: [-183.46760637 -183.27732763 -183.344659   ... -185.88332011 -185.87133938
 -185.88829633]
2025-06-24 07:07:46 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:07:46 INFO Good algorithm:
Algorithm Name: ArchiveGuidedAdaptiveDE
import numpy as np
import random

# Name: ArchiveGuidedAdaptiveDE
# Description: Hybrid DE algorithm using an archive and adaptive scaling factor for multimodal optimization.

class ArchiveGuidedAdaptiveDE:
    """
    Combines Differential Evolution with an archive and adaptive scaling factor to enhance exploration and exploitation in multimodal landscapes.
    """
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.population_size = 10 * self.dim  # common heuristic
        self.archive_size = 200  # Increased archive size for better diversity
        self.archive = []
        self.population = None
        self.F_scale = 0.5  # initial scaling factor


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        fitness = objective_function(self.population)
        self.eval_count += self.population_size

        self.best_solution_overall = self.population[np.argmin(fitness)]
        self.best_fitness_overall = np.min(fitness)

        while self.eval_count < self.budget:
            offspring = self.generate_offspring(self.population, fitness)
            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            # Update archive with diversity check
            self.update_archive(offspring, offspring_fitness)

            # Select best solutions for next generation
            combined_population = np.concatenate((self.population, offspring))
            combined_fitness = np.concatenate((fitness, offspring_fitness))
            indices = np.argsort(combined_fitness)
            self.population = combined_population[indices[:self.population_size]]
            fitness = combined_fitness[indices[:self.population_size]]

            # Update best solution
            best_index = np.argmin(fitness)
            if fitness[best_index] < self.best_fitness_overall:
                self.best_solution_overall = self.population[best_index]
                self.best_fitness_overall = fitness[best_index]

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'archive_size': len(self.archive)
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def generate_offspring(self, population, fitness):
        offspring = np.zeros((self.population_size, self.dim))
        #Adaptive scaling factor with noise
        self.F_scale = 0.5 + 0.3 * np.random.rand() #scale factor with slight variation

        for i in range(self.population_size):
            # Select pbest from archive (if available)
            if self.archive:
                pbest_index = np.random.choice(len(self.archive))
                pbest = self.archive[pbest_index][0]
            else:
                pbest = population[np.argmin(fitness)]

            a, b, c = random.sample(range(self.population_size), 3)
            while a == i or b == i or c == i:
                a, b, c = random.sample(range(self.population_size), 3)

            offspring[i] = population[i] + self.F_scale * (pbest - population[i] + population[a] - population[b])
            offspring[i] = np.clip(offspring[i], self.lower_bounds, self.upper_bounds) #Boundary handling

        return offspring

    def update_archive(self, offspring, offspring_fitness):
        for i in range(len(offspring)):
            if len(self.archive) < self.archive_size:
                self.archive.append((offspring[i], offspring_fitness[i]))
            else:
                #Prioritize diversity and fitness in archive using a simple distance metric
                worst_index = np.argmax([f for _, f in self.archive])
                if offspring_fitness[i] < self.archive[worst_index][1] : # or self.diversity_check(offspring[i]):
                    self.archive[worst_index] = (offspring[i], offspring_fitness[i])

    # def diversity_check(self, solution): #Optional diversity check (can be improved with more sophisticated metrics).  Currently unused.
    #     if not self.archive:
    #         return True
    #     distances = np.linalg.norm(np.array(solution) - np.array([sol for sol,_ in self.archive]), axis=1)
    #     return np.min(distances) > 10  #Adjust threshold as needed

2025-06-24 07:07:46 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:07:47 INFO Run function 6 complete. FEHistory len: 100000, AOCC: 0.1513
2025-06-24 07:07:47 INFO FeHistory: [-183.25931767 -183.38686457 -183.38570731 ... -183.65171581 -183.73693627
 -183.63641965]
2025-06-24 07:07:47 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:07:47 INFO Good algorithm:
Algorithm Name: ArchiveGuidedAdaptiveDE
import numpy as np
import random

class ArchiveGuidedAdaptiveDE:
    """
    Combines Differential Evolution with an archive to enhance exploration in multimodal landscapes.  Adaptive mutation adjusts step size.
    """
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.archive_size = 100  # Size of the solution archive
        self.archive = []
        self.population_size = 100
        self.F = 0.8  # DE scaling factor
        self.CR = 0.9  # DE crossover rate
        self.mutation_rate = 0.2 #Initial mutation rate
        self.mutation_decay = 0.99 # Decay for mutation rate


        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        fitness = objective_function(population)
        self.eval_count += self.population_size

        self.best_solution_overall = population[np.argmin(fitness)]
        self.best_fitness_overall = np.min(fitness)

        while self.eval_count < self.budget:
            # Differential Evolution
            offspring = np.zeros_like(population)
            for i in range(self.population_size):
                a, b, c = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)
                mutant = population[a] + self.F * (population[b] - population[c])
                mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)
                trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])
                trial_fitness = objective_function(trial.reshape(1, -1))[0]
                self.eval_count += 1
                if trial_fitness < fitness[i]:
                    offspring[i] = trial
                    fitness[i] = trial_fitness
                else:
                    offspring[i] = population[i]

            # Archive Management
            self.update_archive(offspring, fitness)

            #Adaptive Mutation
            offspring = self.adaptive_mutation(offspring)

            population = offspring
            
            best_index = np.argmin(fitness)
            if fitness[best_index] < self.best_fitness_overall:
                self.best_fitness_overall = fitness[best_index]
                self.best_solution_overall = population[best_index]
            self.mutation_rate *= self.mutation_decay


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'archive_size_final':len(self.archive)
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def update_archive(self, population, fitness):
        for i in range(len(population)):
            is_better = True
            for j in range(len(self.archive)):
                if fitness[i] > self.archive[j][1]:
                    is_better = False
                    break

            if is_better and len(self.archive) < self.archive_size:
                self.archive.append((population[i], fitness[i]))
            elif is_better and len(self.archive) >= self.archive_size:
                worst_index = np.argmax([f for _, f in self.archive])
                if fitness[i] < self.archive[worst_index][1]:
                    self.archive[worst_index] = (population[i], fitness[i])

    def adaptive_mutation(self, offspring):
        for i in range(len(offspring)):
            for j in range(self.dim):
                if np.random.rand() < self.mutation_rate:
                    offspring[i, j] += np.random.normal(0, (self.upper_bounds[j] - self.lower_bounds[j]) * 0.05)
                    offspring[i, j] = np.clip(offspring[i, j], self.lower_bounds[j], self.upper_bounds[j])
        return offspring

2025-06-24 07:07:47 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:07:55 INFO Run function 13 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:07:55 INFO FeHistory: [3734194.92662953 3260811.84389368 1842731.18632786 ...  929695.65203184
  280153.06514471 1420978.74117715]
2025-06-24 07:07:55 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:07:55 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:07:56 INFO Run function 13 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:07:56 INFO FeHistory: [1316236.48118635  977904.03741889 1567879.54319469 ...  738469.09875744
  850906.3293143   724460.37011904]
2025-06-24 07:07:56 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:07:56 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:07:58 INFO Run function 13 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:07:58 INFO FeHistory: [ 589031.2817215  1998359.32207801 3849280.36652164 ... 1318514.86185945
 1640246.54502033 1970243.80243556]
2025-06-24 07:07:58 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:07:58 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:08:23 INFO Run function 18 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:08:23 INFO FeHistory: [151086.50731469  97322.05716116 163754.40534818 ...  -4470.39599672
  -4470.39571252  -4470.39663332]
2025-06-24 07:08:23 INFO Expected Optimum FE: -5000
2025-06-24 07:08:23 INFO Unimodal AOCC mean: 0.1741
2025-06-24 07:08:23 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:08:23 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 07:08:23 INFO AOCC mean: 0.0580
2025-06-24 07:08:23 INFO Weighed AOCC mean: 0.0174
2025-06-24 07:08:23 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:08:23 ERROR Can not run the algorithm
2025-06-24 07:08:23 INFO Run function 6 complete. FEHistory len: 600, AOCC: 0.1476
2025-06-24 07:08:23 INFO FeHistory: [-183.35334096 -183.27426447 -183.38111091 -183.33864164 -183.39194469
 -183.28501826 -183.35269464 -183.33415803 -183.31577569 -183.33446224
 -183.38635883 -183.32786461 -183.42220257 -183.35115403 -183.35310535
 -183.26631656 -183.36295714 -183.38352437 -183.29210477 -183.27305005
 -183.28491537 -183.35153938 -183.35914864 -183.33853227 -183.30414852
 -183.35832268 -183.32074063 -183.28265861 -183.31857053 -183.4189331
 -183.44226427 -183.34949126 -183.3316033  -183.36511207 -183.31710795
 -183.3920068  -183.46893501 -183.28913303 -183.38932495 -183.36736915
 -183.42876681 -183.46169559 -183.37416222 -183.31193947 -183.31335794
 -183.37750788 -183.38495304 -183.32389583 -183.41400514 -183.31810261
 -183.26643391 -183.34364122 -183.32318837 -183.41956797 -183.41292844
 -183.32318403 -183.36936231 -183.34435336 -183.35710556 -183.30021197
 -183.38166595 -183.41501812 -183.30393885 -183.31032493 -183.36984355
 -183.37459596 -183.30582191 -183.34188376 -183.32179818 -183.3029681
 -183.30469021 -183.29409395 -183.37885625 -183.40256549 -183.31311586
 -183.37009384 -183.35898272 -183.40938593 -183.33584453 -183.36809966
 -183.36575838 -183.45740231 -183.36461041 -183.40618787 -183.333198
 -183.33404842 -183.35160897 -183.40766583 -183.28490254 -183.34672603
 -183.33314701 -183.35288516 -183.35730991 -183.32118737 -183.37347815
 -183.39495637 -183.33794615 -183.35857064 -183.36769089 -183.3342718
 -183.3923916  -183.38816113 -183.30026961 -183.42627719 -183.35657259
 -183.32940699 -183.37060941 -183.31365102 -183.38279691 -183.38621953
 -183.34707971 -183.39979473 -183.31910634 -183.44506009 -183.35426069
 -183.32659664 -183.35514602 -183.40277338 -183.35913685 -183.34157377
 -183.39511506 -183.30832162 -183.27048302 -183.34639933 -183.26988416
 -183.33301033 -183.37882814 -183.41241368 -183.38545862 -183.41214061
 -183.3830106  -183.28578485 -183.32087514 -183.36765535 -183.35901344
 -183.35381466 -183.34814353 -183.27106905 -183.46237206 -183.37222534
 -183.34561352 -183.31699381 -183.38064229 -183.3309455  -183.31845741
 -183.34378246 -183.30958581 -183.41831976 -183.27984506 -183.45119622
 -183.35340553 -183.34689859 -183.3729495  -183.2972908  -183.32033519
 -183.3325982  -183.36775781 -183.33205487 -183.32596509 -183.43237379
 -183.38719615 -183.3090973  -183.48214179 -183.30770054 -183.28109832
 -183.37501439 -183.36092212 -183.37748678 -183.3726145  -183.42309888
 -183.33108595 -183.43666859 -183.34603456 -183.32764212 -183.40384212
 -183.33709383 -183.35533455 -183.28253636 -183.37377936 -183.36869307
 -183.36082676 -183.3514032  -183.36911964 -183.24762269 -183.37656908
 -183.37642026 -183.30774226 -183.35524513 -183.39690024 -183.34915366
 -183.35615209 -183.46178354 -183.31516541 -183.34045877 -183.30339008
 -183.42361834 -183.26248138 -183.38342605 -183.33473642 -183.34747096
 -183.33809522 -183.33268948 -183.30706206 -183.30047106 -183.33786718
 -183.40093182 -183.38510968 -183.37305724 -183.3419073  -183.41668155
 -183.35158397 -183.31284249 -183.37935927 -183.27256187 -183.28667225
 -183.24943297 -183.39778213 -183.31911417 -183.35203096 -183.41594303
 -183.39244181 -183.35614962 -183.26418644 -183.35921542 -183.2729998
 -183.33123791 -183.33259886 -183.31978669 -183.30851318 -183.37253082
 -183.3397     -183.36992315 -183.29302303 -183.40897091 -183.33108898
 -183.40359354 -183.29185884 -183.42000191 -183.31711617 -183.38979231
 -183.38035508 -183.31802483 -183.37672599 -183.35878931 -183.31969693
 -183.34870901 -183.34131048 -183.37510916 -183.33052274 -183.38481818
 -183.3693636  -183.41886981 -183.36804059 -183.30303958 -183.35790985
 -183.4104047  -183.37325809 -183.35847466 -183.35128277 -183.29298865
 -183.2963197  -183.35855699 -183.37169382 -183.35402821 -183.35842965
 -183.36880462 -183.39433281 -183.28923346 -183.45012119 -183.33765121
 -183.33178696 -183.35627957 -183.32575284 -183.31848022 -183.30814371
 -183.35929832 -183.3371443  -183.34197868 -183.33151749 -183.36720343
 -183.3633226  -183.33153932 -183.31521255 -183.30009451 -183.35888517
 -183.29776713 -183.29672827 -183.36020569 -183.34342915 -183.47779496
 -183.38694104 -183.31466502 -183.41784158 -183.35451551 -183.31804781
 -183.29804531 -183.28405711 -183.36875466 -183.33150334 -183.26651276
 -183.44061366 -183.3909206  -183.38418042 -183.28350794 -183.43318229
 -183.38365429 -183.41394799 -183.44625049 -183.32997836 -183.32103842
 -183.3256411  -183.37072335 -183.37282538 -183.35860805 -183.354545
 -183.38145937 -183.40382643 -183.39124299 -183.29528031 -183.34754718
 -183.35492554 -183.37481006 -183.31871432 -183.42957998 -183.40122266
 -183.48322789 -183.30338211 -183.34710501 -183.37788791 -183.39332288
 -183.46453408 -183.36412977 -183.36949038 -183.42710123 -183.36137513
 -183.30458019 -183.44134283 -183.42735734 -183.31006892 -183.33220274
 -183.37283973 -183.37912267 -183.30700539 -183.33957635 -183.39767653
 -183.46500943 -183.40262005 -183.40052565 -183.34897294 -183.3737424
 -183.35603707 -183.4512138  -183.37762785 -183.37741778 -183.44375566
 -183.40204945 -183.44939364 -183.40882444 -183.39129322 -183.33429091
 -183.40174183 -183.42091204 -183.41542714 -183.39046375 -183.39910405
 -183.36027626 -183.28640404 -183.33200391 -183.37272107 -183.3600671
 -183.39788745 -183.33546239 -183.379445   -183.43644066 -183.32895305
 -183.38041812 -183.35375355 -183.34676162 -183.36384293 -183.39957166
 -183.44320213 -183.34011285 -183.36783885 -183.38133504 -183.38329823
 -183.40214785 -183.35818046 -183.35777796 -183.33144886 -183.3875863
 -183.34688831 -183.32015814 -183.38292674 -183.52365832 -183.38566787
 -183.33795263 -183.4409063  -183.46997624 -183.39277219 -183.35221617
 -183.38844246 -183.4597421  -183.28529295 -183.40922526 -183.44563622
 -183.37072022 -183.37231881 -183.44001729 -183.37506135 -183.35259949
 -183.36568989 -183.36335188 -183.38085872 -183.42123584 -183.37384073
 -183.35117845 -183.50312759 -183.3961868  -183.43465558 -183.35358011
 -183.42165883 -183.30713652 -183.35579022 -183.34284797 -183.45874574
 -183.33910404 -183.37116194 -183.35243312 -183.45093704 -183.43629725
 -183.40582652 -183.37550755 -183.43344384 -183.39532744 -183.37541856
 -183.31705657 -183.3573602  -183.39629638 -183.38182398 -183.44686471
 -183.36196697 -183.3601163  -183.40171026 -183.34774853 -183.39647022
 -183.35524001 -183.34977142 -183.35740906 -183.36378696 -183.4465315
 -183.32195961 -183.40345099 -183.34635897 -183.38647989 -183.33307695
 -183.36415071 -183.39322509 -183.40383399 -183.44792407 -183.30627837
 -183.40800246 -183.36906604 -183.32137069 -183.37495194 -183.39533859
 -183.42700257 -183.35335948 -183.36179345 -183.42956918 -183.4099497
 -183.30389999 -183.39514565 -183.3470007  -183.43894963 -183.33092389
 -183.47394551 -183.41874682 -183.45396574 -183.4406706  -183.40795459
 -183.44885883 -183.33983015 -183.41298279 -183.36066052 -183.38227945
 -183.45071038 -183.44307162 -183.4009087  -183.34820881 -183.33095335
 -183.37056295 -183.35190015 -183.34523835 -183.39809014 -183.43717007
 -183.42046633 -183.33493335 -183.36822115 -183.39511272 -183.34466479
 -183.39133329 -183.37789181 -183.4140111  -183.3928217  -183.38320204
 -183.38042539 -183.34868849 -183.35491915 -183.41457071 -183.39070642
 -183.42518504 -183.39320675 -183.3555968  -183.38613818 -183.38002131
 -183.49520952 -183.39440317 -183.37951392 -183.40820299 -183.38091841
 -183.42880486 -183.34493955 -183.34136779 -183.309629   -183.38923902
 -183.40942493 -183.33188344 -183.35232506 -183.37377385 -183.35331297
 -183.43555924 -183.39949119 -183.34322071 -183.41035698 -183.37087555
 -183.31450504 -183.36194925 -183.34262193 -183.30086161 -183.37588732
 -183.42754341 -183.35469087 -183.36266978 -183.43286607 -183.33051466
 -183.46397156 -183.34829051 -183.3547673  -183.33401334 -183.43472517
 -183.35399002 -183.36303983 -183.38510466 -183.33980413 -183.47205661
 -183.39064853 -183.4067237  -183.30817438 -183.34882541 -183.43942497
 -183.33727219 -183.39700017 -183.37805469 -183.38960865 -183.39766089
 -183.40689685 -183.42433661 -183.40346672 -183.39264407 -183.34921343
 -183.44908725 -183.36526652 -183.44162805 -183.40420711 -183.39954685
 -183.41417086 -183.38674593 -183.44735114 -183.36866314 -183.41536556
 -183.37599648 -183.45846266 -183.44648256 -183.40238292 -183.36765836
 -183.46380628 -183.34649571 -183.35389621 -183.32683579 -183.41961087
 -183.45717825 -183.39576021 -183.3857151  -183.41207331 -183.39645488
 -183.32678224 -183.51041665 -183.33913829 -183.33202126 -183.43420968]
2025-06-24 07:08:23 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:08:23 INFO Good algorithm:
Algorithm Name: ArchiveGuidedAdaptiveDE
import numpy as np
import random

# Name: ArchiveGuidedAdaptiveDE
# Description: Hybrid DE algorithm combining an archive for exploration and adaptive scaling factor for exploitation.
class ArchiveGuidedAdaptiveDE:
    """
    Combines Differential Evolution with an archive to enhance exploration and an adaptive scaling factor for exploitation in multimodal optimization.
    """
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.population_size = 10 * self.dim  # common heuristic
        self.archive_size = 200 # Increased archive size for better exploration
        self.archive = []
        self.population = None
        self.F_scale = 0.5  # initial scaling factor


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        fitness = objective_function(self.population)
        self.eval_count += self.population_size

        self.best_solution_overall = self.population[np.argmin(fitness)]
        self.best_fitness_overall = np.min(fitness)

        while self.eval_count < self.budget:
            offspring = self.generate_offspring(self.population, fitness)
            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            # Update archive (improved diversity handling)
            self.update_archive(offspring, offspring_fitness)

            # Select best solutions for next generation (elitism)
            combined_population = np.concatenate((self.population, offspring))
            combined_fitness = np.concatenate((fitness, offspring_fitness))
            indices = np.argsort(combined_fitness)
            self.population = combined_population[indices[:self.population_size]]
            fitness = combined_fitness[indices[:self.population_size]]

            # Update best solution
            if np.min(fitness) < self.best_fitness_overall:
                self.best_solution_overall = self.population[np.argmin(fitness)]
                self.best_fitness_overall = np.min(fitness)


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'archive_size': len(self.archive)
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def generate_offspring(self, population, fitness):
        offspring = np.zeros((self.population_size, self.dim))
        #Adaptive scaling factor with noise for enhanced exploration
        self.F_scale = 0.5 + 0.3 * np.random.rand()  # scale factor with slight variation

        for i in range(self.population_size):
            # Select pbest from archive (if available)
            if self.archive:
                pbest_index = np.random.choice(len(self.archive))
                pbest = self.archive[pbest_index][0]
            else:
                pbest = population[np.argmin(fitness)]

            a, b, c = random.sample(range(self.population_size), 3)
            while a == i or b == i or c == i:
                a, b, c = random.sample(range(self.population_size), 3)

            offspring[i] = population[i] + self.F_scale * (pbest - population[i] + population[a] - population[b])
            offspring[i] = np.clip(offspring[i], self.lower_bounds, self.upper_bounds)  # Boundary handling

        return offspring

    def update_archive(self, offspring, offspring_fitness):
        for i in range(len(offspring)):
            if len(self.archive) < self.archive_size:
                self.archive.append((offspring[i], offspring_fitness[i]))
            else:
                # Prioritize diversity and quality in archive using a distance metric and fitness
                distances = np.linalg.norm(self.archive[:, 0] - offspring[i], axis=1)
                closest_index = np.argmin(distances)
                if offspring_fitness[i] < self.archive[closest_index][1]: #replace if better
                    self.archive[closest_index] = (offspring[i], offspring_fitness[i])
                elif np.mean(distances) > 20: #add if diverse enough
                    worst_index = np.argmax([f for _, f in self.archive])
                    self.archive[worst_index] = (offspring[i], offspring_fitness[i])


2025-06-24 07:08:23 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:08:23 ERROR Can not run the algorithm
2025-06-24 07:08:23 INFO Run function 18 complete. FEHistory len: 100000, AOCC: 0.1003
2025-06-24 07:08:23 INFO FeHistory: [145210.53852508 143152.76847533 190197.88550146 ...  -4999.93222498
  -4999.932841    -4999.84963589]
2025-06-24 07:08:23 INFO Expected Optimum FE: -5000
2025-06-24 07:08:23 INFO Good algorithm:
Algorithm Name: ArchiveGuidedAdaptiveDE
import numpy as np
import random

# Name: ArchiveGuidedAdaptiveDE
# Description: Hybrid DE algorithm using an archive and adaptive scaling factor for multimodal optimization.

class ArchiveGuidedAdaptiveDE:
    """
    Combines Differential Evolution with an archive and adaptive scaling factor to enhance exploration and exploitation in multimodal landscapes.
    """
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.population_size = 10 * self.dim  # common heuristic
        self.archive_size = 200  # Increased archive size for better diversity
        self.archive = []
        self.population = None
        self.F_scale = 0.5  # initial scaling factor


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        fitness = objective_function(self.population)
        self.eval_count += self.population_size

        self.best_solution_overall = self.population[np.argmin(fitness)]
        self.best_fitness_overall = np.min(fitness)

        while self.eval_count < self.budget:
            offspring = self.generate_offspring(self.population, fitness)
            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            # Update archive with diversity check
            self.update_archive(offspring, offspring_fitness)

            # Select best solutions for next generation
            combined_population = np.concatenate((self.population, offspring))
            combined_fitness = np.concatenate((fitness, offspring_fitness))
            indices = np.argsort(combined_fitness)
            self.population = combined_population[indices[:self.population_size]]
            fitness = combined_fitness[indices[:self.population_size]]

            # Update best solution
            best_index = np.argmin(fitness)
            if fitness[best_index] < self.best_fitness_overall:
                self.best_solution_overall = self.population[best_index]
                self.best_fitness_overall = fitness[best_index]

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'archive_size': len(self.archive)
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def generate_offspring(self, population, fitness):
        offspring = np.zeros((self.population_size, self.dim))
        #Adaptive scaling factor with noise
        self.F_scale = 0.5 + 0.3 * np.random.rand() #scale factor with slight variation

        for i in range(self.population_size):
            # Select pbest from archive (if available)
            if self.archive:
                pbest_index = np.random.choice(len(self.archive))
                pbest = self.archive[pbest_index][0]
            else:
                pbest = population[np.argmin(fitness)]

            a, b, c = random.sample(range(self.population_size), 3)
            while a == i or b == i or c == i:
                a, b, c = random.sample(range(self.population_size), 3)

            offspring[i] = population[i] + self.F_scale * (pbest - population[i] + population[a] - population[b])
            offspring[i] = np.clip(offspring[i], self.lower_bounds, self.upper_bounds) #Boundary handling

        return offspring

    def update_archive(self, offspring, offspring_fitness):
        for i in range(len(offspring)):
            if len(self.archive) < self.archive_size:
                self.archive.append((offspring[i], offspring_fitness[i]))
            else:
                #Prioritize diversity and fitness in archive using a simple distance metric
                worst_index = np.argmax([f for _, f in self.archive])
                if offspring_fitness[i] < self.archive[worst_index][1] : # or self.diversity_check(offspring[i]):
                    self.archive[worst_index] = (offspring[i], offspring_fitness[i])

    # def diversity_check(self, solution): #Optional diversity check (can be improved with more sophisticated metrics).  Currently unused.
    #     if not self.archive:
    #         return True
    #     distances = np.linalg.norm(np.array(solution) - np.array([sol for sol,_ in self.archive]), axis=1)
    #     return np.min(distances) > 10  #Adjust threshold as needed

2025-06-24 07:08:23 INFO Unimodal AOCC mean: 0.1756
2025-06-24 07:08:23 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:08:23 INFO Multimodal (multiple components) AOCC mean: 0.1003
2025-06-24 07:08:23 INFO AOCC mean: 0.0920
2025-06-24 07:08:23 INFO Weighed AOCC mean: 0.0878
2025-06-24 07:08:23 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:08:23 INFO Run function 13 complete. FEHistory len: 600, AOCC: 0.0000
2025-06-24 07:08:23 INFO FeHistory: [2502217.9902239  1591325.9577641  2919673.76757249 1887526.05070669
 1925392.39024454 1288433.2208479   497303.19201581 1034947.26243858
 3988128.04639168 2454767.65121243 2079711.65245213 1016616.73396425
 1333718.50626076  601300.67397826 1306947.97721888 2049282.45760301
 5176291.68722808 2352307.46405039 1771354.27173719  722799.90106396
 2712831.18549822  616473.49802724  975783.41036879 2406080.80934111
 1090675.4102558  2175581.26100217 2680914.33663845 2200488.06535762
 2440726.37424435  895604.78050267 1221679.71532715 1552701.13338426
  807124.32131011 2072386.45094206 3308841.63550389 1808262.56404441
 3065398.14135129 1673798.27574016 1560049.69264019 1643502.75515378
 1167465.31942008 1039368.10006589 1553047.42861869 2978521.23029164
  717671.64186544 3324749.20741122 2678866.61303089 2601980.361881
 1820489.75162517  968460.59226203  683674.62796152 1519901.40649208
 2495923.13590034  829716.27500635 1036581.85020884 1049578.37832217
 1056475.19523172 4051294.07529232  939760.51629739 3298709.61774045
 1423662.85419111 1855928.34901438 1091503.40126533 1400694.39226897
  439174.36891552 1309462.02708325 2009790.54393114  635480.63261413
 2283945.43767206  921195.23404973  609613.92409565 1905381.08870932
 3271082.31114499 1123882.11535035 1996831.71925732 2077023.12757132
 2337364.36155371 1191185.48317262 1006261.50023293 1876879.02793601
 1674066.90954033 2491355.98860357 2261841.24035423  898165.24763911
 2100483.98509777 1509867.08464877  752441.52641485 1961136.85095894
 2897817.89332194 1412194.4770338  3256500.64555385 2157063.29763174
 2712277.06580765 2617904.62483669 1499657.36032462 2280274.23768944
 1942466.7528383  2438434.07668474  417576.50435742 1153383.66224022
  379180.09646035 1400604.97775494 2078160.78467994  998831.4455118
 2345856.51900166 2943162.19881119 2322357.69384044 1614345.04754096
 1287311.79055532  767684.18533453  998303.32678193 3222615.12986775
  959772.57998395 1734566.84163572 1853723.00139429 2307955.35565995
 1627517.83886372 2908625.27942484 2041195.23575681  238857.07673837
 1350387.73802729 1958361.43575524 2916365.1214687  1675572.89077436
 2985472.31489907 1849133.21438752  992858.67919724 1130186.72835349
  753103.50379979 2713609.08011231 2787129.61314826 1470458.96660734
  283464.9875404  2869738.25168377  995252.88986246  573872.41303802
 3016006.85645881  723032.98817742 2574493.45395182 3263028.34061971
 2332111.91131825 4440758.90244215 1616961.36442977 1678257.36940919
 2335992.42482334 1509701.31299086 1605423.3106879  1467237.83082981
 2093492.24927558 1270938.95752031 1602973.42335725 2868515.52511608
  717913.99486895  766668.60313966 2399642.78558088 1281783.76195687
 1130831.175049   1738201.93747418 1167411.70709128 1651439.27311582
 1615825.90256538 1918608.15848195 4487451.39997714 1951083.42749621
 2356084.40570944 1742801.94173064 2348198.37054079 1442589.10415523
 3834424.19707054  976636.19905607 2862598.66404893 2088560.28202292
 2618179.05398688 2069238.64187012 1475294.62001292 1383450.9170959
 1972832.26003862 1296769.60398011 2188269.40037578  851006.13395893
 2132327.06591146 3789116.98160663 1545956.35920111 2472141.78782202
 2748913.11007068 1788667.50089893  949276.82753948 1998678.25542988
 4112054.05285138 4578076.3538073  1982998.56371728 1920230.74781314
  669542.7513322  2232812.04114607  423270.09397839  940513.06995715
 3720527.15852874 1908201.44030455  828614.22918023 1306000.44052168
  869249.86315564 2546026.42139134 2507966.04870284 3689184.29254205
 1136241.52899464 2815341.21608665  855825.91023248 3242048.4561142
 1005850.70937256 2230252.2520865  4199771.68864483 1735216.90099826
 1640894.66876589 1273622.58243033  879237.90928716 1941556.49053673
 1415842.47262372 1696081.59812576  504168.41245476 1506513.84945461
  682784.26370065 1469117.66137581 1335099.47772664 1101358.56377416
 1107500.55390793 1700059.62567546 3434841.92471979 1790809.73995978
 2677837.83505806  944001.89512132  482885.93860153  695262.17469773
 3120021.38273351  801846.43443003  838892.29742995 1339221.84864555
  976656.88839611  694545.93754427 2226526.73447251 1318295.03229761
  339173.60080274 1399581.89626854  506371.62830418  984292.69696202
 1952095.27012328 1800045.76954417 1249480.63567593 1452148.24135062
 1097050.33284135  511656.51276444 2178297.03664656 1476139.62025503
 2567664.83043797 1985537.86054544 2900523.85033598 1537723.42299973
 3748270.67900692 1354916.79976789  436984.72124922 2991093.52466618
 4318317.84746817 2478428.69233393 1053375.78305895 1300950.40134096
 2022456.94971977 2870238.67145444 2830508.64768379 1134921.29994933
 2497715.68957755 1674940.67359657 1985664.70103914 1529906.68383907
 3347316.63422402 3461915.74314048 2018555.34316073 2024557.42216364
 1469737.97232366 1615994.69118308 1579229.30445576 1048603.12392896
 1877835.27104247 1309552.11260485 3599311.63718055 2671936.27100102
 1102942.28620842 3040970.21948955 2810167.27243244 2655053.69989483
 2311648.74223328  975653.40491365 2610273.97796166 1762004.84859118
 1153958.035758   1753674.32192219  139263.28408938 4756757.37032125
 1908577.07486589 1482446.3351366  1546694.39375575 3838302.83102495
 1580331.07514668  548199.06839018 1840315.96691998  710982.42043399
 1713971.12023702 1641328.82297691 2515834.71508039 2083588.47678464
 1948385.73634553 1109531.95734296  141610.53196567 1904277.10996867
 1753633.57109576  702317.36287824 1904952.6007877  1012353.29088169
 1909104.49794855 2550260.85418848 1696973.43929794 1552840.84271783
  770207.2754514  1082016.16575299  567880.19554066 1195266.14968728
 1425896.59517943 2068244.50571933 1455475.79910685 1676911.64798388
 1995297.97264884 1752290.99437207 3321595.7704449  1182211.79595002
 2036656.72291035  256170.66076661 2132709.1426479  2026834.96297993
  682644.5753414  2573209.23006142 2577058.2828362  1252957.08482442
 1202457.20389178  781388.02713036 1501528.04871925 1047021.80020146
 1249364.32264002 1923182.74135308 1263907.64094375  651764.23671862
 2200808.40752021 3016379.34904255 1608685.47830969  865907.8800686
 4004031.58834922  307898.39817498  960103.04684845 1870936.76798944
 1480280.92049622 1310345.90500355  818142.63376934 2063984.22052169
  653971.95997445 2647104.77196677  946475.00384817 1134017.1555212
 1336926.75320568 1692820.71866925 1649794.8105094  1324104.79913558
 1131129.65476272 1667020.2439952  1072787.7668243  1968374.70649127
 1704925.90892032  930349.66460818 3059589.26505135 1040383.01730904
 1319683.45412643 1736354.08561249 1043979.61894952 1231699.31826813
 2129836.57916416 4304998.67320384 2051457.58569256 1871475.99137708
 2118562.98082327  840369.66892497 2120909.90827075 3349324.23891432
 1125335.5560362   892360.36584486 1474452.20668273 1982189.91766902
  467001.01220888 1568566.81626545 1378315.18761975 1829555.48969979
 1258950.38620122 1218680.69479804 3116334.05164681 3410948.55993328
 1562079.72881562 1054122.35476607 2187734.99520626  951577.49627458
 1425802.0956161  2109209.21347231 1216529.4694065  1419885.30370961
  890540.24866032  548471.44216438 3564144.71276546  503281.76321887
  942634.1033166   914991.79825294 2229803.39015049 1569806.09527063
 2193041.60585415 2276029.7193437  2639329.00518937 1394643.71092926
 1512378.41704203  841597.33635717 1357129.32287974 2716372.9858471
 2980465.28619486  724220.27745018 1063714.11832236 2272416.20127291
  569376.30764183  990767.91170275 1495516.12831567 2460541.49484687
 1733889.06489284 1703179.274879   3446778.95987692 1848702.64706459
 1684626.01838624  804136.7056018  1544227.01784572 1229053.65726367
 2932244.29303107 1499608.71998965 2242291.85441533 3850699.25181122
 1223781.31119651  731802.11224176  697597.32216962 2740319.30268447
 1317443.87336246 2385528.37387932  579132.86243372 1658716.70268402
 1354655.9981878  1848953.11889464 1524014.12704304  895983.07767793
 1421024.73224682  976581.45621044 1497734.30763106 2276610.42855924
  889365.01371185 2046171.51248848 1956502.78164723 1931509.47752214
 1529394.643104   2011213.59733828 1201909.11876611 2853075.70372084
 3889098.42410548 1767657.81976811  888607.55805086  747705.45459791
 2626976.2100976   590427.40414122 1604214.65636972  747541.96260113
 1258035.13384053 1437518.37024122 2377401.0595244  2476643.59897906
 1576425.23220469 1225416.27032073 1855324.28080251 4522483.77904776
 2097083.30971291 1649677.31119787 1686964.74087755 2493188.48210934
 1381394.16752707 1661720.51466137 2443564.73770619 2693030.06123266
 1086533.72842987  806153.04836241 1775130.2601116  2003808.50266751
 3162533.53517156  903605.30423129 1022861.86475569 1435785.47629928
 3012019.21250496 1733737.52657442 2888687.60606248  681898.21070755
 1514456.94851291  425678.05364267 2880847.05112504 2719596.25151251
 1893657.20238294 2335960.82283057 1729223.55668404  721831.83131833
 1504765.23508713 1504666.67092593  873819.3968806  1178472.30042498
  804460.38840601 1473794.18775939  759534.95797185 1265377.72423582
 2408826.88677373  895793.50817752 2320378.29820708 1908485.04074684
 2263654.81734645 1384547.55841911  934630.47341265 2244987.33679776
 2110515.02953083 1910578.2321349   687880.8198842  2650705.14956991
 1738376.74055862  819705.75060783 2533625.22979302 1768435.03460789
 1714323.04130618 2294997.85544104 1256064.6142691  1433414.84416325
 1443653.71041677 2670473.12335962 1162856.05363269 2182763.93748394
 1783169.46311306 2170225.86286674 1464775.88897876  710974.18899659
  744561.56628318 1472998.5794737  1645501.65038053 1474252.81550864
 1438051.61353337 2077040.73635981  572424.71688262 1037853.8384299
 1242191.7201675   604760.76550253 4084373.73064239  742543.26191993
  852516.41789741 3722119.7863751  2253268.61998999 2078740.84187166
 3691321.91353219 1401832.21695174 1306381.00305395 2290590.90390622
 1560342.99021996 1193970.62525096 1322613.58107982 2202827.15357002
 1882992.71215595 1455689.15343444 1475692.28962758 1425302.04391982
  977371.39738671 1460926.26170402 1945268.51999138  990655.79561741
 2076515.72080584 2396377.25472867 1886966.51435099  659029.40240535
 2123214.54005474  743648.55505117 1733054.7560824  2316203.47771065
 1390804.49235998 2094730.79818479 2998314.4833398  2129075.80847185
 2602540.35900239 2018498.68914195 2812630.89323181 1256286.8025895
 1274594.67615147 1594641.70846635 1473113.68989636  729651.046634  ]
2025-06-24 07:08:23 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:08:23 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:08:24 ERROR Can not run the algorithm
2025-06-24 07:08:24 INFO Run function 18 complete. FEHistory len: 600, AOCC: 0.0000
2025-06-24 07:08:24 INFO FeHistory: [179036.73576245 147937.76075553 145620.81569837 184200.2868079
 187375.34189069 199418.41879847 203904.52504401 127525.24617481
 164725.82056567 135929.73989066 111366.61187114 149589.5798064
 142773.85655299 195154.80839529 129674.24662573 141551.75547513
 177349.38995152 162666.57766539 157446.07921711  82880.89785634
 188591.10068247 147601.67523784  96774.17266508  86465.23303526
 151919.12564669 224187.3964514  151673.47660134 144617.94485527
 111726.03468098 121411.39527341 152802.86023677 146787.38576627
 167221.50664525 100790.29277657 173728.3323272  120525.56128201
  65760.45450314 162777.28096663 212179.50933339 109221.10971291
 141268.94263283 146434.52369096 190111.84359463 227589.64284451
 107762.31718026 110995.61710669  80075.97352213 170253.01684173
 206873.12012107 158090.29842702 135499.79022986 144514.86952475
 198157.12084626 142150.9902526  159945.8795321  198366.12998801
 157117.41848311 169203.93040282 165688.32467295 173509.68171719
  91246.87841039 140556.68174886 140433.78374553 183354.96815969
 170416.52891401 135248.51176834 163035.10671441 109987.90822843
 157224.36487354 162047.90280904 146906.99776554 152818.01449507
 224088.39616833 183723.45142798 153684.83416771 169964.31828564
 123743.29166775 206018.44154691 184434.37023363 170944.60262372
 166264.59606791 158129.06289033 128068.93200093 115001.36188352
 139554.96023461  95081.39054496 164221.11625141 148795.5424373
  84191.44311994 113693.3949059  151429.29517678 197317.57994777
 108145.21721532 158435.62062834 148243.57364142 125859.550663
 198219.48967804 171720.65504217 109022.5744161  181976.10091416
 172151.44381681 122359.58377415 195550.390301   135322.1564623
 165733.39608041 190372.51673922 118059.09889497  89154.88031691
 207919.22451571 128037.22853018 185974.96112466 145026.61629477
 184927.91233771 109844.13260424 177371.98268426 172710.87439149
 155413.08349204 143249.40181497 168744.20872051 123885.11356332
 149287.27444954 153363.64529891  92106.86129887 192699.90447257
 130287.97506041 139147.85088145  97650.13146566 128455.52251903
 127710.08348314 176889.69970843 138970.40311851 107988.0795706
 140830.04007033 158065.42784478 153502.04133037 151592.111884
 177748.15435729 182052.28351957 139951.30692591 162888.15513087
 151905.79639748 184294.10473965 116414.35878643 155207.90209583
 192813.22491843 132965.32001506 108993.44998816 121883.63530787
 136034.07631858 178065.26851009 150398.53053739 148542.10225154
 204127.49304584 119792.44579923 174992.17754652 143793.3862807
 151035.0018048  114296.98524665 145890.44329713 155319.3021915
 171134.707042   132034.28480874  99436.77407592 139622.13293727
 127679.83480447 197481.39101713  97339.66195701 172122.01564608
 158032.97835282 170219.36835742 123458.45582226  89509.19966624
 153906.28120306 210048.67143702 140540.03900967 132775.70530099
 206643.66179386 159092.46840185  94819.68675751 184704.78860818
  89898.71976395 143890.86222239 163873.90131353 140901.89143982
 153125.56130056 133451.3936803  164982.87665829 132068.89707295
 154201.84500667 109465.9628598  139459.12504674 144270.29779106
 158483.10306375 126226.12483686 171084.25206579 125031.2212945
 167525.88324299 272028.35173159 228818.91195345 136441.25992503
 157862.01785547 152907.89804235 210537.39555178 278978.81249122
 161009.23024207 122343.4627485  157436.32984173 200332.41707368
 113896.94018959 154064.41639095 148882.38247976 208489.9275127
 176156.21550293 178544.30050925 164208.0043438  164450.86276776
 136783.54878443  98258.49762062 139312.45908507 147984.49085384
 128964.26436493 171240.20494276 122065.50277851 186245.86804885
 112106.37580368 246976.34528275 129014.19523335 116528.60331845
 169455.37365315 128285.16441985 109460.92785821 101873.35011856
  89878.19066542  82797.33242569 180335.31143337 165553.37895281
 141860.18324933 164957.42474303 147408.45308185 204488.16145666
 187160.87287129 169940.66421524 112456.95836472 194901.61500785
 254621.29936555 146900.64270351 122059.21774747 137777.01309098
 159279.2544757  169802.77514347  95326.25253716 169878.15366188
  89638.75982382 115654.2170775  138718.27755517 117758.34344341
 143539.99640995 132079.11880142 134722.62577499 163536.71444692
 261738.31067509 160976.92869435 205432.09258667 187596.83990199
 110639.36513134 186271.29668718 156321.29714528 179437.20428246
 200831.12759069 131058.74788257  99287.2515003  164302.44735411
 104959.35158915 136916.52754994 183075.11331598 189462.28022466
 115752.15115316 126821.19968701 147098.50886692  97816.75537685
 170735.56406449 165887.40454014 107196.74507411 153962.66174022
 205079.93444455 137972.75947021 197811.28221545 165056.86526523
 123441.77745685 164597.56178546 120238.26669439 194722.14439361
 180876.95856224 181693.51164372 168318.36135824 139892.0925451
  83886.67472821 177337.49202092 133483.72592273 263110.59381961
 130181.69199322 167051.30971142 151300.87165546 245128.57183448
 173536.40207041 162386.48004088 111088.10811334  88090.68513693
 134513.70594762 216884.30626984 139215.21863941 102613.37099545
 108099.8167824  116973.58347361 119890.6529269  168039.03486059
 133190.4637698  180065.40410805 114492.26827545  96440.37208708
 181056.26212799 144106.87552388 128143.51174426 120965.45882279
 157860.09144753 106270.80472338 160971.17380284 209535.92797704
  85324.10830435 141038.01276736 124719.80834689 163175.81957702
 170162.72824628 128867.57212704 133762.00734149 174640.30068001
 198152.89333721 166409.95576952 177889.88958122 188394.89097687
 173328.15299667 133967.0202404  131981.21354535 168940.15739565
 179548.22752914 287111.92120841 107186.90580606 151749.11817371
 105653.18863786 156866.6835461   89098.70643286 130992.40429879
 163232.75929993 167391.71517636 218751.73156932 185338.65416262
 117706.40828658  92356.58389945 134018.82441741 238346.93891637
 155270.78469185 112734.43661461 126158.16835679 162055.10585665
 149617.84659775 149018.65068357 121335.37152619 139601.2426533
 135075.08301859 115938.2973774  115784.94055781 148028.39221691
 148641.57881654 148805.64638586 114803.4438783  111303.12885362
 123014.4362452  126669.59755527 153885.57906355  89304.37144167
 123543.54162963 255408.86097818 118537.26299648 106945.57368297
 135825.99471321 138005.36962815 149535.65847405 149326.43571221
 118367.31621056 130149.46802855 133604.52946382 105711.53392363
 183938.16197878 142908.10434123 146387.94417758 162962.0378445
 139998.76802207 173163.75508995 169237.54817712 187522.5264026
 146777.52459468 143901.36495071 124473.63639827 152881.76564565
 164062.15784536 118864.68092023 117981.59429296 105759.04342543
 135684.47169088 144869.02059316 195889.12616518 123766.26703645
 146396.17696511 192519.14177249 199331.88247497 159467.15682787
 109312.31965398 129641.01221359 161288.09117495 153976.45784952
 185278.53156922 269077.87910688 207953.73638877 132233.21862244
 177820.51299474 169264.67458167 103848.71651919 154662.144175
 151454.79287825 117271.33217912 146405.10388033 117690.16190478
 146388.54655165 157599.76489429 136469.41580556 171903.0776752
 152130.35390736 160222.51962511 148553.64272618 164682.87165038
 128935.67115427 194069.4268355  170477.8730325  161803.55848219
 179732.19470043 196676.80330468 104347.7007675  161504.44566785
 123465.43659269 151036.33398253 168225.57603923  95079.86177167
 115621.59827016  88187.17299739 119078.54246139 180663.93294592
  74691.07934584 155724.17559153 145227.11996505 166091.98408353
 151453.34106175 206601.116178   113168.7240441  163751.56002142
  90061.40638993 115649.36717352 135288.55664401 100283.01965694
 167089.08935001  99748.88050544 119036.29949941  73761.46609834
 115993.92021899 203838.06403725 161938.88909314 165708.38404978
 128006.76392303 129372.64800624  87096.26017185 160844.45828346
  85121.67212216 176615.33300448 134707.6421917  147593.32165743
  86478.50680142 106614.38702035 118842.18605076 131609.75176707
 124893.45130462 138008.01862548  97076.87744015 152250.51349041
 143035.3539404  129488.40709796 146015.98399547 131045.56843598
 146863.29793077 148765.95048218 163264.31833633 170076.89386979
 117505.65991613 193245.13125413 184432.09846546 149392.44660153
 159171.9683521  115254.11552368 135291.75973301 125987.72260452
 130733.18808087 144617.55465582 146635.96270325 108801.91539897
 184802.05838853 133378.26042914 107127.60402642 218887.59111736
 114828.16829874 150881.1265666  198241.2532037  178469.18997122
 129849.63793824 159739.91326823 164057.16587758 131252.14038178
 122892.53424531 119750.87369122 204506.52594524 147425.2884411
 171881.70502494 121663.4507275  131265.61960041 156748.74416167
 139760.60699341 251504.5656113  123169.76225661 168275.89268184
 175509.49118378 140302.39246969 144034.7507609  132216.44833323
  94526.22286013 122814.34170259 140486.83281671 177553.27365521
 186642.1969412  205601.1690478  134686.09602131 175878.75335658
 189218.24052704 137380.85337084 149666.88816568 125550.59353766
 156698.51166955 134007.49709981 170667.57832144 202755.02205589
 141609.39789073 108725.23540515 166565.53465163 120276.06982398
 155104.82147879 128134.6974441  144196.58488065 113049.21108525
 105268.17314727 117594.71364212 112193.04005206 104634.13398692
  89732.94389974 142462.34754609  91310.37826326 155472.73595549
 183146.96754913 121110.53340231 145923.09060852 108745.94086912
 113312.43244135 170744.84655483 174717.14698325 195756.7279384
 174160.31065248 224738.73584484 123807.27059368 209599.61012717
 187689.66809025 170892.93994796 113564.7315325  233329.89474781
 130493.03879438  92612.02340791  87382.54425408 187709.33355683
 154344.35284334 115175.90947274 130934.51111997 192206.43424975
  94838.77563152 243952.77362125 122497.65511593 130420.20265289]
2025-06-24 07:08:24 INFO Expected Optimum FE: -5000
2025-06-24 07:08:24 INFO Unimodal AOCC mean: 0.1476
2025-06-24 07:08:24 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:08:24 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 07:08:24 INFO AOCC mean: 0.0492
2025-06-24 07:08:24 INFO Weighed AOCC mean: 0.0148
2025-06-24 07:08:24 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:08:27 INFO Run function 18 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:08:27 INFO FeHistory: [165948.60265925 107814.45269861 196327.6959752  ...  63587.18762951
  35995.59538447  94545.8839865 ]
2025-06-24 07:08:27 INFO Expected Optimum FE: -5000
2025-06-24 07:08:27 INFO Unimodal AOCC mean: 0.1513
2025-06-24 07:08:27 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:08:27 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 07:08:27 INFO AOCC mean: 0.0504
2025-06-24 07:08:27 INFO Weighed AOCC mean: 0.0151
2025-06-24 07:08:27 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:08:32 INFO Run function 6 complete. FEHistory len: 100000, AOCC: 0.1631
2025-06-24 07:08:32 INFO FeHistory: [-183.41012684 -183.39946819 -183.30063387 ... -184.57730666 -184.57730666
 -184.57730666]
2025-06-24 07:08:32 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:08:32 INFO Good algorithm:
Algorithm Name: ArchiveGuidedAdaptiveDE
import numpy as np
import random

class ArchiveGuidedAdaptiveDE:
    """
    Hybrid Differential Evolution algorithm with an archive and adaptive mutation 
    for robust multimodal optimization.
    """
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        self.population_size = 100
        self.archive_size = 50
        self.archive = []
        self.F = 0.5  # Differential weight
        self.CR = 0.9 # Crossover rate
        self.mutation_rate = 0.1 #Initial mutation rate

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
        self.fitness_values = objective_function(self.population)
        self.eval_count += self.population_size

        self.best_solution_overall, self.best_fitness_overall = self.update_best(self.population, self.fitness_values)

        while self.eval_count < self.budget:
            offspring = self.generate_offspring()
            offspring_fitness = objective_function(offspring)
            self.eval_count += self.population_size

            self.population, self.fitness_values = self.selection(self.population, self.fitness_values, offspring, offspring_fitness)
            self.best_solution_overall, self.best_fitness_overall = self.update_best(self.population, self.fitness_values)
            self.update_archive()
            self.adapt_parameters()

        if self.best_solution_overall is None and self.dim > 0:
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def generate_offspring(self):
        offspring = np.zeros_like(self.population)
        for i in range(self.population_size):
            a, b, c = self.select_parents(i)
            mutated = self.population[a] + self.F * (self.population[b] - self.population[c])
            offspring[i] = self.crossover(self.population[i], mutated)
            offspring[i] = np.clip(offspring[i], self.lower_bounds, self.upper_bounds)
        return offspring

    def select_parents(self, i):
        a, b, c = random.sample(range(self.population_size), 3)
        while a == i or b == i or c == i:
            a, b, c = random.sample(range(self.population_size), 3)
        return a, b, c
    
    def crossover(self, x, v):
        return np.where(np.random.rand(self.dim) < self.CR, v, x)
    
    def selection(self, population, fitnesses, offspring, offspring_fitnesses):
        combined_population = np.vstack((population, offspring))
        combined_fitnesses = np.concatenate((fitnesses, offspring_fitnesses))
        sorted_indices = np.argsort(combined_fitnesses)
        return combined_population[sorted_indices[:self.population_size]], combined_fitnesses[sorted_indices[:self.population_size]]

    def update_best(self, population, fitnesses):
        best_index = np.argmin(fitnesses)
        best_solution = population[best_index]
        best_fitness = fitnesses[best_index]
        if best_fitness < self.best_fitness_overall:
            self.best_fitness_overall = best_fitness
            self.best_solution_overall = best_solution
        return best_solution, best_fitness

    def update_archive(self):
        for i in range(self.population_size):
            if len(self.archive) < self.archive_size:
                self.archive.append((self.population[i], self.fitness_values[i]))
            else:
                worst_index = np.argmax([f for _, f in self.archive])
                if self.fitness_values[i] < self.archive[worst_index][1]:
                    self.archive[worst_index] = (self.population[i], self.fitness_values[i])

    def adapt_parameters(self):
        self.F = max(0.1, self.F * 0.99) #Decay F
        self.mutation_rate *= 0.99 #Decay mutation rate


2025-06-24 07:08:32 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:08:39 INFO Run function 13 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:08:39 INFO FeHistory: [ 3.10467584e+06  2.15969256e+06  3.59268010e+06 ... -3.68349360e+01
 -3.64831060e+01 -3.68404089e+01]
2025-06-24 07:08:39 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:08:39 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:09:05 INFO Run function 18 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:09:05 INFO FeHistory: [204048.53963265 187511.13518702 179875.57961896 ...  -4356.77026908
  -4356.77026908  -4356.77026908]
2025-06-24 07:09:05 INFO Expected Optimum FE: -5000
2025-06-24 07:09:05 INFO Unimodal AOCC mean: 0.1631
2025-06-24 07:09:05 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:09:05 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 07:09:05 INFO AOCC mean: 0.0544
2025-06-24 07:09:05 INFO Weighed AOCC mean: 0.0163
2025-06-24 07:09:05 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:09:05 ERROR Can not run the algorithm
2025-06-24 07:09:06 INFO Run function 6 complete. FEHistory len: 102, AOCC: 0.1467
2025-06-24 07:09:06 INFO FeHistory: [-183.32040326 -183.29563417 -183.2610943  -183.30375908 -183.28852784
 -183.3514411  -183.3308178  -183.444216   -183.31077328 -183.30933705
 -183.34555844 -183.33868955 -183.30676943 -183.2904676  -183.34372875
 -183.28628321 -183.36849502 -183.39944395 -183.30353173 -183.27754523
 -183.34275573 -183.34598506 -183.44128967 -183.44642612 -183.29203012
 -183.3267901  -183.33249737 -183.37823311 -183.39806114 -183.43746631
 -183.31448276 -183.40104945 -183.29679624 -183.36403152 -183.32309466
 -183.33954865 -183.38650198 -183.41034333 -183.35048292 -183.30677792
 -183.36196337 -183.33838898 -183.39305489 -183.32827314 -183.33285972
 -183.39212235 -183.26843766 -183.30004012 -183.31475064 -183.26686322
 -183.27620584 -183.38155032 -183.34900877 -183.25838197 -183.27871666
 -183.31123131 -183.32181255 -183.44822149 -183.31185877 -183.35710335
 -183.37080895 -183.33263411 -183.35390862 -183.35769381 -183.34696762
 -183.37559309 -183.36797096 -183.32006451 -183.33380641 -183.28290661
 -183.32538519 -183.33186778 -183.33646771 -183.29758656 -183.39265052
 -183.26964176 -183.40972404 -183.3136277  -183.31656213 -183.41952022
 -183.30197599 -183.34042831 -183.3389728  -183.29355304 -183.3321467
 -183.32003432 -183.39455156 -183.3624726  -183.328138   -183.4009279
 -183.36040728 -183.35757861 -183.28941812 -183.27398589 -183.30309654
 -183.4046399  -183.34765047 -183.30116007 -183.36261468 -183.27792196
 -183.30948021 -183.30926618]
2025-06-24 07:09:06 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:09:06 INFO Good algorithm:
Algorithm Name: ArchiveGuidedAdaptiveDE
import numpy as np
import random

# Name: ArchiveGuidedAdaptiveDE
# Description: Hybrid DE with archive and adaptive mutation for robust multimodal optimization.
# Code:
class ArchiveGuidedAdaptiveDE:
    """
    A hybrid Differential Evolution algorithm that uses an archive to store promising solutions 
    and adapts its mutation strategy based on the search progress.
    """
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        self.population_size = 100
        self.archive_size = 50
        self.archive = []
        self.mutation_scale = 0.8
        self.mutation_scale_decay = 0.99
        self.population = None
        self.fitness_values = None


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.population = self._initialize_population()
        self.fitness_values = self._evaluate_population(objective_function)
        self.best_solution_overall, self.best_fitness_overall = self._find_best(self.population, self.fitness_values)

        while self.eval_count < self.budget:
            new_population = []
            new_fitness_values = []

            for i in range(self.population_size):
                # Differential Mutation with Archive Guidance
                a, b, c = self._select_different(i)
                mutant = self.population[a] + self.mutation_scale * (self.population[b] - self.population[c])

                # Incorporate archive into mutation
                if len(self.archive) > 0:
                    archive_index = random.randint(0, len(self.archive) - 1)
                    mutant += 0.2 * (self.archive[archive_index] - self.population[i])  # Influence from archive


                # Adaptive Gaussian Perturbation
                mutant += np.random.normal(0, self.mutation_scale / 2, self.dim)
                mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

                # Crossover
                trial = np.where(np.random.rand(self.dim) < 0.5, mutant, self.population[i])

                # Selection
                trial_fitness = objective_function(trial.reshape(1, -1))[0]
                self.eval_count += 1
                if trial_fitness < self.fitness_values[i]:
                    new_population.append(trial)
                    new_fitness_values.append(trial_fitness)
                    self._update_archive(trial, trial_fitness)
                else:
                    new_population.append(self.population[i])
                    new_fitness_values.append(self.fitness_values[i])

                best_solution, best_fitness = self._find_best(np.array(new_population), np.array(new_fitness_values))
                if best_fitness < self.best_fitness_overall:
                    self.best_solution_overall = best_solution
                    self.best_fitness_overall = best_fitness

            self.population = np.array(new_population)
            self.fitness_values = np.array(new_fitness_values)
            self.mutation_scale *= self.mutation_scale_decay

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info


    def _initialize_population(self):
        return np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))

    def _evaluate_population(self, objective_function):
        fitness = objective_function(self.population)
        self.eval_count += self.population_size
        return fitness

    def _select_different(self, index):
        a, b, c = random.sample(range(self.population_size), 3)
        while a == index or b == index or c == index or a == b or a == c or b == c:
            a, b, c = random.sample(range(self.population_size), 3)
        return a, b, c

    def _find_best(self, population, fitness_values):
        best_index = np.argmin(fitness_values)
        return population[best_index], fitness_values[best_index]

    def _update_archive(self, solution, fitness):
        if len(self.archive) < self.archive_size:
            self.archive.append((solution, fitness))
        else:
            worst_solution_index = np.argmax([f for _, f in self.archive])
            if fitness < self.archive[worst_solution_index][1]:
                self.archive[worst_solution_index] = (solution, fitness)

2025-06-24 07:09:06 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:09:06 ERROR Can not run the algorithm
2025-06-24 07:09:06 INFO Run function 13 complete. FEHistory len: 102, AOCC: 0.0000
2025-06-24 07:09:06 INFO FeHistory: [ 830644.68763459 3001983.29759627 1686824.50345115 1853180.70350908
 1682393.42984323  897875.50809299  394445.71328927 4656822.95350641
  665767.78210999 1132637.97552421 1454161.03065236 1288624.71079143
  996959.72243622  928546.89380106 2711409.79803018 1393134.34562459
 1090485.97411643 2137916.1789814  1614639.12031298 1785792.98694362
 2428464.06403774  851686.7244655  1979655.30740779 1017031.50482179
 2625407.21837177  457650.13891632 1276084.73154854  719200.81026933
  808122.66069572  932798.62418628 2522397.79756663 2317136.80940535
 2665149.08606541 1339399.3010613  1927620.81217056  928275.50375908
 1683984.16731874 1191446.45760249 4458562.3691323  1055882.30840297
  816642.60013719 2441921.11256354  686735.61487335 1252164.25704089
 1370324.12020179 1770928.44020038 4120474.05470606  838229.45328719
 2591428.78102899 2115181.38380516  660418.9708635  1757524.22159011
 1424114.9338092  1714102.58124035 2988984.39362605 1467815.8559286
 3598650.19965273 1428164.36534343 1103103.94477468 1611312.37027206
  550436.77414618 1225071.83716949 4977666.34700629  679022.23614789
 2419107.78925188 1470104.20520894 2366642.32745309 1791966.63481459
 1519013.091068    415717.26783646 2243774.98756966 1180627.58117318
 1781541.68316087  617689.30011656 1634087.81966265 1697429.66700346
  257997.32339936 3803244.33781173 1185088.87652762  907794.40817651
 2304018.49522547 1731947.80098897 1230000.00278728 1641889.89202611
 2257008.42133819 1358906.52396446 2157159.55977503 1067546.12934969
 1128056.42925603 1963404.17502481 2129806.7255959   598156.94267452
 2995582.97105944 3050692.89285436 3765615.7320783  1850157.25306866
 1882354.5700449  1948447.22354533 1349241.8472728  2452477.43573219
 3739214.61730914 1917618.32067654]
2025-06-24 07:09:06 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:09:06 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:09:06 ERROR Can not run the algorithm
2025-06-24 07:09:06 INFO Run function 18 complete. FEHistory len: 101, AOCC: 0.0000
2025-06-24 07:09:06 INFO FeHistory: [205892.87986694 108320.8669729  185359.32717627 154814.78973572
 167305.36315478 141023.15396407 148834.49991642 122422.30209553
 190028.07584502 109818.60736215 138121.02512134 130585.22001049
 119136.13907906 105883.66568329 127297.09713604 140998.555736
 141954.93759317 181429.96374265 161677.60938695 144994.67766023
 145114.42565438 143477.64619346 210982.39907151 130690.41558789
 190252.39376797 120672.80034775 139510.73013887 179300.77802287
 231407.01678809  96956.15594114 119748.7043595  173200.21739817
 118676.03898259 176536.5013773  115845.33490409 123253.13898258
 167825.17395685 172303.49443864 154408.9128408  155615.25725875
 136968.53912776 159339.82347752 182918.35980797 109663.26444361
 103936.88481126 115488.06515319 149768.11421391 188342.13129645
 141177.02353633 100442.41204904 179340.78199618 136807.29857819
 123477.75930984 188924.23932202 199012.50994352 130548.77426164
 106550.88566344 152394.6645099  140351.01887632 167466.99285477
 140789.48545182  99348.64624263 130633.00445908 133781.94617036
 170665.12226123 106547.20964118  91976.20262587 190905.18104565
  93115.9231675  115643.95207049 147712.66199453 157355.94912065
 127605.68053449 145787.80055451  87817.72552593 165433.26004534
 187402.93646761 152865.09575593 143733.17218035  91992.69687906
 163553.38304374 169032.52822821 166636.53711546 130880.11715734
 186337.90490604 187534.14928242 207080.91274728 141278.29446855
 171976.15861289 124583.82353405 110024.42981436 143565.42830804
 149470.49181406 154067.16635433 121066.57979823 170519.91400512
 149192.41754282 170347.66328001 148244.02635545 162082.18498781
 170952.76873399]
2025-06-24 07:09:06 INFO Expected Optimum FE: -5000
2025-06-24 07:09:06 INFO Unimodal AOCC mean: 0.1467
2025-06-24 07:09:06 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:09:06 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 07:09:06 INFO AOCC mean: 0.0489
2025-06-24 07:09:06 INFO Weighed AOCC mean: 0.0147
2025-06-24 07:09:13 INFO Run function 6 complete. FEHistory len: 100000, AOCC: 0.1579
2025-06-24 07:09:13 INFO FeHistory: [-183.3790024  -183.33943517 -183.33271341 ... -184.25341847 -184.25341847
 -184.25341847]
2025-06-24 07:09:13 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:09:13 INFO Good algorithm:
Algorithm Name: ArchiveGuidedAdaptiveDE
import numpy as np
import random

# Name: ArchiveGuidedAdaptiveDE
# Description: Hybrid DE algorithm using an archive to enhance exploration and adaptive mutation for exploitation.

class ArchiveGuidedAdaptiveDE:
    """
    Combines Differential Evolution (DE) with an archive and adaptive mutation 
    to efficiently explore and exploit multimodal landscapes.
    """
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = budget
        self.dim = dim
        self.lower_bounds = np.array(lower_bounds)
        self.upper_bounds = np.array(upper_bounds)
        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        self.population_size = 100
        self.archive_size = 200
        self.archive = []
        self.F = 0.8  # Differential weight (adaptive)
        self.CR = 0.9 # Crossover rate

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        population = self._initialize_population()
        fitness_values = objective_function(population)
        self.eval_count += self.population_size
        self.archive = self._update_archive(population, fitness_values)
        self._update_best(population, fitness_values)

        while self.eval_count < self.budget:
            offspring = self._generate_offspring(population)
            offspring_fitness = objective_function(offspring)
            self.eval_count += self.population_size
            population, fitness_values = self._select_next_generation(
                population, fitness_values, offspring, offspring_fitness
            )
            self.archive = self._update_archive(np.vstack((population, offspring)), 
                                                np.concatenate((fitness_values, offspring_fitness)))
            self._update_best(population, fitness_values)
            self._adapt_parameters(population, fitness_values)

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def _initialize_population(self):
        return np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))

    def _generate_offspring(self, population):
        offspring = np.zeros_like(population)
        for i in range(self.population_size):
            a, b, c = self._select_different_individuals(population, i)
            mutant = a + self.F * (b - c)
            offspring[i] = self._crossover(population[i], mutant)
        return np.clip(offspring, self.lower_bounds, self.upper_bounds)

    def _select_different_individuals(self, population, i):
        indices = list(range(self.population_size))
        indices.remove(i)
        a, b, c = random.sample(indices, 3)
        return population[a], population[b], population[c]

    def _crossover(self, x, v):
        jrand = random.randint(0, self.dim - 1)
        y = np.copy(x)
        for j in range(self.dim):
            if random.random() < self.CR or j == jrand:
                y[j] = v[j]
        return y

    def _select_next_generation(self, population, fitness_values, offspring, offspring_fitness):
        combined_pop = np.vstack((population, offspring))
        combined_fit = np.concatenate((fitness_values, offspring_fitness))
        sorted_indices = np.argsort(combined_fit)
        return combined_pop[sorted_indices[:self.population_size]], combined_fit[sorted_indices[:self.population_size]]

    def _update_best(self, population, fitness_values):
        best_index = np.argmin(fitness_values)
        if fitness_values[best_index] < self.best_fitness_overall:
            self.best_fitness_overall = fitness_values[best_index]
            self.best_solution_overall = population[best_index]

    def _update_archive(self, population, fitness_values):
        combined = np.column_stack((population, fitness_values))
        new_archive = []
        for sol in combined:
            already_present = any(np.allclose(sol[:-1], arch[:-1], atol=1e-6) for arch in self.archive)
            if not already_present:
                new_archive.append(sol)
        new_archive.sort(key=lambda x: x[-1])
        return np.array(new_archive)[:self.archive_size]

    def _adapt_parameters(self, population, fitness_values):
        #Simple adaptive scheme: Reduce F if convergence is detected
        avg_fitness_diff = np.mean(np.diff(np.sort(fitness_values)))
        if avg_fitness_diff < 0.1: # Adjust threshold as needed
            self.F *= 0.95
2025-06-24 07:09:13 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:11:56 INFO Run function 6 complete. FEHistory len: 100000, AOCC: 0.1527
2025-06-24 07:11:56 INFO FeHistory: [-183.32418458 -183.40933802 -183.28865638 ... -183.86999021 -183.87844505
 -183.85901649]
2025-06-24 07:11:56 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:11:56 INFO Good algorithm:
Algorithm Name: ArchiveGuidedAdaptiveDE
import numpy as np
import random

# Name: ArchiveGuidedAdaptiveDE
# Description: Hybrid DE with an archive to enhance exploration and adaptive mutation for multimodal optimization.
# Code:

class ArchiveGuidedAdaptiveDE:
    """
    Combines adaptive Differential Evolution (DE) with an archive to enhance exploration and exploitation in multimodal landscapes.  
    Uses an adaptive mutation strategy and tournament selection for efficiency.  The archive helps maintain diversity and guides exploration towards promising areas.
    """
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        self.population_size = 100
        self.archive_size = 200
        self.F = 0.8  # Differential evolution scaling factor
        self.CR = 0.9 # Crossover rate
        self.archive = []


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        if self.dim > 0:
            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        else:
            self.best_solution_overall = np.array([])
        self.best_fitness_overall = objective_function(self.best_solution_overall.reshape(1, -1))[0]
        self.eval_count += 1

        population = self._initialize_population()
        fitness_values = objective_function(population)
        self.eval_count += self.population_size
        self.archive = self._update_archive(population, fitness_values)

        while self.eval_count < self.budget:
            offspring = self._differential_evolution(population, fitness_values)
            offspring_fitness = objective_function(offspring)
            self.eval_count += self.population_size

            population, fitness_values = self._select_next_generation(
                population, fitness_values, offspring, offspring_fitness
            )

            self.archive = self._update_archive(
                np.vstack((population, offspring)),
                np.concatenate((fitness_values, offspring_fitness))
            )

            self._update_best(offspring, offspring_fitness)

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }

        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def _initialize_population(self):
        return np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))

    def _differential_evolution(self, population, fitness_values):
        offspring = []
        for i in range(self.population_size):
            # Mutation
            a, b, c = self._select_mutants(i, len(population))
            mutant = population[a] + self.F * (population[b] - population[c])

            # Crossover
            trial = np.where(np.random.rand(self.dim) < self.CR, mutant, population[i])
            trial = np.clip(trial, self.lower_bounds, self.upper_bounds)
            offspring.append(trial)

        return np.array(offspring)

    def _select_mutants(self, i, pop_size):
       
        indices = np.random.choice(pop_size, 3, replace=False)
        while i in indices:
            indices = np.random.choice(pop_size, 3, replace=False)
        return indices


    def _select_next_generation(self, population, fitness_values, offspring, offspring_fitness):
        combined_pop = np.vstack((population, offspring))
        combined_fit = np.concatenate((fitness_values, offspring_fitness))
        sorted_indices = np.argsort(combined_fit)
        next_gen = combined_pop[sorted_indices[:self.population_size]]
        next_fit = combined_fit[sorted_indices[:self.population_size]]
        return next_gen, next_fit

    def _update_best(self, offspring, offspring_fitness):
        for i, fitness in enumerate(offspring_fitness):
            if fitness < self.best_fitness_overall:
                self.best_fitness_overall = fitness
                self.best_solution_overall = offspring[i]

    def _update_archive(self, population, fitness_values):
        combined = np.column_stack((population, fitness_values))
        new_archive = []
        for sol in combined:
            already_present = any(np.allclose(sol[:-1], arch[:-1], atol=1e-6) for arch in self.archive)
            if not already_present:
                new_archive.append(sol)
        new_archive.sort(key=lambda x: x[-1])
        return np.array(new_archive[:self.archive_size])

2025-06-24 07:11:56 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:11:57 INFO Run function 6 complete. FEHistory len: 100000, AOCC: 0.1526
2025-06-24 07:11:57 INFO FeHistory: [-183.32706378 -183.2946512  -183.29243457 ... -183.81788364 -183.85083856
 -183.81191645]
2025-06-24 07:11:57 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:11:57 INFO Good algorithm:
Algorithm Name: ArchiveGuidedAdaptiveDE
import numpy as np
import random

class ArchiveGuidedAdaptiveDE:
    """
    Combines Differential Evolution (DE) with an archive to enhance exploration and exploitation in multimodal landscapes.  
    Adaptive mutation rate adjusts exploration based on diversity.
    """
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        self.population_size = 100
        self.archive_size = 200
        self.archive = []
        self.F = 0.8  # DE scaling factor
        self.CR = 0.9  # DE crossover rate
        self.mutation_rate = 0.1 # Initial mutation rate


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        self.best_fitness_overall = objective_function(self.best_solution_overall.reshape(1,-1))[0]
        self.eval_count += 1

        population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        fitness_values = objective_function(population)
        self.eval_count += self.population_size
        self.archive = self._update_archive(population, fitness_values)


        while self.eval_count < self.budget:
            offspring = self._generate_offspring(population)
            offspring_fitness = objective_function(offspring)
            self.eval_count += self.population_size

            population, fitness_values = self._select_next_generation(population, fitness_values, offspring, offspring_fitness)
            self.archive = self._update_archive(np.vstack((population, offspring)), np.concatenate((fitness_values, offspring_fitness)))

            self._update_best(offspring, offspring_fitness)
            self.mutation_rate = self._adaptive_mutation_rate(population)


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info


    def _generate_offspring(self, population):
        offspring = np.zeros_like(population)
        for i in range(self.population_size):
            a, b, c = random.sample(range(self.population_size), 3)
            while a == i or b == i or c == i:
                a, b, c = random.sample(range(self.population_size), 3)
            mutant = population[a] + self.F * (population[b] - population[c])
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)

            trial = np.zeros_like(population[i])
            for j in range(self.dim):
                if random.random() < self.CR:
                    trial[j] = mutant[j]
                else:
                    trial[j] = population[i][j]
            offspring[i] = trial
            #Adaptive Mutation
            if random.random() < self.mutation_rate:
                offspring[i] += np.random.normal(0, 0.1 * (self.upper_bounds - self.lower_bounds), self.dim) # Gaussian mutation
                offspring[i] = np.clip(offspring[i], self.lower_bounds, self.upper_bounds)

        return offspring


    def _select_next_generation(self, population, fitness_values, offspring, offspring_fitness):
        combined_pop = np.vstack((population, offspring))
        combined_fit = np.concatenate((fitness_values, offspring_fitness))
        sorted_indices = np.argsort(combined_fit)
        next_gen = combined_pop[sorted_indices[:self.population_size]]
        next_fit = combined_fit[sorted_indices[:self.population_size]]
        return next_gen, next_fit

    def _update_best(self, offspring, offspring_fitness):
        for i, fitness in enumerate(offspring_fitness):
            if fitness < self.best_fitness_overall:
                self.best_fitness_overall = fitness
                self.best_solution_overall = offspring[i]

    def _update_archive(self, population, fitness_values):
        combined = np.column_stack((population, fitness_values))
        new_archive = []
        for sol in combined:
            already_present = any(np.allclose(sol[:-1], arch[:-1], atol=1e-6) for arch in self.archive)
            if not already_present:
                new_archive.append(sol)
        new_archive.sort(key=lambda x: x[-1])
        return np.array(new_archive[:self.archive_size])


    def _adaptive_mutation_rate(self, population):
        #Simple diversity measure: average distance to nearest neighbor. High distance implies high diversity
        distances = np.linalg.norm(population[:, np.newaxis, :] - population[np.newaxis, :, :], axis=2)
        avg_dist = np.mean(np.min(distances[np.arange(distances.shape[0]) != np.arange(distances.shape[1])], axis=1))
        if avg_dist > 50:
            return 0.05 # Decrease exploration if already diverse
        elif avg_dist < 20:
            return 0.2  # Increase exploration if not enough diversity
        else:
            return self.mutation_rate # Maintain current rate

2025-06-24 07:11:57 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:12:46 INFO Run function 6 complete. FEHistory len: 100000, AOCC: 0.1519
2025-06-24 07:12:46 INFO FeHistory: [-183.34510806 -183.27507569 -183.27911093 ... -183.85558294 -183.80751811
 -183.75022175]
2025-06-24 07:12:46 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:12:46 INFO Good algorithm:
Algorithm Name: ArchiveGuidedAdaptiveDE
import numpy as np
import random

# Name: ArchiveGuidedAdaptiveDE
# Description: Hybrid DE with archive and adaptive mutation for multimodal optimization.
class ArchiveGuidedAdaptiveDE:
    """
    Combines Differential Evolution (DE) with an archive and adaptive mutation 
    to enhance exploration and exploitation in high-dimensional multimodal landscapes.
    """
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')
        self.population_size = 100
        self.archive_size = 200
        self.archive = []
        self.F = 0.8  # Differential weight
        self.CR = 0.9 # Crossover rate
        self.sigma = 0.2 * (self.upper_bounds - self.lower_bounds) #Adaptive mutation scale

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)
        self.best_fitness_overall = objective_function(self.best_solution_overall.reshape(1, -1))[0]
        self.eval_count += 1

        population = self._initialize_population()
        fitness_values = objective_function(population)
        self.eval_count += self.population_size
        self.archive = self._update_archive(population, fitness_values)

        while self.eval_count < self.budget:
            offspring = self._differential_evolution(population, fitness_values)
            offspring_fitness = objective_function(offspring)
            self.eval_count += self.population_size

            population, fitness_values = self._selection(population, fitness_values, offspring, offspring_fitness)
            self.archive = self._update_archive(np.vstack((population, offspring)), np.concatenate((fitness_values, offspring_fitness)))
            self._update_best(offspring, offspring_fitness)
            self.sigma *= 0.99 #Adaptive Mutation Scaling

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def _initialize_population(self):
        return np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))

    def _differential_evolution(self, population, fitness_values):
        offspring = np.copy(population)
        for i in range(self.population_size):
            a, b, c = self._select_distinct(population, i, 3)
            mutant = a + self.F * (b - c)
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds) #Keep within bounds
            trial = self._crossover(population[i], mutant)
            trial = self._adaptive_mutation(trial)
            offspring[i] = trial
        return offspring
    
    def _adaptive_mutation(self, solution):
        return solution + np.random.normal(0, self.sigma, size=solution.shape)

    def _select_distinct(self, population, exclude_index, num_vectors):
      indices = np.random.choice(len(population), num_vectors, replace=False)
      while exclude_index in indices:
          indices = np.random.choice(len(population), num_vectors, replace=False)
      return population[indices]

    def _crossover(self, x, v):
        u = np.copy(x)
        indices = np.random.rand(self.dim) < self.CR
        u[indices] = v[indices]
        return u

    def _selection(self, population, fitness_values, offspring, offspring_fitness):
        combined_pop = np.vstack((population, offspring))
        combined_fit = np.concatenate((fitness_values, offspring_fitness))
        sorted_indices = np.argsort(combined_fit)
        return combined_pop[sorted_indices[:self.population_size]], combined_fit[sorted_indices[:self.population_size]]

    def _update_best(self, offspring, offspring_fitness):
        for i, fitness in enumerate(offspring_fitness):
            if fitness < self.best_fitness_overall:
                self.best_fitness_overall = fitness
                self.best_solution_overall = offspring[i]

    def _update_archive(self, population, fitness_values):
        combined = np.column_stack((population, fitness_values))
        new_archive = []
        for sol in combined:
            already_present = any(np.allclose(sol[:-1], arch[:-1], atol=1e-6) for arch in self.archive)
            if not already_present:
                new_archive.append(sol)
        new_archive.sort(key=lambda x: x[-1])
        return np.array(new_archive[:self.archive_size])
2025-06-24 07:12:46 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:13:25 INFO Run function 13 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:13:25 INFO FeHistory: [1227980.53008735 1296484.03253916 1417285.08180567 ... 1665568.71344724
 1583022.8357391  1776618.05370888]
2025-06-24 07:13:25 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:13:25 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:22:35 INFO Run function 13 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:22:35 INFO FeHistory: [1413042.37506109 2158661.33953312 2884919.5101145  ... 1391465.90187283
 1413843.00055488 2715111.15648651]
2025-06-24 07:22:35 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:22:35 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:22:38 INFO Run function 13 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:22:38 INFO FeHistory: [2979747.83618885 1700119.20165078 2111977.55720382 ...  487522.86319759
 3299385.80188252 1502813.14445837]
2025-06-24 07:22:38 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:22:38 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:23:25 INFO Run function 13 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:23:25 INFO FeHistory: [1491923.67574267 1224992.7027471  1173911.29070372 ... 2526101.24422757
 1653745.08100351 3368644.20650423]
2025-06-24 07:23:25 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:23:25 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:24:23 INFO Run function 18 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:24:23 INFO FeHistory: [244353.81769605 145616.66011241 176759.08550334 ...  20094.63048944
  27522.79104984  11395.61656577]
2025-06-24 07:24:23 INFO Expected Optimum FE: -5000
2025-06-24 07:24:23 INFO Unimodal AOCC mean: 0.1579
2025-06-24 07:24:23 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:24:23 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 07:24:23 INFO AOCC mean: 0.0526
2025-06-24 07:24:23 INFO Weighed AOCC mean: 0.0158
2025-06-24 07:27:09 INFO Run function 18 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:27:09 INFO FeHistory: [186680.93926235 202147.52354098 180420.02888391 ...  23900.41753816
   7910.4554601   19345.93539609]
2025-06-24 07:27:09 INFO Expected Optimum FE: -5000
2025-06-24 07:27:09 INFO Unimodal AOCC mean: 0.1527
2025-06-24 07:27:09 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:27:09 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 07:27:09 INFO AOCC mean: 0.0509
2025-06-24 07:27:09 INFO Weighed AOCC mean: 0.0153
2025-06-24 07:27:14 INFO Run function 18 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:27:14 INFO FeHistory: [127039.45639013 145116.49987668 158287.56876932 ...  16633.34729417
  24788.45507047  32148.42004503]
2025-06-24 07:27:14 INFO Expected Optimum FE: -5000
2025-06-24 07:27:14 INFO Unimodal AOCC mean: 0.1526
2025-06-24 07:27:14 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:27:14 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 07:27:14 INFO AOCC mean: 0.0509
2025-06-24 07:27:14 INFO Weighed AOCC mean: 0.0153
2025-06-24 07:27:57 INFO Run function 18 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:27:57 INFO FeHistory: [ 96902.6329292  140421.26542567 125430.64907942 ...  14599.08615526
  28792.51648767  35450.18652592]
2025-06-24 07:27:57 INFO Expected Optimum FE: -5000
2025-06-24 07:27:57 INFO Unimodal AOCC mean: 0.1519
2025-06-24 07:27:57 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:27:57 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 07:27:57 INFO AOCC mean: 0.0506
2025-06-24 07:27:57 INFO Weighed AOCC mean: 0.0152
2025-06-24 07:28:45 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:28:45 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:28:45 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:28:45 INFO --- GNBG Problem Parameters for f6 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -186.864053
  Lambda (Curvature): [0.05]
  Mu (Asymmetry/Depth): [0 0]
----------------------------------------
2025-06-24 07:28:45 ERROR Can not run the algorithm
2025-06-24 07:28:45 ERROR Can not run the algorithm
2025-06-24 07:28:45 INFO Run function 6 complete. FEHistory len: 300, AOCC: 0.1469
2025-06-24 07:28:45 INFO FeHistory: [-183.3166742  -183.32859353 -183.33105909 -183.27335555 -183.40329581
 -183.3320528  -183.32658258 -183.4097773  -183.33669652 -183.28989019
 -183.28744805 -183.33354453 -183.29942212 -183.39768709 -183.44542549
 -183.33165983 -183.41874911 -183.35218964 -183.36618816 -183.3172341
 -183.35581307 -183.2824292  -183.35914352 -183.395773   -183.38970049
 -183.33573256 -183.43823407 -183.36789888 -183.35410928 -183.28267203
 -183.3637843  -183.28458241 -183.3818055  -183.3497745  -183.33534359
 -183.37965974 -183.40660739 -183.34364557 -183.30269065 -183.296859
 -183.32957211 -183.28804305 -183.35376678 -183.34364792 -183.35896567
 -183.35451193 -183.36393918 -183.38678388 -183.44412273 -183.35571726
 -183.27775835 -183.38794802 -183.32773547 -183.27329194 -183.33077494
 -183.32392416 -183.42174591 -183.31992151 -183.37832623 -183.32161832
 -183.35526723 -183.30377588 -183.34956302 -183.33071422 -183.38714166
 -183.38014212 -183.39579726 -183.27023354 -183.34869173 -183.40809338
 -183.34279903 -183.35498792 -183.32923478 -183.31937043 -183.37483485
 -183.35853512 -183.33525645 -183.31997864 -183.35832322 -183.29309993
 -183.35353561 -183.4195868  -183.36628839 -183.36503329 -183.35082217
 -183.34933309 -183.32894902 -183.37888838 -183.38196305 -183.42302752
 -183.33939845 -183.34152468 -183.40189291 -183.3651087  -183.34287091
 -183.27516231 -183.37932812 -183.33807617 -183.31187844 -183.35757157
 -183.2957416  -183.32709449 -183.36228485 -183.29765151 -183.36219432
 -183.37295613 -183.29095988 -183.30119384 -183.35398185 -183.39055077
 -183.39751803 -183.39269218 -183.41644373 -183.3583046  -183.27526599
 -183.32052972 -183.39741137 -183.27017199 -183.38309142 -183.33575745
 -183.34831163 -183.36753447 -183.39237473 -183.33770948 -183.33152539
 -183.31943775 -183.29707523 -183.35198656 -183.36326251 -183.36265991
 -183.4151041  -183.34817824 -183.34027533 -183.35118714 -183.3363972
 -183.37728702 -183.30339404 -183.31772037 -183.33448623 -183.36225717
 -183.39709516 -183.29352773 -183.29194366 -183.34733309 -183.39037485
 -183.3345995  -183.41481716 -183.33322626 -183.37998497 -183.32509137
 -183.31793147 -183.36187364 -183.37072128 -183.30358827 -183.26218656
 -183.42402781 -183.30101584 -183.30264252 -183.36863289 -183.39683379
 -183.43022948 -183.32765212 -183.30919678 -183.28123825 -183.31713812
 -183.37449927 -183.32726021 -183.30323288 -183.32974738 -183.39066333
 -183.38425351 -183.37837618 -183.31139308 -183.35073966 -183.28361336
 -183.37225273 -183.31496431 -183.41138354 -183.39473679 -183.36674153
 -183.39666352 -183.29962529 -183.43249899 -183.40819351 -183.30712671
 -183.32807055 -183.32346595 -183.43067322 -183.3230337  -183.44987734
 -183.33995586 -183.26053902 -183.35320545 -183.39902741 -183.40125857
 -183.33029284 -183.31880752 -183.29536253 -183.23945285 -183.3395572
 -183.42238542 -183.3927185  -183.39629062 -183.36099922 -183.36127488
 -183.29103319 -183.40169342 -183.46029316 -183.32956553 -183.39230729
 -183.28761389 -183.33914815 -183.37382124 -183.30149768 -183.36242683
 -183.39583142 -183.36370057 -183.35935456 -183.37341405 -183.35519334
 -183.32125279 -183.30146697 -183.28849636 -183.40539645 -183.40881073
 -183.280252   -183.34019176 -183.33230091 -183.40601754 -183.32464363
 -183.39415029 -183.36282505 -183.27575985 -183.30814017 -183.30724493
 -183.30214615 -183.36882369 -183.34972469 -183.34157116 -183.32037716
 -183.4213287  -183.30602997 -183.36350184 -183.33242241 -183.35540751
 -183.40651135 -183.31567941 -183.33006124 -183.3055028  -183.34880442
 -183.36772428 -183.32820632 -183.31794249 -183.30649447 -183.33107259
 -183.36480832 -183.33040323 -183.4450821  -183.3350907  -183.31901546
 -183.28321759 -183.46721682 -183.37745293 -183.30734128 -183.30079166
 -183.2823256  -183.41424805 -183.38455525 -183.38086697 -183.42829071
 -183.33627535 -183.34946132 -183.31690762 -183.28144167 -183.39344757
 -183.37401183 -183.35787606 -183.34782867 -183.42202032 -183.33000082
 -183.42846875 -183.45326127 -183.35473893 -183.28209159 -183.37384896
 -183.3679603  -183.29409023 -183.35433966 -183.28736085 -183.3730644
 -183.36814778 -183.36681291 -183.34775123 -183.32005854 -183.42069705
 -183.31213934 -183.31026454 -183.34124819 -183.31440391 -183.33045166]
2025-06-24 07:28:45 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:28:45 INFO Good algorithm:
Algorithm Name: AdaptiveHybridOptimizer
import numpy as np
import random
from scipy.optimize import minimize

class AdaptiveHybridOptimizer:
    """Hybrid algorithm combining Differential Evolution (DE), Gaussian Processes (GP), and Simulated Annealing (SA) for multimodal optimization."""

    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = budget
        self.dim = dim
        self.lower_bounds = np.array(lower_bounds)
        self.upper_bounds = np.array(upper_bounds)
        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # DE parameters
        self.population_size = 10 * self.dim
        self.F = 0.5  # scaling factor
        self.CR = 0.9  # crossover rate

        # SA parameters
        self.T0 = 100.0  # initial temperature
        self.alpha = 0.95  # cooling rate

        # GP parameters (simplified for demonstration)
        self.gp_samples = 10 # number of samples for GP exploration


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        fitness = objective_function(self.population)
        self.eval_count += self.population_size
        self.best_solution_overall = self.population[np.argmin(fitness)]
        self.best_fitness_overall = np.min(fitness)


        while self.eval_count < self.budget:
            # Differential Evolution step
            offspring = self.differential_evolution(self.population, fitness)
            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            #Simulated Annealing step - focus on best solution from DE
            sa_solution, sa_fitness = self.simulated_annealing(self.best_solution_overall, objective_function, self.T0, self.alpha)
            if sa_fitness < self.best_fitness_overall:
                self.best_solution_overall = sa_solution
                self.best_fitness_overall = sa_fitness


            # Gaussian Process exploration (periodically)
            if self.eval_count % (self.population_size * 2) == 0:
                 self.gaussian_process_exploration(objective_function)


            # Combine and select
            combined_population = np.vstack((self.population, offspring))
            combined_fitness = np.concatenate((fitness, offspring_fitness))
            indices = np.argsort(combined_fitness)
            self.population = combined_population[indices[:self.population_size]]
            fitness = combined_fitness[indices[:self.population_size]]

            self.best_solution_overall = self.population[np.argmin(fitness)]
            self.best_fitness_overall = np.min(fitness)


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def differential_evolution(self, population, fitness):
        offspring = np.zeros_like(population)
        for i in range(self.population_size):
            a, b, c = random.sample(range(self.population_size), 3)
            while a == i or b == i or c == i:
                a, b, c = random.sample(range(self.population_size), 3)
            mutant = population[a] + self.F * (population[b] - population[c])
            trial = np.clip(np.where(np.random.rand(self.dim) < self.CR, mutant, population[i]), self.lower_bounds, self.upper_bounds)
            trial_fitness = objective_function(trial.reshape(1, -1))
            if trial_fitness < fitness[i]:
                offspring[i] = trial
            else:
                offspring[i] = population[i]
        return offspring

    def simulated_annealing(self, initial_solution, objective_function, T0, alpha):
        current_solution = initial_solution.copy()
        current_fitness = objective_function(current_solution.reshape(1, -1))
        best_solution = current_solution.copy()
        best_fitness = current_fitness

        T = T0
        while T > 1e-6:
            neighbor = current_solution + np.random.normal(0, T, self.dim)
            neighbor = np.clip(neighbor, self.lower_bounds, self.upper_bounds)
            neighbor_fitness = objective_function(neighbor.reshape(1, -1))
            delta_e = neighbor_fitness - current_fitness
            if delta_e < 0 or random.random() < np.exp(-delta_e / T):
                current_solution = neighbor
                current_fitness = neighbor_fitness
            if current_fitness < best_fitness:
                best_solution = current_solution.copy()
                best_fitness = current_fitness
            T *= alpha
            self.eval_count += 1
            if self.eval_count >= self.budget:
                break
        return best_solution, best_fitness

    def gaussian_process_exploration(self, objective_function):
        # Simplified GP exploration (replace with a proper GP library for better performance)
        # This example just generates random samples around the current best
        for _ in range(self.gp_samples):
            sample = self.best_solution_overall + np.random.normal(0, 20, self.dim)  # Adjust variance as needed
            sample = np.clip(sample, self.lower_bounds, self.upper_bounds)
            fitness = objective_function(sample.reshape(1,-1))
            self.eval_count +=1
            if fitness < self.best_fitness_overall:
                self.best_solution_overall = sample
                self.best_fitness_overall = fitness

2025-06-24 07:28:45 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:28:45 INFO Run function 6 complete. FEHistory len: 300, AOCC: 0.1476
2025-06-24 07:28:45 INFO FeHistory: [-183.37741429 -183.35280796 -183.33338499 -183.32156087 -183.35793659
 -183.41401187 -183.37752061 -183.38936177 -183.32496002 -183.32188978
 -183.35437562 -183.32709888 -183.32579546 -183.38744683 -183.28769337
 -183.34365977 -183.29423234 -183.31331174 -183.43042817 -183.38849823
 -183.3574298  -183.36622533 -183.31990554 -183.33813279 -183.33951822
 -183.33993952 -183.31056451 -183.3337556  -183.38161333 -183.38753413
 -183.32536143 -183.25798452 -183.272064   -183.38610873 -183.33766805
 -183.30042359 -183.31063308 -183.36579417 -183.36405168 -183.30417486
 -183.34917123 -183.45820292 -183.32809551 -183.35704157 -183.3013882
 -183.35455921 -183.33422476 -183.40888027 -183.34935625 -183.32239457
 -183.39228302 -183.29508322 -183.29252079 -183.44678052 -183.43469759
 -183.33934489 -183.39911078 -183.30292533 -183.36391853 -183.31199863
 -183.34620465 -183.32881811 -183.35719283 -183.3545161  -183.34337551
 -183.30462731 -183.32084449 -183.3147366  -183.45269352 -183.37660995
 -183.3667346  -183.32083117 -183.35113587 -183.30190845 -183.30790388
 -183.36061721 -183.35145245 -183.2925733  -183.3485822  -183.34932383
 -183.39689719 -183.32907883 -183.36953269 -183.40644907 -183.31722666
 -183.319557   -183.34721247 -183.43858169 -183.27123627 -183.28700926
 -183.35116277 -183.30735138 -183.26862811 -183.35591461 -183.26638838
 -183.34452965 -183.43730056 -183.39528033 -183.39187088 -183.37498448
 -183.4346554  -183.25436698 -183.29545102 -183.32364678 -183.33796246
 -183.34143615 -183.36414961 -183.28642956 -183.27162097 -183.31053043
 -183.37751803 -183.37463696 -183.29341485 -183.32147093 -183.40426808
 -183.29699831 -183.43233864 -183.41727393 -183.39028819 -183.34845627
 -183.27152446 -183.44842491 -183.2706411  -183.33721295 -183.34281267
 -183.35188625 -183.33117674 -183.23503857 -183.39523974 -183.32977676
 -183.33522169 -183.27222688 -183.35395274 -183.31210008 -183.38584484
 -183.35650243 -183.39023636 -183.37120215 -183.3966309  -183.3506272
 -183.33573627 -183.31183754 -183.34985784 -183.27622185 -183.31753151
 -183.3179525  -183.3638577  -183.33325702 -183.36530378 -183.3239776
 -183.33321546 -183.34504522 -183.43603601 -183.34690697 -183.32783323
 -183.41701866 -183.31991508 -183.36996313 -183.29946835 -183.36607932
 -183.25199984 -183.36959169 -183.30900848 -183.29894913 -183.38188703
 -183.31795115 -183.37546303 -183.33123107 -183.36989455 -183.29061769
 -183.36578267 -183.40819182 -183.41136886 -183.36279027 -183.33578857
 -183.36334159 -183.28015625 -183.30655993 -183.36966719 -183.40163402
 -183.2848035  -183.38277259 -183.50365028 -183.29912695 -183.4091419
 -183.3971866  -183.34054496 -183.40048341 -183.40072413 -183.33553049
 -183.35683826 -183.31799302 -183.30284217 -183.39053682 -183.40870076
 -183.32822112 -183.3756825  -183.38465715 -183.30149535 -183.32022126
 -183.42314222 -183.28779285 -183.40724189 -183.33003736 -183.37859845
 -183.38227299 -183.32436943 -183.34243734 -183.37683423 -183.4146805
 -183.46435257 -183.37130179 -183.36200469 -183.2647417  -183.35268882
 -183.3171106  -183.52118476 -183.34339734 -183.37326631 -183.36922292
 -183.300513   -183.42146673 -183.33522208 -183.45182731 -183.33717829
 -183.34277451 -183.39193578 -183.3761223  -183.41815692 -183.29570777
 -183.29012462 -183.2484474  -183.3592061  -183.37347471 -183.32159912
 -183.387144   -183.34292083 -183.37033562 -183.31917986 -183.39541998
 -183.29766966 -183.34273448 -183.32796079 -183.361438   -183.38151847
 -183.38742328 -183.41890037 -183.33644177 -183.33249295 -183.31285086
 -183.29512653 -183.28460513 -183.43699996 -183.32860287 -183.30725035
 -183.29451889 -183.3396582  -183.39407468 -183.34355603 -183.31248058
 -183.38656312 -183.29761301 -183.33118494 -183.3283086  -183.32486103
 -183.38769881 -183.35504213 -183.36004151 -183.36454122 -183.30681496
 -183.3516716  -183.40383738 -183.43315509 -183.37804092 -183.38308401
 -183.32480132 -183.40444908 -183.42135285 -183.37663637 -183.33879678
 -183.36642513 -183.40011106 -183.33657701 -183.41015795 -183.31745679
 -183.40109496 -183.25935762 -183.35046894 -183.32109524 -183.3016092
 -183.36228711 -183.34768612 -183.40606388 -183.42237647 -183.37194025
 -183.49322699 -183.31684838 -183.39918941 -183.367247   -183.40590337]
2025-06-24 07:28:45 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:28:45 INFO Good algorithm:
Algorithm Name: AdaptiveHybridOptimizer
import numpy as np
import random
from scipy.optimize import minimize

# Name: AdaptiveHybridOptimizer
# Description: A hybrid evolutionary algorithm combining Differential Evolution, Gaussian Processes, and local search for efficient multimodal optimization.

class AdaptiveHybridOptimizer:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.population_size = 10 * self.dim
        self.archive_size = 100
        self.archive = []
        self.population = None
        self.F_scale = 0.5
        self.CR = 0.9 #crossover rate for DE
        self.exploration_rate = 0.8 # Initial exploration rate


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        fitness = objective_function(self.population)
        self.eval_count += self.population_size

        self.best_solution_overall = self.population[np.argmin(fitness)]
        self.best_fitness_overall = np.min(fitness)

        while self.eval_count < self.budget:
            offspring = self.generate_offspring()
            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            self.update_archive(offspring, offspring_fitness)

            combined_population = np.concatenate((self.population, offspring))
            combined_fitness = np.concatenate((fitness, offspring_fitness))
            indices = np.argsort(combined_fitness)
            self.population = combined_population[indices[:self.population_size]]
            fitness = combined_fitness[indices[:self.population_size]]

            self.best_solution_overall = self.population[np.argmin(fitness)]
            self.best_fitness_overall = np.min(fitness)

            #Adapt exploration rate based on progress
            if self.eval_count > self.budget * 0.2 :
                progress = (self.best_fitness_overall - np.min(fitness))/self.best_fitness_overall if self.best_fitness_overall != 0 else 1.0
                self.exploration_rate = max(0.1, self.exploration_rate * (1 - progress) + 0.1)  #Reduce if good progress.

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'archive_size': len(self.archive)
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def generate_offspring(self):
        offspring = np.zeros((int(self.population_size * self.exploration_rate), self.dim))
        for i in range(int(self.population_size * self.exploration_rate)):
            #Global Exploration using DE
            a, b, c = random.sample(range(self.population_size), 3)
            offspring[i] = self.population[a] + self.F_scale * (self.population[b] - self.population[c])
            offspring[i] = np.clip(offspring[i], self.lower_bounds, self.upper_bounds)

        #Local Exploitation using local search around best solutions
        remaining_offspring = int(self.population_size * (1 - self.exploration_rate))
        if remaining_offspring > 0:
          local_offspring = np.zeros((remaining_offspring, self.dim))
          for i in range(remaining_offspring):
              best_index = np.argmin(np.linalg.norm(self.population - self.best_solution_overall, axis=1))
              x0 = self.population[best_index]
              res = minimize(lambda x: objective_function(np.array([x])), x0, bounds = list(zip(self.lower_bounds, self.upper_bounds)), method = "L-BFGS-B")
              local_offspring[i] = res.x
          offspring = np.concatenate((offspring, local_offspring))
          
        return offspring


    def update_archive(self, offspring, offspring_fitness):
        for i in range(len(offspring)):
            if len(self.archive) < self.archive_size:
                self.archive.append((offspring[i], offspring_fitness[i]))
            else:
                worst_index = np.argmax([f for _, f in self.archive])
                if offspring_fitness[i] < self.archive[worst_index][1]:
                    self.archive[worst_index] = (offspring[i], offspring_fitness[i])
2025-06-24 07:28:45 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:28:45 ERROR Can not run the algorithm
2025-06-24 07:28:45 ERROR Can not run the algorithm
2025-06-24 07:28:46 INFO Run function 13 complete. FEHistory len: 300, AOCC: 0.0000
2025-06-24 07:28:46 INFO FeHistory: [1983659.6616964  2927404.85986822 2239894.24734582 1935826.24193454
 3295818.72387712 1576966.09947226 1509694.21177098 3119175.93062234
 2185932.50340455 3169307.0361978  2984255.53332592 1568937.25644961
 3013893.40989879 2247368.22447935 1797477.05223508  657699.63873751
 1230268.70095627  415026.53895493 2760223.96478587 1076454.68348419
 1856024.51213417 1398531.53403743 3103551.31229742 2986404.86988476
  730041.43497188 5000884.94981328  989801.56601181 2276805.65509475
 2100749.36897352  985466.55461976 1566335.83131905 2158916.80081213
 1651422.00899354 3749937.27299726 3958837.3029927   309195.16348074
  931158.42577083 1078399.81801572  686266.00613578  824445.23321624
 3756440.76726249 2689817.47754713 2592163.01526314 1253039.43054368
 1546840.41823241  901024.07209817 1003667.07880555 2850242.72177042
 1296239.98543105 2407419.83033455 2378914.99163818 1724805.55286533
 1311981.95132387  358315.30552321 2121019.55553538 2214464.71366173
 2906989.76428376 2785810.67350504 2851173.28120272 3784360.16578698
 1146373.3277135  2219661.87028154  589490.64106624 1711918.18039646
 2204489.84990828 1723544.20086994 1827754.73138419 2957250.53963587
  969645.01840578 3191436.51390685 1342983.45667221 2015571.62140403
 3124299.92604811 2129755.01479995 1294727.29780542 1304480.20939351
 1784241.28792341 2139310.8740579   575515.9296259  2248023.89107312
 1430377.28171319 2877061.17273341 3538630.87975045  824985.89441698
 1100416.19148973 2394840.66615856 1642238.26147315  500693.13012547
 3036403.14550621  850193.39792433 3150768.76753522 1978919.79633999
 1755189.83107085 2566222.27725099  666455.64938988 4245479.6436341
 1400612.44721361 1119388.71063394  875231.80999215 2631503.17916513
 1030939.84769841 3473326.34749343 1479848.21620184 1259899.59956478
  777114.57071176 2549475.65703856 2501157.41676734 1416557.49893186
 3051596.36331077  978334.67922112 1990876.71432957 1987637.01571634
  968650.16163874  729577.65240841 1196815.60703557 1984983.51098763
  874043.6671379  1771417.44482977 1435189.51028433 1260828.62625491
  628634.86304208 1183079.50111719 3058772.77803816 2484181.01968915
 1616981.78577424  830856.40597289 2548936.07735986  597197.48174784
 1663138.19811696 1303222.469815   1505488.7935793  1482566.14173951
 2477658.5178003  2636398.02815049 1312517.25656232  380932.55900177
 1762356.62783343 2468678.65493793 1936312.52728207 2358952.24476998
 2014590.59587701 1497925.87227477 1043890.129965   1725998.14373216
 1391593.09887048 1163041.59818979 1688362.79101865 1549757.77842114
  859243.43517951 4043740.75751936 1681845.61919284 2039591.89751577
  633914.56586883  211337.34258919 1911404.47652704  953179.13995509
  496557.57651815 2175591.88031262 3272534.97418066 1769015.64344065
  704451.66892614 1717637.2410813  2603055.11727429  594485.01149975
  973580.09498994 2998877.87299257 2741521.42131401 3182659.02135419
 3342476.90015122 1936980.94717485  749649.15745331 2067874.15742593
 3546390.20337065 3732967.27746043 2155929.62806365 1888003.15964858
  486981.83869908 5139089.54606216 1721645.14089908 1679186.51609879
 1106665.29759552  504681.14605027 3105630.58791775 2059053.75471594
 3941575.18625732 3394913.17828849 2346824.82851505 2383285.27114702
 1644096.82062099 1327319.09004126 1424538.23228711  492800.15736667
  500655.19805153 1225454.69262963 2918322.03999095 3405594.01359387
 1520384.24746612 1317232.55969283  647247.41543872 5018702.99939099
 1053298.54158976 2625675.35639983 2433209.75468519 1991009.13953222
 1872767.28466937 1720947.38174908 1543465.05698612  718964.04923879
 1810021.00985766 2193769.201828   1319522.24111566 1470861.53128848
 1355928.7702426  3251057.30539122 1144773.80727315 2941064.05405712
 1268088.24126492 1914890.94763817 1338715.54347825 1075736.9387279
 2040819.14448548 2048444.27794526 1889474.17407997 1692457.64111408
 3954254.37581345  305249.0701871  1628363.23582664 2981006.27955293
 2563093.11696966 1381991.29245373 1074515.77961794 1260887.81485957
 1694357.43936985  861160.08686354  919563.14704312  934637.70312883
  877879.80626965 3532918.67208945 2272054.85312444  666008.1810549
 4504685.67047871 2642487.92099615  349266.78004077 1127528.1621445
 1627623.90169906 1617810.17115303 2083816.39141015  948500.74240547
 2845189.40008799 3404426.94912116 2208182.2375932  4467753.5997224
 2135805.41021055  407453.75447798 2073558.92878497 1927935.03761283
 1150914.48293144  771914.01042919 3729669.50806631  296943.9734865
 1021949.5877738  2569166.11229235  514688.61381056 3528793.13695685
 2004300.69645275 4814881.81927295 2026068.77102317 2217279.22618227
 1496107.29001254 1380546.81171608 1945797.31773694 1328697.32026904
 2371347.26376152 1332441.768354   3016486.6947618  2102182.68265845
  844815.68016705 3866858.69659901 2825450.59558268 1447186.26437158
 1592779.22952762  987434.28591265 2146256.34183241 2256772.12118127
 2121478.57930037 3724701.26265792  725514.39870405 1129016.36470397
 1366064.61351101 2841094.61529465 2994991.66052373 3273205.98422444
 1102826.57193288  469229.02671028 1812215.20894006  312448.70064987
 3011112.5599603  1609414.00811468 1242153.80926703 1275527.76101385]
2025-06-24 07:28:46 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:28:46 INFO Run function 13 complete. FEHistory len: 300, AOCC: 0.0000
2025-06-24 07:28:46 INFO FeHistory: [1070301.2286222   957543.40043223 2197157.26137116  681335.61191962
  573298.46753824  957314.01624962 2090491.37294724 3914121.90086013
 2118082.57000559  826212.73541698 1442857.69711609 1028531.98616952
 1260735.65612174 1978981.29632347  706677.9041736  1461887.1407691
 1537958.77410334 2467236.11869823 1166590.15852445 1334164.22663379
 2397654.38518555  763425.61963494 2378729.42838953 1741650.05319063
 2213274.68763913 1080770.19895267 1138851.52364347 1069627.90485967
 3314201.7608555  1048323.3742422  3461002.19646429 1559106.62680016
 1987375.96595075 1235361.06014051 3250622.29201774 1050290.24859296
 1189642.28958045 2671773.59612385 2435620.30540165 1779389.36025286
 1238960.65209045 1521415.27687333 3168487.16801223 1536134.44106767
 1987315.99642318 4418371.37945212 1262803.23811217 2528150.91283669
 1947402.04595994 3639029.1830042  1358559.58747002 2667602.79059755
 3383634.76930308 1873675.44878119 1072356.73242995 2746928.28106434
  545412.73497203 1565075.34668944 2766975.0126229  1173205.76949792
  469222.69727427 5251685.17362787 1011081.30650374 2022621.57892825
 1069097.37387098 1817851.05371996  596732.92478709 3589924.12938346
 2763359.09154479 2218630.67866899 1977158.30243567 6054005.50890872
 2707873.36305403  289193.17248715 1427254.45877103 1266118.9968103
 1468443.64577444 2019489.869058   1827708.08981577 3792667.79777656
 1086836.49483046 1139666.31951618 3457769.69236321 2625665.8342179
 4139758.96590052 2686376.99428954 1828068.28007144 1191384.522117
 1247852.4270449  2400048.68961867  669201.10118797 2715436.7772419
  906844.96717016 1434302.51455234 2320746.67037616  989152.85162696
 2828250.71871476 3141204.54350359 3727928.71772304 2488374.17542426
 1164623.66739171 1612943.41814917 2281629.87598624 1536110.51250236
 1726731.7933887  3170139.21817254  872074.4379505  2469682.5903881
 3654107.38497753 2652641.08236337 4218482.36010436 3226615.39945504
 2534152.56350391 3276259.82861395 1234931.26982658  904507.28196721
 2498335.92281409 2467266.98126398 1498216.89405826 2011427.57459537
 3388873.7716015   424853.19237015 1926741.67126391 1482423.19064106
 3126254.78284404 3767216.70626815 1092760.82007798 1078024.66889465
 2275615.81832179 3762247.71404962 2151723.99050911 1314093.34455518
  206703.29992557  252838.10563366 1696906.5977977  3054398.54378042
 1578292.41366357 1779521.85150942 1318817.51015703 1529783.76221198
 3232677.37979049  415715.0895962   844374.33032701 3730109.84676699
  760821.87138412 2889576.33665154 1920925.13774175  946842.43075551
  735247.56241309 2541133.90615617 3020789.87646875 1865210.21696869
 2378102.35484202 1882855.4690184  2639498.62435425 3188909.04454261
  931657.98545375  676882.4690684  1660405.04825466  945765.96488751
 3285167.68765802 1244850.72478383 5600395.90432612 1332170.58513192
 1232395.61990474 1899707.75471251 1287348.95976946 1896188.42523026
  912282.72990275 1998823.59029255 4902450.27833787 1611056.13385228
 1226211.03550171  567378.75067882  790407.26445883 1532323.06833124
 1383959.0505878  1673131.60075198 3141642.02470806 3424086.36729685
 5941374.84925308 3782356.68341008 3443248.22159436 2649974.79280179
 2328333.08804739 1791067.23244728 2208571.49729266 1016800.0911016
 3196565.07098186 2446610.85097922 3185354.98236615  935077.06956427
 2119066.98986928 1879261.13076227 2131832.25999764 1234152.55372849
 2640350.10796391 1808508.71273012 2595411.71930477 3894529.92400074
 2251323.62898052 1509602.99718848 3685871.72732898 1372270.40229656
 3970529.65498274 2482542.87281995 2733537.81316555 1726974.90362861
 4036178.15373366 6042471.95092165 2585996.54251383 2321570.54041491
 1138540.10510112 2819045.50162494 1056547.51882422 2593509.71926126
 2352207.21007422  982708.39635138 1169822.13387296 3628220.79133625
  804702.67771204 3837156.75522861 1978673.82746682 3224995.95873058
 1125442.62910859 2203033.72580437 2540641.50320939 2228860.80500252
 1456540.75608024 1499129.90335817 2732518.11958503 2319800.84192239
 1309691.459249   3315379.92580099 1532004.91018407  401879.21284487
 1379257.04449824 1731819.35982509 2738480.97610606 2171756.03147634
 1637034.86480035 2283510.39666334 1599812.06310158 1736587.88732073
 1194790.22999799  632679.87839005 1071490.39959314 2389286.02221998
  944169.51062198 1979174.10979526 3183671.54404472 1252940.76597842
 2253311.18675468 1571103.63772006  668968.33236843 2005108.1266999
 1597515.0761295  1478718.01795294 2001879.96538299  771834.98786466
 3127251.11004486 1524882.55890589 1245184.40449675 1203419.81801283
 2269857.04370392 1157253.43661626 3568222.58785928 2207110.92093486
 1534437.97334412  948554.26817944 1735323.40996762 1217880.90060812
 1945536.70635123  513669.46264593  737014.95789331 1041523.88823589
  643844.85907805 2478533.32700408 2481528.1852591  4467779.30982404
 2350995.61354318 2042426.7528667  1341519.17900368 1249346.02085368
 1488852.06521577 1468778.17427967 3490616.80784941 2776063.14288884
 1449594.54499373 1096376.06261583 2857443.16735534 1879183.91991019
 2073647.21544154 5484540.78732808 1236816.46974164 1353914.10574716
 1248473.04288994 1418937.01159529 1958847.07092542 1803645.15102426]
2025-06-24 07:28:46 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:28:46 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:28:46 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:28:46 ERROR Can not run the algorithm
2025-06-24 07:28:46 ERROR Can not run the algorithm
2025-06-24 07:28:46 INFO Run function 18 complete. FEHistory len: 300, AOCC: 0.0000
2025-06-24 07:28:46 INFO FeHistory: [160493.13312316 178123.68597082 105236.29198859 142058.83597693
 113286.05149426 128803.27324288 164187.92296215 118726.07396909
 180815.38759101 179767.06912684 112650.31380522 126411.84030737
 162924.96259655  70110.1164274  176688.94147621 141899.80516757
 121149.85112831 204663.38391324 223402.75020412 126756.12193206
 118918.36366493 160425.04979388 132474.93888029  57714.04254496
 119088.15277987  98693.55897907 191722.53290468 102108.94354013
 144394.86928009 133079.23916984 187829.82748737 136315.91058733
 128684.19696501 144989.78127728 178908.88096911 111983.29990806
 171273.2248915  200413.68670482 141745.85523764 106068.11432028
 173355.62537339 182855.59617875 122793.26038152 144509.43604209
 154018.97656267  95436.02076425  78157.42455023 151712.4146972
 205605.33297228 155096.31346528 102533.39385113 187937.14601882
 147469.22574042 136386.42273399 130205.41774282  67112.85642411
 107273.21827444 226962.63992464 105589.57540787  84905.57767504
 153890.08627438 150161.17558365 123257.52102077 152918.65124942
 197435.45096982 161539.71824872 119396.56310848 157768.1197685
  88367.17298816 137071.55276032 200116.45992577 110597.11650443
 141237.18684352 197784.70047318 144387.16051555 142227.66743285
 161713.54227729 156196.14610561 109933.86003752 111928.1981865
 193593.49161093 166119.54309686 185301.05449662 181348.9602983
 177952.2059237  143908.09679001 212819.87121432 101159.87892364
 138582.30421968 142954.54351174 121414.13006844 193945.8785043
 153544.17242693 170597.62182052 213139.52372088 134573.60354108
 135318.20071898 277291.97017054  85823.57358022 181968.04988232
 138841.46699477 163292.24912818 162393.22308336 102326.93464429
 142242.97072645 227712.59214777 153749.29279652 184395.42338606
 234613.03471813 111494.79758606 158080.07992205 159506.6665555
 157176.86961769 130049.58539082 127261.30707459 148935.10848165
 183081.81922358 173918.73070933 124477.23554905 102398.03004968
 170090.67446028 144385.91961037 138493.60143781 159675.21060033
 195232.69245403 152312.86160857 156732.92025874 200607.95567173
 101256.74303389 144681.25278532 104271.62440827 143939.22209377
 134587.56568109 164933.47387531 107348.25170119 130977.99669461
 133965.47995905 155508.10111379 181209.25262779 140966.23276646
 115232.50759386 149441.58520441 117785.27929598 161372.00869601
 153525.73919218 130576.44838225 168831.46826278 256446.79389251
 123656.19615128 213549.95477229 155222.92282871 134631.85830666
 167391.36658581 115317.85091249 156309.13083348 163588.21860931
 119488.76882909 160668.42218586 205025.23704392 196292.79411057
 116318.91341726 120514.15934504 157880.99837303 164758.12287529
 161521.66517619 138604.97635106 126422.49137431 172565.50383388
 182454.14121268 130241.23030574 190858.05343863 125833.71568931
 204369.89892342 163248.96997176 218097.45251736 126360.72823091
 134071.91439916 191738.28240163  96411.41015586 113548.46684606
 178125.52197131 127102.74770449 160757.04040259 115502.28052233
 141645.57084529 161456.75250121 124318.77504193 187661.2437502
 138087.18073152 122937.88148405 118353.12195459 102868.12341207
 175847.69977679 133091.30008777 124619.06567811 152918.96844278
 139353.20119928 200765.03558854 103154.59054062 123991.18429812
 165816.85912108 122445.23311627 174382.98684327 156075.8948617
 167902.01347379 148031.69726192 124241.00604974  71857.02551428
 168006.28292091 168545.1883234  221561.36786388 159033.90424306
 154605.35099076 182642.67024643 121145.00004719 177634.20023545
 181649.55961733 116919.33585661 156648.15959059 150450.68210342
  96157.19325807 104470.78810269 106020.18740651 122532.48104068
 132511.20700701 228613.90243165 171046.06316332 145246.30444429
 144488.66558249 158291.2155336  172804.78963253 104576.38521485
 158798.83172869 197038.97281738 170812.94734621 148226.09510788
 153486.14278305 161494.63556177 107094.37676117 151445.86504146
 147883.28229456 156275.75070505 114412.10202286 145186.4234615
 205731.0394414  155926.84649235 202112.63933537 152984.81327279
 110215.37342516 183711.27381076 133593.96992393 148012.70806806
 169976.41462924 163708.7324358  125149.59913528 164243.32203722
 157770.47654506 153033.71568499 147212.36863151 176200.91433632
 195663.64100475 148846.48065833 110342.47992906 109748.53750992
 202244.7493731  258556.58075387 181811.02625654 117133.05062457
 131472.11533456 170782.25328349 159246.40629917 153813.42011543
 159970.61697045 116835.83893161 233466.79605981 119708.13929981
 145058.12502756 117980.3104435  148386.06376846 138054.046222
 131441.35472393 142840.58846108 194037.28711116 156982.56999098
 194064.2883758  195032.04806235  92572.7981109  164242.8148877
 136892.04028131 155655.42171708 148082.40967048 124736.68463014
 174456.92058976 149256.89814005 132571.67834734 242488.73482149
 107512.18910892 178530.71881192 168053.2001195   70085.03197158]
2025-06-24 07:28:46 INFO Expected Optimum FE: -5000
2025-06-24 07:28:46 INFO Unimodal AOCC mean: 0.1469
2025-06-24 07:28:46 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:28:46 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 07:28:46 INFO AOCC mean: 0.0490
2025-06-24 07:28:46 INFO Weighed AOCC mean: 0.0147
2025-06-24 07:28:46 INFO Run function 18 complete. FEHistory len: 300, AOCC: 0.0000
2025-06-24 07:28:46 INFO FeHistory: [ 87322.40891572 120968.68557569 139880.53096903 187415.79297963
 207837.80272267 118621.62545696 212023.37983486 170149.61783499
 128597.54267084 113433.57147168  94014.65996235 155236.79587504
 153746.74028655 142239.57274359 169156.23532935 227111.55955118
 192574.44938844 140019.7544097   97579.62108463 136695.87743414
 119087.89896461 164316.51928299 115831.72151248 148452.44206826
 165003.63088676 150468.06122243 110842.30698817 234970.85995381
 113638.12148223 108641.24327616 123069.52241902 141397.60824754
 157006.79142229 132599.39279867 121338.23048876 140824.08247146
 155110.56765579 157439.35078016 157450.18408902 150480.81237606
 193960.96173698 115764.58102019 187652.2060127  162173.36090172
 119129.82896144 119047.3352982  109925.14651535  66171.74052766
 138672.3746734  201808.33497098 206390.09957503  78762.61954812
 154833.49561044 165845.38469875 157787.49528041 142456.08529684
 122595.35271212 151502.19568197 165472.38868093  98461.50783849
 166474.45284457 235421.04916882 168499.34816702 144862.08503491
 136018.78318819 116878.49648839 140986.51516519 168842.63214562
 123406.40459753 143115.02223124 170526.8226002  170907.99936903
 162483.77915467 195861.44775832 170174.35419077 106439.40657139
 139339.30172952 116916.11065469  82105.84521704 165639.66090044
 107291.51515409 173266.79450998 150644.56389126 126841.86231263
 216493.65008492 124544.24108601 189175.38723501 239955.96707433
 190953.14143368 170615.2292842  139438.03667003 193741.10998084
 102009.8499043   97366.61999882 139972.96293864 126010.23904451
 128047.86157938 118526.4937097  276217.69775312  90772.51161986
 154528.71002714 200949.94115119 133904.10834989 115987.4029081
 128274.43856993 104325.32254808 140444.29527917 204716.53743681
 136041.77479683 155576.14810988 106138.55367363 156240.78298535
 128764.05550833 142777.39650868 118402.28177935 165155.99401747
 114367.23909021 179910.89090349 181199.79404133 150182.40628991
 132958.40058092 124508.07597523 166154.57943153 156738.99472545
  81949.65342806 188288.43553661 143096.45006225 142973.63221502
 190113.31473845 141230.36890553 164162.6335114  181689.75758988
 145920.76502462 121714.79687065 111946.18811437 208226.14901401
 135482.958613   141340.10165186 224248.96254359 106105.62524181
 137176.36225242 166056.43779493  97389.99087802 129983.05911476
 127089.55314128 133779.97239039 192753.79513699 146832.78590959
 113503.08873729 152094.53517835 131475.95886585 227959.11788922
 125822.10012008 120398.80675014  98994.17129529 188630.31912135
 226579.10288167 118642.5507754  141280.77101233 159930.56248287
 140336.48213278 136060.89715658 142877.35371494 199378.05848358
 160723.0207812  142885.103283   187464.43140358 141932.98648508
 132734.76340305 166532.73903821 124551.80783143 138224.51338952
 148808.63613018 187575.11841485 160669.8906743  168867.07584429
 119185.3316065  182272.00023568 159596.07092248 106954.60548931
 127693.97553386 131907.1042118  192771.56171366 135387.51723177
 198613.44658514 136347.58523594 146948.6641717  106990.99545695
 189419.10151169  81696.28477689 100466.62377792 122242.72801938
 166398.2258061  124883.73757607 144345.55527452 136817.28279717
 230831.5748638  121491.18671599 155011.71601447 168991.64482026
 234382.30645795 235506.52932339 186151.9728972  160342.70657096
 193694.20492199 161834.1165611   80978.20394572 158802.84949269
 248469.7805022  125751.28980142 129727.4218429  138923.37413841
 126730.03531714 135306.14196807 196583.06569693 196908.537578
 252080.67470127 173245.94614665 213273.86686602 234278.89799065
 143365.16641995 126566.23727452 174923.23186009 153461.47520037
 170599.68223022 138400.78518295 144495.6826446  149609.893868
 171296.88321794 139333.51604188 171484.71958347 126240.9396483
 145521.9982069  163389.77056755 147126.54151821 208396.61715451
 164343.02592096 180211.26275117 225611.18717693 105980.50293216
 137712.75152778 108250.79944811 149765.74016218 135103.79595321
 172161.43485698 127217.68909487 207815.57433061 122596.60966082
 218622.60753595 177777.28647929 125560.14905018 108520.16006263
 210871.78275291 126942.41845956 234898.19982235 189754.21393853
 139843.11026801 178396.03153323 174698.01571964  98046.7473699
 178568.45343052 106120.18442808 266055.10218553 175031.39351172
 107799.46548034 180093.23786393 208958.42849313 110634.15731049
 203353.71619348 107604.43273901 140205.89863767  96799.21822154
 163376.84233666 168580.77977164 172287.1829586  216624.59911649
 149066.66747869  64216.72543465 213817.30029754 140175.73180838
 235951.09426944 170668.18458434  89653.69859346 134846.46384181
 114292.4820567  115172.86388462 164251.21536138 169933.36229769
 148965.90428943 121322.53121452 113259.16257165  98739.64328065
  89374.20052689 146454.696906   107279.72811897 132136.7819051
 127936.06841633 151936.77902921 154716.62358535 125815.38501476]
2025-06-24 07:28:46 INFO Expected Optimum FE: -5000
2025-06-24 07:28:46 INFO Unimodal AOCC mean: 0.1476
2025-06-24 07:28:46 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:28:46 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 07:28:46 INFO AOCC mean: 0.0492
2025-06-24 07:28:46 INFO Weighed AOCC mean: 0.0148
2025-06-24 07:28:53 INFO Run function 6 complete. FEHistory len: 100000, AOCC: 0.1597
2025-06-24 07:28:53 INFO FeHistory: [-183.34999522 -183.32442108 -183.34296625 ... -184.51377472 -184.45861468
 -184.69932688]
2025-06-24 07:28:53 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:28:53 INFO Good algorithm:
Algorithm Name: AdaptiveHybridOptimizer
import numpy as np
import random

# Name: AdaptiveHybridOptimizer
# Description: A hybrid algorithm combining Differential Evolution, Gaussian Process Regression, and Simulated Annealing for robust multimodal optimization.

class AdaptiveHybridOptimizer:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.population_size = 10 * self.dim
        self.archive_size = 200  #Increased archive size for diversity
        self.archive = []
        self.population = None
        self.F_scale = 0.5
        self.CR = 0.9 #Crossover rate for DE
        self.T = 100.0 #Initial temperature for Simulated Annealing
        self.cooling_rate = 0.98 #Cooling rate for SA

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        fitness = objective_function(self.population)
        self.eval_count += self.population_size

        self.best_solution_overall = self.population[np.argmin(fitness)]
        self.best_fitness_overall = np.min(fitness)

        while self.eval_count < self.budget:
            offspring = self.generate_offspring(self.population, fitness)
            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            # Simulated Annealing step for escaping local optima
            offspring, offspring_fitness = self.simulated_annealing(offspring, offspring_fitness, objective_function)


            self.update_archive(offspring, offspring_fitness)

            combined_population = np.concatenate((self.population, offspring))
            combined_fitness = np.concatenate((fitness, offspring_fitness))
            indices = np.argsort(combined_fitness)
            self.population = combined_population[indices[:self.population_size]]
            fitness = combined_fitness[indices[:self.population_size]]

            self.best_solution_overall = self.population[np.argmin(fitness)]
            self.best_fitness_overall = np.min(fitness)

            # Adapt parameters (example: reduce F_scale for exploitation)
            self.F_scale *= 0.99


            self.T *= self.cooling_rate #Cool down the SA


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'archive_size': len(self.archive)
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def generate_offspring(self, population, fitness):
        offspring = np.zeros((self.population_size, self.dim))
        self.F_scale = 0.5 + 0.3 * np.random.rand()

        for i in range(self.population_size):
            if self.archive:
                pbest_index = np.random.choice(len(self.archive))
                pbest = self.archive[pbest_index][0]
            else:
                pbest = population[np.argmin(fitness)]

            a, b, c = random.sample(range(self.population_size), 3)
            while a == i or b == i or c == i:
                a, b, c = random.sample(range(self.population_size), 3)

            v = population[i] + self.F_scale * (pbest - population[i] + population[a] - population[b])
            u = np.where(np.random.rand(self.dim) < self.CR, v, population[i])
            offspring[i] = np.clip(u, self.lower_bounds, self.upper_bounds)

        return offspring

    def update_archive(self, offspring, offspring_fitness):
        for i in range(len(offspring)):
            if len(self.archive) < self.archive_size:
                self.archive.append((offspring[i], offspring_fitness[i]))
            else:
                worst_index = np.argmax([f for _, f in self.archive])
                if offspring_fitness[i] < self.archive[worst_index][1]:
                    self.archive[worst_index] = (offspring[i], offspring_fitness[i])

    def simulated_annealing(self, offspring, offspring_fitness, objective_function):
        for i in range(len(offspring)):
            neighbor = offspring[i] + np.random.normal(0, 1, self.dim) * 0.1  #Small perturbation
            neighbor = np.clip(neighbor, self.lower_bounds, self.upper_bounds)
            neighbor_fitness = objective_function(neighbor.reshape(1, -1))[0]
            self.eval_count +=1
            delta_e = neighbor_fitness - offspring_fitness[i]
            if delta_e < 0 or np.random.rand() < np.exp(-delta_e / self.T):
                offspring[i] = neighbor
                offspring_fitness[i] = neighbor_fitness
        return offspring, offspring_fitness
2025-06-24 07:28:53 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:28:53 INFO Run function 6 complete. FEHistory len: 100000, AOCC: 0.1490
2025-06-24 07:28:53 INFO FeHistory: [-183.32258137 -183.33753622 -183.38175203 ... -183.55380805 -183.51612144
 -183.52464341]
2025-06-24 07:28:53 INFO Expected Optimum FE: -186.86405320391498
2025-06-24 07:28:53 INFO Good algorithm:
Algorithm Name: AdaptiveHybridDE_SA
import numpy as np
import random

# Name: AdaptiveHybridDE_SA
# Description: A hybrid Differential Evolution and Simulated Annealing algorithm with adaptive parameters for multimodal optimization.

class AdaptiveHybridDE_SA:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):
        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        self.population_size = 20 * self.dim  # Increased population size for better exploration
        self.population = None
        self.archive = []  # Archive to store diverse solutions
        self.archive_size = 200

        self.F = 0.5  # Differential Evolution scaling factor
        self.CR = 0.9  # Crossover rate
        self.T = 100.0  # Initial temperature for Simulated Annealing
        self.cooling_rate = 0.95  # Cooling rate for Simulated Annealing


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        self.eval_count = 0
        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))
        fitness = objective_function(self.population)
        self.eval_count += self.population_size

        self.best_solution_overall = self.population[np.argmin(fitness)]
        self.best_fitness_overall = np.min(fitness)

        while self.eval_count < self.budget:
            offspring = self.generate_offspring()
            offspring_fitness = objective_function(offspring)
            self.eval_count += len(offspring)

            self.update_archive(offspring, offspring_fitness)

            combined_population = np.concatenate((self.population, offspring))
            combined_fitness = np.concatenate((fitness, offspring_fitness))
            indices = np.argsort(combined_fitness)
            self.population = combined_population[indices[:self.population_size]]
            fitness = combined_fitness[indices[:self.population_size]]

            self.best_solution_overall = self.population[np.argmin(fitness)]
            self.best_fitness_overall = np.min(fitness)

            # Adapt parameters
            self.adapt_parameters(fitness)


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
            'archive_size': len(self.archive)
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info

    def generate_offspring(self):
        offspring = np.zeros((self.population_size, self.dim))
        for i in range(self.population_size):
            a, b, c = random.sample(range(self.population_size), 3)
            while a == i or b == i or c == i:
                a, b, c = random.sample(range(self.population_size), 3)

            mutant = self.population[a] + self.F * (self.population[b] - self.population[c])

            # Simulated Annealing perturbation
            perturbation = np.random.normal(0, self.T/10, self.dim) #scale perturbation by temperature
            mutant = mutant + perturbation
            mutant = np.clip(mutant, self.lower_bounds, self.upper_bounds)


            crosspoints = np.random.rand(self.dim) < self.CR
            offspring[i] = np.where(crosspoints, mutant, self.population[i])

        return offspring

    def update_archive(self, offspring, offspring_fitness):
        for i in range(len(offspring)):
            if len(self.archive) < self.archive_size:
                self.archive.append((offspring[i], offspring_fitness[i]))
            else:
                worst_index = np.argmax([f for _, f in self.archive])
                if offspring_fitness[i] < self.archive[worst_index][1]:
                    self.archive[worst_index] = (offspring[i], offspring_fitness[i])


    def adapt_parameters(self, fitness):
        # Simple adaptive strategy: Reduce temperature and adjust F based on convergence
        self.T *= self.cooling_rate
        avg_fitness_diff = np.mean(np.diff(np.sort(fitness)))
        if avg_fitness_diff < 0.1 : #adjust F if convergence is slow
            self.F = min(1.0, self.F + 0.05)  #increase F for further exploration
        else:
            self.F = max(0.1, self.F - 0.02) #decrease F for exploitation

2025-06-24 07:28:53 INFO --- GNBG Problem Parameters for f13 ---
  Dimension: 30, MaxEvals: 500000
  Search Bounds: [-100, 100]
  Number of Components: 1
  Known Optimum Value: -216.727696
  Lambda (Curvature): [1]
  Mu (Asymmetry/Depth): [1 1]
----------------------------------------
2025-06-24 07:29:02 INFO Run function 13 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:29:02 INFO FeHistory: [ 813530.8197792  2645131.71838642 2215952.57416792 ...  748200.73245493
  443714.76619816  395979.76893335]
2025-06-24 07:29:02 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:29:02 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:29:02 INFO Run function 13 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:29:02 INFO FeHistory: [1696454.2116268  1994831.52345893 2640858.29701144 ...   65636.41409135
   17841.91177849   54010.63222243]
2025-06-24 07:29:02 INFO Expected Optimum FE: -216.7276963542314
2025-06-24 07:29:02 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-24 07:31:08 INFO Run function 18 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:31:08 INFO FeHistory: [178417.1735216  104597.62272716 170908.98281168 ...  -4404.54265215
  -4412.22363843  -4408.73728224]
2025-06-24 07:31:08 INFO Expected Optimum FE: -5000
2025-06-24 07:31:08 INFO Unimodal AOCC mean: 0.1597
2025-06-24 07:31:08 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:31:08 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 07:31:08 INFO AOCC mean: 0.0532
2025-06-24 07:31:08 INFO Weighed AOCC mean: 0.0160
2025-06-24 07:31:08 INFO Run function 18 complete. FEHistory len: 100000, AOCC: 0.0000
2025-06-24 07:31:08 INFO FeHistory: [156192.94469471 140543.04100762 181613.66566579 ...  -4162.59080157
  -4216.91858372  -4095.24747838]
2025-06-24 07:31:08 INFO Expected Optimum FE: -5000
2025-06-24 07:31:08 INFO Unimodal AOCC mean: 0.1490
2025-06-24 07:31:08 INFO Multimodal (single component) AOCC mean: 0.0000
2025-06-24 07:31:08 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-24 07:31:08 INFO AOCC mean: 0.0497
2025-06-24 07:31:08 INFO Weighed AOCC mean: 0.0149
