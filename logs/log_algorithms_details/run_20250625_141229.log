2025-06-25 14:12:30 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 14:12:30 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 14:13:13 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:13:13 INFO FeHistory: [122861.57978396 168693.44399964 150456.622721   ... 119072.9759371
 139466.21858239 155195.82631126]
2025-06-25 14:13:13 INFO Expected Optimum FE: -5000
2025-06-25 14:13:13 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 14:13:14 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0141
2025-06-25 14:13:14 INFO FeHistory: [164342.07646208 144654.03577761 101984.07584546 ... 132633.60105917
 113733.93478736 101156.61239437]
2025-06-25 14:13:14 INFO Expected Optimum FE: -5000
2025-06-25 14:13:14 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 14:13:55 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:13:55 INFO FeHistory: [112712.01767061 197018.63901085 114391.24064799 ... 124258.46749639
 137990.00999057 181202.97757114]
2025-06-25 14:13:55 INFO Expected Optimum FE: -5000
2025-06-25 14:13:55 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 14:13:55 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:13:55 INFO FeHistory: [196162.62299799 181992.96593518 141942.69710275 ... 225179.69215206
 179330.58617642 222523.76216285]
2025-06-25 14:13:55 INFO Expected Optimum FE: -5000
2025-06-25 14:13:55 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 14:14:36 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:14:36 INFO FeHistory: [248168.07790581 209603.90412549 236075.35922272 ... 209609.96151388
 248231.64898603 301610.49453563]
2025-06-25 14:14:36 INFO Expected Optimum FE: -5000
2025-06-25 14:14:36 INFO Unimodal AOCC mean: nan
2025-06-25 14:14:36 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 14:14:36 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 14:14:36 INFO AOCC mean: 0.0000
2025-06-25 14:14:36 INFO Weighed AOCC mean: nan
2025-06-25 14:14:36 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 14:14:37 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:14:37 INFO FeHistory: [122532.02091029 147391.1924683  157953.33943497 ... 142131.09336103
 179718.04867911 137169.81337846]
2025-06-25 14:14:37 INFO Expected Optimum FE: -5000
2025-06-25 14:14:37 INFO Unimodal AOCC mean: nan
2025-06-25 14:14:37 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 14:14:37 INFO Multimodal (multiple components) AOCC mean: 0.0047
2025-06-25 14:14:37 INFO AOCC mean: 0.0047
2025-06-25 14:14:37 INFO Weighed AOCC mean: nan
2025-06-25 14:14:37 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 14:15:18 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:15:18 INFO FeHistory: [123454.21225856 132937.82361564 138710.82361968 ... 118504.010129
 109436.11690401  84411.01265553]
2025-06-25 14:15:18 INFO Expected Optimum FE: -5000
2025-06-25 14:15:18 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 14:15:19 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:15:19 INFO FeHistory: [118522.48913581 117345.72207575 150860.83633321 ... 113411.07848429
 162070.10826276  97191.37659354]
2025-06-25 14:15:19 INFO Expected Optimum FE: -5000
2025-06-25 14:15:19 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 14:16:00 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:16:00 INFO FeHistory: [154109.71952187  99187.68667647 163913.95254135 ... 220749.19704091
 198276.26475085 237817.8139983 ]
2025-06-25 14:16:00 INFO Expected Optimum FE: -5000
2025-06-25 14:16:00 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 14:16:01 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:16:01 INFO FeHistory: [116723.6178571  145083.03982232 141886.9462605  ... 220179.28876704
 109303.81066473 156135.7703171 ]
2025-06-25 14:16:01 INFO Expected Optimum FE: -5000
2025-06-25 14:16:01 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 14:16:41 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:16:41 INFO FeHistory: [196376.20338273 186220.69139926 204795.34233531 ... 152680.90851288
 132971.94569373 176831.94988538]
2025-06-25 14:16:41 INFO Expected Optimum FE: -5000
2025-06-25 14:16:41 INFO Unimodal AOCC mean: nan
2025-06-25 14:16:41 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 14:16:41 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 14:16:41 INFO AOCC mean: 0.0000
2025-06-25 14:16:41 INFO Weighed AOCC mean: nan
2025-06-25 14:16:41 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 14:16:43 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:16:43 INFO FeHistory: [ 57389.63278581 237395.52546894 243740.69604236 ... 193892.66202753
 138534.65260884 191504.95783226]
2025-06-25 14:16:43 INFO Expected Optimum FE: -5000
2025-06-25 14:16:43 INFO Unimodal AOCC mean: nan
2025-06-25 14:16:43 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 14:16:43 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 14:16:43 INFO AOCC mean: 0.0000
2025-06-25 14:16:43 INFO Weighed AOCC mean: nan
2025-06-25 14:16:43 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 14:17:24 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.3482
2025-06-25 14:17:24 INFO FeHistory: [142262.49024076 155810.62092987 146943.12973723 ... 144606.20554214
 118484.75558109 103521.20503814]
2025-06-25 14:17:24 INFO Expected Optimum FE: -5000
2025-06-25 14:17:24 INFO Good algorithm:
Algorithm Name: AdaptiveIslandDEPlus
import numpy as np
import random

# Name: AdaptiveIslandDEPlus
# Description: Island-based DE with adaptive parameters, local search, and fitness-reassessed migration.
# Code:
class AdaptiveIslandDEPlus:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20,
                 migration_interval: int = 500, migration_size: int = 2,
                 local_search_iterations: int = 10, local_search_perturbation_scale: float = 0.1,
                 restart_percentage: float = 0.95):
        """
        Initializes the AdaptiveIslandDEPlus optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search.
            local_search_perturbation_scale (float): Scale of the random perturbation in local search.
            restart_percentage (float): Percentage of budget used to trigger restart.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.local_search_perturbation_scale = local_search_perturbation_scale
        self.restart_percentage = restart_percentage

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands

        # Adaptive DE parameters (initialized)
        self.crossover_rates = np.full(self.num_islands, 0.7)
        self.mutation_rates = np.full(self.num_islands, 0.5)


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island, adapting parameters.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]
        crossover_rate = self.crossover_rates[island_index]
        mutation_rate = self.mutation_rates[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector

        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

        # Adaptive parameter update (example - simple adjustment)
        if random.random() < 0.05:  # Small chance to adjust
            self.crossover_rates[island_index] = np.clip(crossover_rate + random.uniform(-0.1, 0.1), 0.1, 0.9)
            self.mutation_rates[island_index] = np.clip(mutation_rate + random.uniform(-0.1, 0.1), 0.1, 0.9)


    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution.

        Args:
            solution (np.ndarray): The solution to start local search from.
            objective_function (callable): Objective function.

        Returns:
            tuple: Improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            perturbation = np.random.normal(0, self.local_search_perturbation_scale, self.dim)
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands, followed by local adaptation.
        """
        for i in range(self.num_islands):
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Source: Best solutions
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()

            # Destination: Worst solutions
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            self.populations[dest_island][worst_indices] = migrants

            # Re-evaluate fitness and apply local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function)
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness

            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                    self.best_fitnesses[dest_island] = fit
                    self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes using island model DE with adaptive migration and local search.

        Args:
            objective_function (callable): The function to optimize.
            acceptance_threshold (float): Included for compliance, not used.

        Returns:
            tuple: Best solution, fitness, and optimization info.
        """
        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize fitness
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]

        # Main loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            if self.eval_count > self.budget * self.restart_percentage:
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
2025-06-25 14:17:24 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 14:17:26 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.5326
2025-06-25 14:17:26 INFO FeHistory: [ 89158.77586221 124587.43461832 102559.15838663 ... 129308.87090986
 126245.74353385 162300.78359938]
2025-06-25 14:17:26 INFO Expected Optimum FE: -5000
2025-06-25 14:17:26 INFO Good algorithm:
Algorithm Name: AdaptiveIslandDEPlus
import numpy as np
import random

# Name: AdaptiveIslandDEPlus
# Description: Island-based DE with adaptive migration, enhanced local search, and fitness-aware mechanisms.
# Code:
class AdaptiveIslandDEPlus:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.8719572569354708,
                 mutation_rate: float = 0.6113964692124271, migration_interval: int = 896.9508697672186, migration_size: float = 0.1,
                 local_search_iterations: int = 6, local_search_perturbation_scale: float = 0.1, restart_percentage: float = 0.8,
                 adaptive_mutation_chance: float = 0.1):
        """
        Initializes the AdaptiveIslandDEPlus optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (float): Fraction of individuals to migrate.
            local_search_iterations (int): Iterations for local search
            local_search_perturbation_scale (float): Scale of the perturbation in local search.
            restart_percentage (float): Percentage of budget used to trigger restart.
            adaptive_mutation_chance (float): Probability of adaptive mutation.
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = int(migration_interval)
        self.migration_size = migration_size
        self.local_search_iterations = int(local_search_iterations)
        self.local_search_perturbation_scale = local_search_perturbation_scale
        self.restart_percentage = restart_percentage
        self.adaptive_mutation_chance = adaptive_mutation_chance

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands

    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island with adaptive mutation.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)

            # Potentially adapt mutation rate
            current_mutation_rate = self.mutation_rate
            if random.random() < self.adaptive_mutation_chance:
                current_mutation_rate = random.uniform(0.1, 1.0)  # Adapt mutation rate

            mutant_vector = population[a] + current_mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector

        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values


    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs enhanced local search around a solution using random perturbations and gradient descent.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Enhanced Perturbation: Adjusted scale
            perturbation = np.random.normal(0, self.local_search_perturbation_scale, self.dim)
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands using fitness-aware migration strategy.

        Each island sends its best individuals to another randomly chosen island
        and replaces its worst individuals with the migrants.
        """
        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            migration_amount = int(self.migration_size * self.population_size)  #Portion adapts
            best_indices = np.argsort(source_island_fitness)[:migration_amount]
            migrants = self.populations[i][best_indices].copy()

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-migration_amount:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants

             # Re-evaluate the fitness of the new solutions on the destination island (important!) and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function)
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness
             # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol


    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using island model with DE and local adaptation.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used, but included for compliance.

        Returns:
            tuple: Best solution, fitness, and optimization info.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]

        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * self.restart_percentage:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]

        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
2025-06-25 14:17:26 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 14:18:05 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:18:05 INFO FeHistory: [228320.938301   209883.5376999  125325.93453328 ... 143155.91097842
 161080.25952943 173595.16312622]
2025-06-25 14:18:05 INFO Expected Optimum FE: -5000
2025-06-25 14:18:05 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 14:18:08 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:18:08 INFO FeHistory: [141046.80686853 174403.49715922 181538.81662693 ... 254138.83258774
 191892.28797334 225745.88782689]
2025-06-25 14:18:08 INFO Expected Optimum FE: -5000
2025-06-25 14:18:08 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 14:18:48 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:18:48 INFO FeHistory: [145972.59862644 134700.00363091 206194.40560607 ... 231399.76493044
 282201.8616086  271504.79611662]
2025-06-25 14:18:48 INFO Expected Optimum FE: -5000
2025-06-25 14:18:48 INFO Unimodal AOCC mean: nan
2025-06-25 14:18:48 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 14:18:48 INFO Multimodal (multiple components) AOCC mean: 0.1161
2025-06-25 14:18:48 INFO AOCC mean: 0.1161
2025-06-25 14:18:48 INFO Weighed AOCC mean: nan
2025-06-25 14:18:48 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 14:18:50 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0207
2025-06-25 14:18:50 INFO FeHistory: [168396.40482285 198354.65761252 156069.21698766 ... 298126.33613861
 318361.60963978 300141.14679631]
2025-06-25 14:18:50 INFO Expected Optimum FE: -5000
2025-06-25 14:18:50 INFO Unimodal AOCC mean: nan
2025-06-25 14:18:50 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 14:18:50 INFO Multimodal (multiple components) AOCC mean: 0.1844
2025-06-25 14:18:50 INFO AOCC mean: 0.1844
2025-06-25 14:18:50 INFO Weighed AOCC mean: nan
2025-06-25 14:18:50 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 14:19:34 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:19:34 INFO FeHistory: [125279.35764197 175172.50827317  88013.44039418 ... 150654.96293362
 140558.27386608 126542.30228244]
2025-06-25 14:19:34 INFO Expected Optimum FE: -5000
2025-06-25 14:19:34 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 14:19:35 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:19:35 INFO FeHistory: [149134.78854246 113666.49434609 128021.00980868 ... 166156.33154825
 117172.33213876 151086.15529605]
2025-06-25 14:19:35 INFO Expected Optimum FE: -5000
2025-06-25 14:19:35 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 14:20:16 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:20:16 INFO FeHistory: [140691.91870162 243777.75028897 156495.46664657 ... 169886.01830416
 167287.77684566 196951.21454842]
2025-06-25 14:20:16 INFO Expected Optimum FE: -5000
2025-06-25 14:20:16 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 14:20:19 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.3245
2025-06-25 14:20:19 INFO FeHistory: [128017.92275157 130488.6126255  121453.05131725 ... 141148.92123967
 256992.13966644 135617.11837158]
2025-06-25 14:20:19 INFO Expected Optimum FE: -5000
2025-06-25 14:20:19 INFO Good algorithm:
Algorithm Name: AdaptiveIslandDEPlusLocalTuning
import numpy as np
import random

# Name: AdaptiveIslandDEPlusLocalTuning
# Description: Island model DE with adaptive migration, local DE tuning, and restart for deceptive landscapes.
# Code:
class AdaptiveIslandDEPlusLocalTuning:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 500, migration_size: int = 2,
                 local_search_iterations: int = 10, restart_trigger: float = 0.95,
                 mutation_rate_local_tuning: float = 0.1):  # Mutation rate for local DE tuning

        """
        Initializes the AdaptiveIslandDEPlusLocalTuning optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor for global DE.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search with DE operator
            restart_trigger (float) Percentage of budget at which the algorithm restarts.
            mutation_rate_local_tuning(float): DE mutation scaling factor for local DE tuning.

        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.restart_trigger = restart_trigger
        self.mutation_rate_local_tuning = mutation_rate_local_tuning

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search using DE around a solution with tuned mutation rate.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
             # Mutation - Like DE
            indices = list(range(self.dim))
            a, b, c = random.sample(indices, 3)
            mutant_vector = best_solution + self.mutation_rate_local_tuning * (best_solution - best_solution)  #best_solution vector cause focus to itself
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds) # Clip to bounds
            
            #Evaluation
            new_fitness = objective_function(mutant_vector.reshape(1, -1))[0]
            self.eval_count += 1
        
            #Selection for next iteration
            if new_fitness < best_fitness:
                 best_fitness = new_fitness
                 best_solution = mutant_vector
        return best_solution, best_fitness



    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands.  Each island sends its best
        individuals to a randomly chosen other island, and receives
        migrants to replace its worst individuals. Local search after migration
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]

            # Replace the worst solutions on the destination island with the migrants
            self.populations[dest_island][worst_indices] = migrants

            # Re-evaluate the fitness of the new solutions on the destination island and perform local search
            new_fitnesses = []
            for j in range(len(worst_indices)):
                migrant = migrants[j]
                migrant, fitness = self.local_search(migrant, objective_function) #Local Adaptation here.
                new_fitnesses.append(fitness)

            dest_island_fitness[worst_indices] = new_fitnesses
            self.fitness_values[dest_island] = dest_island_fitness
             # Update best fitness, if needed
            for fit, sol in zip(new_fitnesses, migrants):
                if fit < self.best_fitnesses[dest_island]:
                     self.best_fitnesses[dest_island] = fit
                     self.best_solutions[dest_island] = sol
                if fit < self.best_fitness_overall:
                    self.best_fitness_overall = fit
                    self.best_solution_overall = sol




    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index]

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i]


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating
            if self.eval_count > self.budget * self.restart_trigger:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index]
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i]


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
2025-06-25 14:20:19 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 14:20:58 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:20:58 INFO FeHistory: [247387.45756967 142682.61586692 154436.69809469 ... 217148.56759265
 225763.79113553 257961.08346368]
2025-06-25 14:20:58 INFO Expected Optimum FE: -5000
2025-06-25 14:20:58 INFO Unimodal AOCC mean: nan
2025-06-25 14:20:58 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 14:20:58 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 14:20:58 INFO AOCC mean: 0.0000
2025-06-25 14:20:58 INFO Weighed AOCC mean: nan
2025-06-25 14:21:01 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0986
2025-06-25 14:21:01 INFO FeHistory: [146638.92219014 136755.43281952 168167.12541137 ... 193195.3344386
 193800.62792923 249830.77660555]
2025-06-25 14:21:01 INFO Expected Optimum FE: -5000
2025-06-25 14:21:01 INFO Unimodal AOCC mean: nan
2025-06-25 14:21:01 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 14:21:01 INFO Multimodal (multiple components) AOCC mean: 0.1411
2025-06-25 14:21:01 INFO AOCC mean: 0.1411
2025-06-25 14:21:01 INFO Weighed AOCC mean: nan
2025-06-25 14:21:35 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 14:21:35 INFO --- GNBG Problem Parameters for f16 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0 0 0 0 0 0 0 0 0 0]
----------------------------------------
2025-06-25 14:22:19 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:22:19 INFO FeHistory: [ 98758.45794799 120952.95445051 167756.39580061 ... 169388.21937662
 129226.41206042 134268.40237522]
2025-06-25 14:22:19 INFO Expected Optimum FE: -5000
2025-06-25 14:22:19 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 14:22:19 INFO Run function 16 complete. FEHistory len: 150000, AOCC: 0.0000
2025-06-25 14:22:19 INFO FeHistory: [132819.50693828 193966.39451881 129512.58115308 ... 142399.89819259
  86655.02201393 124702.2264226 ]
2025-06-25 14:22:19 INFO Expected Optimum FE: -5000
2025-06-25 14:22:19 INFO --- GNBG Problem Parameters for f18 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.22159228 0.42314776 0.4901829  0.25862884 0.37043014 0.37440768
 0.26098797 0.491006   0.27569772 0.45404864]
----------------------------------------
2025-06-25 14:22:48 INFO Run function 18 complete. FEHistory len: 103910, AOCC: 0.0000
2025-06-25 14:22:48 INFO FeHistory: [170791.56229916 100068.78657833 185869.0673098  ...  -4470.39998284
  -4470.39998636  -4470.39998008]
2025-06-25 14:22:48 INFO Expected Optimum FE: -5000
2025-06-25 14:22:48 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 14:23:00 INFO Run function 19 complete. FEHistory len: 46210, AOCC: 0.0000
2025-06-25 14:23:00 INFO FeHistory: [189803.73909556 185205.17432274 170879.93524278 ...  -2646.52954388
  -3268.52883123  -2818.89970397]
2025-06-25 14:23:00 INFO Expected Optimum FE: -5000
2025-06-25 14:23:00 INFO Unimodal AOCC mean: nan
2025-06-25 14:23:00 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 14:23:00 INFO Multimodal (multiple components) AOCC mean: 0.0000
2025-06-25 14:23:00 INFO AOCC mean: 0.0000
2025-06-25 14:23:00 INFO Weighed AOCC mean: nan
2025-06-25 14:23:00 INFO Run function 18 complete. FEHistory len: 150000, AOCC: 0.2515
2025-06-25 14:23:00 INFO FeHistory: [124593.24229562 131069.34697616 120079.03299301 ... 148822.66731724
 176265.42336324 169798.6611352 ]
2025-06-25 14:23:00 INFO Expected Optimum FE: -5000
2025-06-25 14:23:00 INFO Good algorithm:
Algorithm Name: AdaptiveIslandDEPlus
import numpy as np
import random

# Name: AdaptiveIslandDEPlus
# Description: Island-based DE with adaptive migration using fitness ranking and local search refinement after migration.
# Code:
class AdaptiveIslandDEPlus:
    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float],
                 num_islands: int = 5, population_size: int = 20, crossover_rate: float = 0.7,
                 mutation_rate: float = 0.5, migration_interval: int = 500, migration_size: int = 2,
                 local_search_iterations: int = 10, migration_acceptance_probability=0.5):
        """
        Initializes the AdaptiveIslandDEPlus optimizer.

        Args:
            budget (int): Maximum number of function evaluations.
            dim (int): Problem dimensionality.
            lower_bounds (list[float]): List of lower bounds for each dimension.
            upper_bounds (list[float]): List of upper bounds for each dimension.
            num_islands (int): Number of independent subpopulations (islands).
            population_size (int): Number of individuals in each island's population.
            crossover_rate (float): DE crossover probability.
            mutation_rate (float): DE mutation scaling factor.
            migration_interval (int): Number of evaluations between migrations.
            migration_size (int): Number of individuals to migrate.
            local_search_iterations (int): Iterations for local search
            migration_acceptance_probability (float): The probability that worse fitness gets replaced from other island
        """

        self.budget = int(budget)
        self.dim = int(dim)
        self.lower_bounds = np.array(lower_bounds, dtype=float)
        self.upper_bounds = np.array(upper_bounds, dtype=float)
        self.num_islands = num_islands
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.migration_interval = migration_interval
        self.migration_size = migration_size
        self.local_search_iterations = local_search_iterations
        self.migration_acceptance_probability = migration_acceptance_probability

        self.eval_count = 0
        self.best_solution_overall = None
        self.best_fitness_overall = float('inf')

        # Initialize populations for each island
        self.populations = [
            np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
            for _ in range(self.num_islands)
        ]
        self.fitness_values = [np.full(self.population_size, float('inf')) for _ in range(self.num_islands)]
        self.best_solutions = [None] * self.num_islands
        self.best_fitnesses = [float('inf')] * self.num_islands


    def differential_evolution_step(self, island_index: int, objective_function: callable):
        """
        Performs a single step of differential evolution on a given island.

        Args:
            island_index (int): Index of the island to evolve.
            objective_function (callable): The objective function to optimize.
        """

        population = self.populations[island_index]
        fitness_values = self.fitness_values[island_index]

        for i in range(self.population_size):
            # Mutation
            indices = list(range(self.population_size))
            indices.remove(i)
            a, b, c = random.sample(indices, 3)
            mutant_vector = population[a] + self.mutation_rate * (population[b] - population[c])
            mutant_vector = np.clip(mutant_vector, self.lower_bounds, self.upper_bounds)  # Clip to bounds

            # Crossover
            trial_vector = np.copy(population[i])
            for j in range(self.dim):
                if random.random() < self.crossover_rate:
                    trial_vector[j] = mutant_vector[j]

            # Evaluation
            trial_vector_reshaped = trial_vector.reshape(1, -1)
            trial_fitness = objective_function(trial_vector_reshaped)[0]
            self.eval_count += 1

            # Selection
            if trial_fitness < fitness_values[i]:
                population[i] = trial_vector
                fitness_values[i] = trial_fitness

                # Update island best
                if trial_fitness < self.best_fitnesses[island_index]:
                    self.best_fitnesses[island_index] = trial_fitness
                    self.best_solutions[island_index] = trial_vector

                # Update overall best
                if trial_fitness < self.best_fitness_overall:
                    self.best_fitness_overall = trial_fitness
                    self.best_solution_overall = trial_vector


        self.populations[island_index] = population
        self.fitness_values[island_index] = fitness_values

    def local_search(self, solution: np.ndarray, objective_function: callable) -> tuple:
        """
        Performs local search around a solution using a simple gradient-based method.

        Args:
            solution (np.ndarray): The solution to start the local search from.
            objective_function (callable): The objective function to optimize.

        Returns:
            tuple: A tuple containing the improved solution and its fitness.
        """
        best_solution = solution.copy()
        best_fitness = objective_function(best_solution.reshape(1, -1))[0]
        self.eval_count += 1

        for _ in range(self.local_search_iterations):
            # Create a small random perturbation
            perturbation = np.random.normal(0, 0.1, self.dim) # Scale adjusted from 1 to 0.1
            new_solution = best_solution + perturbation
            new_solution = np.clip(new_solution, self.lower_bounds, self.upper_bounds)

            # Evaluate the new solution
            new_fitness = objective_function(new_solution.reshape(1, -1))[0]
            self.eval_count += 1

            # If the new solution is better, update the current best
            if new_fitness < best_fitness:
                best_fitness = new_fitness
                best_solution = new_solution

        return best_solution, best_fitness


    def migrate(self, objective_function: callable):
        """
        Migrates individuals between islands with adaptive fitness-based acceptance and local search.
        """

        for i in range(self.num_islands):
            # Select a random destination island (excluding itself)
            dest_island = random.choice([j for j in range(self.num_islands) if j != i])

            # Identify the best solutions on the source island
            source_island_fitness = self.fitness_values[i]
            best_indices = np.argsort(source_island_fitness)[:self.migration_size]
            migrants = self.populations[i][best_indices].copy()  # Important to copy
            migrant_fitnesses = source_island_fitness[best_indices].copy()

            # Identify the worst solutions on the destination island
            dest_island_fitness = self.fitness_values[dest_island]
            worst_indices = np.argsort(dest_island_fitness)[-self.migration_size:]
            
            #Adaptive Migration: replace bad ones only if the migrants are better.
            
            for j in range(self.migration_size):
                 if migrant_fitnesses[j] < dest_island_fitness[worst_indices[j]] or random.random() < self.migration_acceptance_probability:
                      # Replace the worst solutions on the destination island with the migrants
                      self.populations[dest_island][worst_indices[j]] = migrants[j]

                      # Perform local search on the migrant after migration for faster adaptation
                      migrant, fitness = self.local_search(migrants[j], objective_function)  # Local adaptation
                      self.fitness_values[dest_island][worst_indices[j]] = fitness

                       # Update best fitness, if needed
                      if fitness < self.best_fitnesses[dest_island]:
                          self.best_fitnesses[dest_island] = fitness
                          self.best_solutions[dest_island] = migrant
                      if fitness < self.best_fitness_overall:
                          self.best_fitness_overall = fitness
                          self.best_solution_overall = migrant
            
            #Re-evaluate destination after some migrants settle in.
            # Re-evaluate the fitness of the new solutions on the destination island (important!)
            # self.fitness_values[dest_island] = objective_function(self.populations[dest_island])
            # self.eval_count += self.population_size #Batch Evaluation (Can slow down, so picking the ones being replaced only)
            
             # Batch version might cause diversity exhaustion. Replaced by incremental Local Adaptation.

    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:
        """
        Optimizes the given objective function using the island model differential evolution algorithm.

        Args:
            objective_function (callable): The objective function to optimize.
            acceptance_threshold (float): Not used in this implementation, but included for compliance.

        Returns:
            tuple: A tuple containing the best solution found, its fitness, and optimization information.
        """
        self.eval_count = 0  # Reset for this run
        self.best_solution_overall = None # Reset for this run
        self.best_fitness_overall = float('inf') # Reset for this run

        # Initialize fitness values for each island
        for i in range(self.num_islands):
            self.fitness_values[i] = objective_function(self.populations[i])
            self.eval_count += self.population_size
            best_index = np.argmin(self.fitness_values[i])
            self.best_fitnesses[i] = self.fitness_values[i][best_index]
            self.best_solutions[i] = self.populations[i][best_index].copy() #Important To Copy!!!

            if self.best_fitnesses[i] < self.best_fitness_overall:
                self.best_fitness_overall = self.best_fitnesses[i]
                self.best_solution_overall = self.best_solutions[i].copy() #Important To Copy!!!


        # Main optimization loop
        while self.eval_count < self.budget:
            for i in range(self.num_islands):
                self.differential_evolution_step(i, objective_function)

            if self.eval_count % self.migration_interval == 0:
                self.migrate(objective_function)

            #Restart Mechanism if stagnating (Diversity Maintenance)
            if self.eval_count > self.budget * 0.95:  # Restart towards the end
                for i in range(self.num_islands):
                    self.populations[i] = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))
                    self.fitness_values[i] = objective_function(self.populations[i])
                    self.eval_count += self.population_size
                    best_index = np.argmin(self.fitness_values[i])
                    self.best_fitnesses[i] = self.fitness_values[i][best_index]
                    self.best_solutions[i] = self.populations[i][best_index].copy()#Important To Copy!!!
                    if self.best_fitnesses[i] < self.best_fitness_overall:
                        self.best_fitness_overall = self.best_fitnesses[i]
                        self.best_solution_overall = self.best_solutions[i].copy() #Important To Copy!!!


        optimization_info = {
            'function_evaluations_used': self.eval_count,
            'final_best_fitness': self.best_fitness_overall,
        }
        return self.best_solution_overall, self.best_fitness_overall, optimization_info
2025-06-25 14:23:00 INFO --- GNBG Problem Parameters for f19 ---
  Dimension: 30, MaxEvals: 1000000
  Search Bounds: [-100, 100]
  Number of Components: 5
  Known Optimum Value: -5000.000000
  Lambda (Curvature): [1 1 1 1 1]
  Mu (Asymmetry/Depth): [0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5 0.5]
----------------------------------------
2025-06-25 14:23:42 INFO Run function 19 complete. FEHistory len: 150000, AOCC: 0.0806
2025-06-25 14:23:42 INFO FeHistory: [277135.49256694 171884.43519661 158045.27246744 ... 172489.40048765
 150448.28441383 163276.94809626]
2025-06-25 14:23:42 INFO Expected Optimum FE: -5000
2025-06-25 14:23:42 INFO Unimodal AOCC mean: nan
2025-06-25 14:23:42 INFO Multimodal (single component) AOCC mean: nan
2025-06-25 14:23:42 INFO Multimodal (multiple components) AOCC mean: 0.1107
2025-06-25 14:23:42 INFO AOCC mean: 0.1107
2025-06-25 14:23:42 INFO Weighed AOCC mean: nan
