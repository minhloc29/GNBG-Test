{"id": "e8dd21f1-faf8-4196-be73-412a9c25ad3a", "fitness": 0.049324592884943785, "name": "EnhancedArchiveGuidedDE", "description": "Archive-guided Differential Evolution with enhanced archive management and adaptive mutation.", "code": "import numpy as np\nimport random\n\nclass EnhancedArchiveGuidedDE:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n\n        self.population_size = 10 * self.dim  # common heuristic\n        self.archive_size = 100\n        self.archive = []\n        self.population = None\n        self.F_scale = 0.5 #initial scaling factor\n\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        self.population = np.random.uniform(self.lower_bounds, self.upper_bounds, size=(self.population_size, self.dim))\n        fitness = objective_function(self.population)\n        self.eval_count += self.population_size\n\n        self.best_solution_overall = self.population[np.argmin(fitness)]\n        self.best_fitness_overall = np.min(fitness)\n\n        while self.eval_count < self.budget:\n            offspring = self.generate_offspring(self.population, fitness)\n            offspring_fitness = objective_function(offspring)\n            self.eval_count += len(offspring)\n\n            # Update archive\n            self.update_archive(offspring, offspring_fitness)\n\n            # Select best solutions for next generation\n            combined_population = np.concatenate((self.population, offspring))\n            combined_fitness = np.concatenate((fitness, offspring_fitness))\n            indices = np.argsort(combined_fitness)\n            self.population = combined_population[indices[:self.population_size]]\n            fitness = combined_fitness[indices[:self.population_size]]\n\n            #Update best solution\n            self.best_solution_overall = self.population[np.argmin(fitness)]\n            self.best_fitness_overall = np.min(fitness)\n\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall,\n            'archive_size': len(self.archive)\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info\n\n    def generate_offspring(self, population, fitness):\n        offspring = np.zeros((self.population_size, self.dim))\n        #Adaptive scaling factor\n        self.F_scale = 0.5 + 0.3*np.random.rand() #scale factor with slight variation\n\n        for i in range(self.population_size):\n            # Select pbest from archive (if available)\n            if self.archive:\n                pbest_index = np.random.choice(len(self.archive))\n                pbest = self.archive[pbest_index][0]\n            else:\n                pbest = population[np.argmin(fitness)]\n\n            a, b, c = random.sample(range(self.population_size), 3)\n            while a == i or b == i or c == i:\n                a, b, c = random.sample(range(self.population_size), 3)\n\n            offspring[i] = population[i] + self.F_scale * (pbest - population[i] + population[a] - population[b])\n            offspring[i] = np.clip(offspring[i], self.lower_bounds, self.upper_bounds) #Boundary handling\n\n        return offspring\n\n    def update_archive(self, offspring, offspring_fitness):\n        for i in range(len(offspring)):\n            if len(self.archive) < self.archive_size:\n                self.archive.append((offspring[i], offspring_fitness[i]))\n            else:\n                #Prioritize diversity in archive\n                worst_index = np.argmax([f for _, f in self.archive])\n                if offspring_fitness[i] < self.archive[worst_index][1] or len(self.archive) < self.archive_size * 0.8 :\n                    self.archive[worst_index] = (offspring[i], offspring_fitness[i])\n", "configspace": "", "generation": 2, "feedback": "The mean AOCC score of the algorithm EnhancedArchiveGuidedDE on Multimodal instances with a single component 0.05, ", "error": "", "parent_ids": ["d839bb7e-aa7b-422c-bdff-9ec2b3765a14"], "operator": null, "metadata": {"aucs": []}}
