{
  "name": "AdaptiveGaussianMixtureDE",
  "description": "Adaptive Gaussian Mixture Differential Evolution with enhanced archive management, adaptive F and CR, refined GMM, and a covariance matrix adaptation for improved exploration and exploitation, using a more robust covariance matrix update and refined population sizing based on problem dimensionality.",
  "code": "import numpy as np\nfrom scipy.stats import multivariate_normal\n\nclass AdaptiveGaussianMixtureDE:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n\n        self.population_size = 5 * self.dim + 50  # Refined population sizing\n        self.F = 0.8\n        self.CR = 0.9\n\n        self.archive = []\n        self.archive_size = 100\n\n        self.C = np.eye(self.dim)\n        self.F_adapt_rate = 0.05\n        self.CR_adapt_rate = 0.02\n        self.sigma = 0.5\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n        self.best_fitness_overall = objective_function(self.best_solution_overall.reshape(1, -1))[0]\n        self.eval_count += 1\n\n        population = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.population_size, self.dim))\n        fitness_values = objective_function(population)\n        self.eval_count += self.population_size\n\n        for _ in range(self.budget - self.population_size):\n            # Mutation\n            mutated = np.zeros_like(population)\n            for j in range(self.population_size):\n                a, b, c = np.random.choice(np.delete(np.arange(self.population_size), j), size=3, replace=False)\n                mutated[j] = population[a] + self.F * (population[b] - population[c])\n\n            # Crossover\n            crossed = np.where(np.random.rand(*population.shape) < self.CR, mutated, population)\n\n            # GMM-guided mutation\n            if len(self.archive) > self.dim:\n                from sklearn.mixture import GaussianMixture\n                archive_solutions = np.array([sol for sol, _ in self.archive])\n                gm = GaussianMixture(n_components=min(len(self.archive), 10), covariance_type='full', random_state=0)\n                gm.fit(archive_solutions)\n                sampled = gm.sample(self.population_size)[0]\n                noise = np.random.multivariate_normal(np.zeros(self.dim), self.C * (self.sigma**2), self.population_size)\n                crossed = np.clip(crossed + noise * 0.2, self.lower_bounds, self.upper_bounds)\n\n                # Update covariance matrix\n                best_archive_sol = archive_solutions[np.argmin([f for _, f in self.archive])]\n                archive_mean = np.mean(archive_solutions, axis=0)\n                diff = best_archive_sol - archive_mean\n                self.C = 0.9 * self.C + 0.1 * np.outer(diff, diff)\n                self.sigma *= 0.99\n\n            # Selection\n            offspring_fitness = objective_function(crossed)\n            self.eval_count += self.population_size\n\n            for j in range(self.population_size):\n                if offspring_fitness[j] < fitness_values[j]:\n                    fitness_values[j] = offspring_fitness[j]\n                    population[j] = crossed[j]\n\n                    if offspring_fitness[j] < self.best_fitness_overall:\n                        self.best_fitness_overall = offspring_fitness[j]\n                        self.best_solution_overall = crossed[j]\n\n            # Archive management\n            for j in range(self.population_size):\n                if len(self.archive) < self.archive_size:\n                    self.archive.append((population[j], fitness_values[j]))\n                else:\n                    worst_idx = np.argmax([f for _, f in self.archive])\n                    if fitness_values[j] < self.archive[worst_idx][1]:\n                        self.archive[worst_idx] = (population[j], fitness_values[j])\n\n            # Adaptive parameters\n            self.F *= (1 + self.F_adapt_rate * np.random.randn())\n            self.CR *= (1 + self.CR_adapt_rate * np.random.randn())\n            self.F = np.clip(self.F, 0.1, 1)\n            self.CR = np.clip(self.CR, 0.1, 1)\n\n        return self.best_solution_overall, self.best_fitness_overall, {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall\n        }"
}
