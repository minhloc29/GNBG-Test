{"id": "7ae3b875-5878-40fa-a3f1-8aeee230b964", "fitness": 0.0, "name": "HybridPSO_NelderMead", "description": "A hybrid metaheuristic combining a modified Particle Swarm Optimization with a local search using a Nelder-Mead simplex method.", "code": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridPSO_NelderMead:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n        self.swarm_size = int(np.ceil(self.dim * 5)) # Dynamic swarm size\n        self.inertia_weight = 0.7\n        self.cognitive_factor = 1.4\n        self.social_factor = 1.4\n\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n        self.best_fitness_overall = objective_function(self.best_solution_overall.reshape(1,-1))[0]\n        self.eval_count +=1\n\n        swarm = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.swarm_size, self.dim))\n        velocities = np.zeros((self.swarm_size, self.dim))\n        personal_bests = swarm.copy()\n        personal_best_fitness = np.array([objective_function(x.reshape(1,-1))[0] for x in swarm])\n        self.eval_count += self.swarm_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.swarm_size):\n                if personal_best_fitness[i] < self.best_fitness_overall:\n                    self.best_fitness_overall = personal_best_fitness[i]\n                    self.best_solution_overall = personal_bests[i].copy()\n            \n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            velocities = self.inertia_weight * velocities + self.cognitive_factor * r1 * (personal_bests - swarm) + self.social_factor * r2 * (self.best_solution_overall - swarm)\n            swarm = swarm + velocities\n            swarm = np.clip(swarm, self.lower_bounds, self.upper_bounds)\n\n            fitness_values = objective_function(swarm)\n            self.eval_count += self.swarm_size\n            \n            for i in range(self.swarm_size):\n                if fitness_values[i] < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness_values[i]\n                    personal_bests[i] = swarm[i].copy()\n\n\n            #Local Search with Nelder-Mead\n            res = minimize(objective_function, self.best_solution_overall, method='nelder-mead', options={'maxfev': 100})\n            if res.fun < self.best_fitness_overall and self.eval_count + res.nfev <= self.budget:\n                self.best_fitness_overall = res.fun\n                self.best_solution_overall = res.x\n                self.eval_count += res.nfev\n\n            if self.eval_count >= self.budget: break\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info\n", "configspace": "", "generation": 0, "feedback": "The algorithm HybridPSO_NelderMead got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00 with standard deviation 0.00.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}}
{"id": "8c12c911-07a5-4461-953e-255141ae7f49", "fitness": 0.0, "name": "AdaptiveHybridPSO_NelderMead", "description": "Enhanced Hybrid PSO-NelderMead with adaptive inertia weight and population resizing, incorporating a more robust local search strategy.", "code": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveHybridPSO_NelderMead:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n        self.swarm_size = int(np.ceil(self.dim * 5))  # Dynamic swarm size\n        self.inertia_weight = 0.7\n        self.cognitive_factor = 1.4\n        self.social_factor = 1.4\n        self.local_search_budget_ratio = 0.1 #Percentage of budget for local search\n\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n        self.best_fitness_overall = objective_function(self.best_solution_overall.reshape(1,-1))[0]\n        self.eval_count += 1\n\n        swarm = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.swarm_size, self.dim))\n        velocities = np.zeros((self.swarm_size, self.dim))\n        personal_bests = swarm.copy()\n        personal_best_fitness = np.array([objective_function(x.reshape(1,-1))[0] for x in swarm])\n        self.eval_count += self.swarm_size\n\n        local_search_budget = int(self.budget * self.local_search_budget_ratio)\n\n\n        while self.eval_count < self.budget:\n            for i in range(self.swarm_size):\n                if personal_best_fitness[i] < self.best_fitness_overall:\n                    self.best_fitness_overall = personal_best_fitness[i]\n                    self.best_solution_overall = personal_bests[i].copy()\n\n            #Adaptive inertia weight\n            self.inertia_weight = 0.4 + 0.3 * np.exp(-self.eval_count / self.budget)\n\n\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            velocities = self.inertia_weight * velocities + self.cognitive_factor * r1 * (personal_bests - swarm) + self.social_factor * r2 * (self.best_solution_overall - swarm)\n            swarm = swarm + velocities\n            swarm = np.clip(swarm, self.lower_bounds, self.upper_bounds)\n\n            fitness_values = objective_function(swarm)\n            self.eval_count += self.swarm_size\n\n            for i in range(self.swarm_size):\n                if fitness_values[i] < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness_values[i]\n                    personal_bests[i] = swarm[i].copy()\n\n            # Adaptive population size\n            if self.eval_count > self.budget / 2:\n                self.swarm_size = int(np.ceil(self.swarm_size/2))\n                swarm = personal_bests[:self.swarm_size]\n                velocities = velocities[:self.swarm_size]\n                personal_best_fitness = personal_best_fitness[:self.swarm_size]\n\n\n            # Local Search with Nelder-Mead (more robust)\n            if self.eval_count + local_search_budget <= self.budget:\n                res = minimize(objective_function, self.best_solution_overall, method='nelder-mead', options={'maxfev': local_search_budget})\n                if res.fun < self.best_fitness_overall:\n                    self.best_fitness_overall = res.fun\n                    self.best_solution_overall = res.x\n                    self.eval_count += res.nfev\n\n            if self.eval_count >= self.budget:\n                break\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info\n", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveHybridPSO_NelderMead got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00 with standard deviation 0.00.", "error": "", "parent_ids": ["7ae3b875-5878-40fa-a3f1-8aeee230b964"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}}
{"id": "114876b8-af02-44f5-8312-e21d5ca0e02a", "fitness": 0.0, "name": "EnhancedHybridPSO_NelderMead", "description": "Enhanced Hybrid PSO-NelderMead with adaptive inertia weight and improved Nelder-Mead integration for efficient global and local search.", "code": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedHybridPSO_NelderMead:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n        self.swarm_size = int(np.ceil(self.dim * 5))  # Dynamic swarm size\n        self.inertia_weight = 0.7\n        self.cognitive_factor = 1.4\n        self.social_factor = 1.4\n        self.nelder_mead_budget_ratio = 0.2 #Fraction of budget for Nelder-Mead\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        if self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n            self.best_fitness_overall = objective_function(self.best_solution_overall.reshape(1,-1))[0]\n            self.eval_count += 1\n        else:\n            self.best_solution_overall = np.array([])\n            self.best_fitness_overall = 0\n\n\n        swarm = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.swarm_size, self.dim))\n        velocities = np.zeros((self.swarm_size, self.dim))\n        personal_bests = swarm.copy()\n        personal_best_fitness = np.array([objective_function(x.reshape(1,-1))[0] for x in swarm])\n        self.eval_count += self.swarm_size\n\n        nelder_mead_budget = int(self.budget * self.nelder_mead_budget_ratio)\n\n        while self.eval_count < self.budget:\n            for i in range(self.swarm_size):\n                if personal_best_fitness[i] < self.best_fitness_overall:\n                    self.best_fitness_overall = personal_best_fitness[i]\n                    self.best_solution_overall = personal_bests[i].copy()\n\n            # Adaptive inertia weight\n            self.inertia_weight = 0.4 + 0.3 * (1 - (self.eval_count / self.budget))\n\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            velocities = self.inertia_weight * velocities + self.cognitive_factor * r1 * (personal_bests - swarm) + self.social_factor * r2 * (self.best_solution_overall - swarm)\n            swarm = swarm + velocities\n            swarm = np.clip(swarm, self.lower_bounds, self.upper_bounds)\n\n            fitness_values = objective_function(swarm)\n            self.eval_count += self.swarm_size\n\n            for i in range(self.swarm_size):\n                if fitness_values[i] < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness_values[i]\n                    personal_bests[i] = swarm[i].copy()\n\n            # Improved Nelder-Mead integration: only if significant improvement in PSO\n            if self.eval_count < self.budget - nelder_mead_budget and self.best_fitness_overall < 0.8* np.mean(personal_best_fitness):\n                res = minimize(objective_function, self.best_solution_overall, method='nelder-mead', options={'maxfev': nelder_mead_budget})\n                if res.fun < self.best_fitness_overall and self.eval_count + res.nfev <= self.budget:\n                    self.best_fitness_overall = res.fun\n                    self.best_solution_overall = res.x\n                    self.eval_count += res.nfev\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info", "configspace": "", "generation": 2, "feedback": "The algorithm EnhancedHybridPSO_NelderMead got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00 with standard deviation 0.00.", "error": "", "parent_ids": ["7ae3b875-5878-40fa-a3f1-8aeee230b964"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}}
{"id": "745c848f-7308-4f8d-96ff-ebe6af1ae626", "fitness": 0.0, "name": "AdaptiveHybridPSO_NelderMead", "description": "A hybrid metaheuristic combining improved Particle Swarm Optimization with a local search using a Nelder-Mead simplex method and adaptive parameter tuning.", "code": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveHybridPSO_NelderMead:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n        self.swarm_size = int(np.ceil(self.dim * 5))  # Dynamic swarm size\n        self.inertia_weight = 0.7\n        self.cognitive_factor = 1.4\n        self.social_factor = 1.4\n        self.adaptive_factor = 0.95 #Factor to adapt parameters\n\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        if self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n            self.best_fitness_overall = objective_function(self.best_solution_overall.reshape(1,-1))[0]\n            self.eval_count += 1\n        else:\n            self.best_solution_overall = np.array([])\n            self.best_fitness_overall = 0.0\n\n\n        swarm = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.swarm_size, self.dim))\n        velocities = np.zeros((self.swarm_size, self.dim))\n        personal_bests = swarm.copy()\n        personal_best_fitness = np.array([objective_function(x.reshape(1,-1))[0] for x in swarm])\n        self.eval_count += self.swarm_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.swarm_size):\n                if personal_best_fitness[i] < self.best_fitness_overall:\n                    self.best_fitness_overall = personal_best_fitness[i]\n                    self.best_solution_overall = personal_bests[i].copy()\n\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            velocities = self.inertia_weight * velocities + self.cognitive_factor * r1 * (personal_bests - swarm) + self.social_factor * r2 * (self.best_solution_overall - swarm)\n            swarm = swarm + velocities\n            swarm = np.clip(swarm, self.lower_bounds, self.upper_bounds)\n\n            fitness_values = objective_function(swarm)\n            self.eval_count += self.swarm_size\n\n            for i in range(self.swarm_size):\n                if fitness_values[i] < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness_values[i]\n                    personal_bests[i] = swarm[i].copy()\n\n            # Adaptive Parameter Tuning\n            self.inertia_weight *= self.adaptive_factor\n            self.cognitive_factor *= self.adaptive_factor\n            self.social_factor *= self.adaptive_factor\n\n\n            # Local Search with Nelder-Mead\n            if self.eval_count < self.budget * 0.9: #only do local search if there's enough budget left.\n                res = minimize(objective_function, self.best_solution_overall, method='nelder-mead', options={'maxfev': int(self.budget * 0.1)})\n                if res.fun < self.best_fitness_overall and self.eval_count + res.nfev <= self.budget:\n                    self.best_fitness_overall = res.fun\n                    self.best_solution_overall = res.x\n                    self.eval_count += res.nfev\n\n            if self.eval_count >= self.budget:\n                break\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveHybridPSO_NelderMead got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00 with standard deviation 0.00.", "error": "", "parent_ids": ["7ae3b875-5878-40fa-a3f1-8aeee230b964"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}}
{"id": "5806951c-54f0-41af-99d5-d901b38c0a51", "fitness": 0.0, "name": "AdaptiveHybridPSONelderMead", "description": "Adaptive Hybrid PSO-Nelder Mead with dynamic swarm size and inertia weight adjustment based on convergence rate.", "code": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveHybridPSONelderMead:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n        self.swarm_size = int(np.ceil(self.dim * 5))  # Dynamic swarm size\n        self.inertia_weight = 0.7\n        self.cognitive_factor = 1.4\n        self.social_factor = 1.4\n        self.convergence_rate = 0.0\n        self.last_best_fitness = float('inf')\n\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n        self.best_fitness_overall = objective_function(self.best_solution_overall.reshape(1,-1))[0]\n        self.eval_count += 1\n        self.last_best_fitness = self.best_fitness_overall\n\n        swarm = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.swarm_size, self.dim))\n        velocities = np.zeros((self.swarm_size, self.dim))\n        personal_bests = swarm.copy()\n        personal_best_fitness = np.array([objective_function(x.reshape(1,-1))[0] for x in swarm])\n        self.eval_count += self.swarm_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.swarm_size):\n                if personal_best_fitness[i] < self.best_fitness_overall:\n                    self.best_fitness_overall = personal_best_fitness[i]\n                    self.best_solution_overall = personal_bests[i].copy()\n\n            # Adaptive adjustments\n            self.convergence_rate = (self.last_best_fitness - self.best_fitness_overall) / self.last_best_fitness if self.last_best_fitness !=0 else 1.0\n            self.last_best_fitness = self.best_fitness_overall\n            self.inertia_weight = 0.4 + 0.3 * np.exp(-5 * self.convergence_rate) #Adjust inertia weight based on convergence\n\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            velocities = self.inertia_weight * velocities + self.cognitive_factor * r1 * (personal_bests - swarm) + self.social_factor * r2 * (self.best_solution_overall - swarm)\n            swarm = swarm + velocities\n            swarm = np.clip(swarm, self.lower_bounds, self.upper_bounds)\n\n            fitness_values = objective_function(swarm)\n            self.eval_count += self.swarm_size\n\n            for i in range(self.swarm_size):\n                if fitness_values[i] < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness_values[i]\n                    personal_bests[i] = swarm[i].copy()\n\n            # Local Search with Nelder-Mead (adaptive iterations)\n            nelder_mead_iterations = min(100, int(self.budget - self.eval_count) // 10 ) # Adjust based on remaining budget\n            if nelder_mead_iterations > 0:\n                res = minimize(objective_function, self.best_solution_overall, method='nelder-mead', options={'maxfev': nelder_mead_iterations})\n                if res.fun < self.best_fitness_overall:\n                    self.best_fitness_overall = res.fun\n                    self.best_solution_overall = res.x\n                    self.eval_count += res.nfev\n\n            if self.eval_count >= self.budget:\n                break\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveHybridPSONelderMead got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00 with standard deviation 0.00.", "error": "", "parent_ids": ["7ae3b875-5878-40fa-a3f1-8aeee230b964"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}}
{"id": "15ce5280-1141-4256-97f3-4b493825c914", "fitness": 0.0, "name": "AdaptiveHybridPSO_NelderMead", "description": "Enhanced Hybrid PSO-NelderMead with adaptive inertia weight and population resizing for improved exploration-exploitation balance and efficiency.", "code": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveHybridPSO_NelderMead:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n        self.swarm_size = int(np.ceil(self.dim * 5))  # Dynamic swarm size\n        self.inertia_weight = 0.7\n        self.cognitive_factor = 1.4\n        self.social_factor = 1.4\n        self.adaptive_factor = 0.98 #Factor to decrease inertia weight\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        if self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n            self.best_fitness_overall = objective_function(self.best_solution_overall.reshape(1,-1))[0]\n            self.eval_count += 1\n        else:\n            self.best_solution_overall = np.array([])\n            self.best_fitness_overall = 0.0 #Handle 0 dimension case\n\n\n        swarm = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.swarm_size, self.dim))\n        velocities = np.zeros((self.swarm_size, self.dim))\n        personal_bests = swarm.copy()\n        personal_best_fitness = np.array([objective_function(x.reshape(1,-1))[0] for x in swarm])\n        self.eval_count += self.swarm_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.swarm_size):\n                if personal_best_fitness[i] < self.best_fitness_overall:\n                    self.best_fitness_overall = personal_best_fitness[i]\n                    self.best_solution_overall = personal_bests[i].copy()\n\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            velocities = self.inertia_weight * velocities + self.cognitive_factor * r1 * (personal_bests - swarm) + self.social_factor * r2 * (self.best_solution_overall - swarm)\n            swarm = swarm + velocities\n            swarm = np.clip(swarm, self.lower_bounds, self.upper_bounds)\n\n            fitness_values = objective_function(swarm)\n            self.eval_count += self.swarm_size\n\n            for i in range(self.swarm_size):\n                if fitness_values[i] < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness_values[i]\n                    personal_bests[i] = swarm[i].copy()\n\n            # Adaptive Inertia Weight\n            self.inertia_weight *= self.adaptive_factor\n\n            # Adaptive Swarm Size (increase if stuck)\n            if self.eval_count > self.budget * 0.7 and self.inertia_weight < 0.1 : #Avoid unnecessary increase at end\n                self.swarm_size = int(self.swarm_size * 1.5)\n                swarm = np.concatenate((swarm, np.random.uniform(self.lower_bounds, self.upper_bounds, (self.swarm_size - swarm.shape[0], self.dim))))\n                velocities = np.concatenate((velocities, np.zeros((self.swarm_size - velocities.shape[0], self.dim))))\n                personal_bests = np.concatenate((personal_bests, swarm[-self.swarm_size + swarm.shape[0]:]))\n                personal_best_fitness = np.concatenate((personal_best_fitness, [objective_function(x.reshape(1, -1))[0] for x in swarm[-self.swarm_size + swarm.shape[0]:]]))\n                self.eval_count += self.swarm_size - swarm.shape[0]\n\n\n            # Local Search with Nelder-Mead\n            res = minimize(objective_function, self.best_solution_overall, method='nelder-mead', options={'maxfev': int(100 + (self.budget - self.eval_count) * 0.2)}) #dynamic maxfev\n            if res.fun < self.best_fitness_overall and self.eval_count + res.nfev <= self.budget:\n                self.best_fitness_overall = res.fun\n                self.best_solution_overall = res.x\n                self.eval_count += res.nfev\n            if self.eval_count >= self.budget: break\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info\n", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveHybridPSO_NelderMead got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00 with standard deviation 0.00.", "error": "", "parent_ids": ["7ae3b875-5878-40fa-a3f1-8aeee230b964"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}}
{"id": "b6cfd90d-0300-4bb9-897c-39d7e70f0a7c", "fitness": 0.0, "name": "AdaptiveHybridPSO_NelderMead", "description": "Adaptive Hybrid PSO with Nelder-Mead local search, dynamically adjusting swarm size and inertia weight based on exploration-exploitation balance.", "code": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveHybridPSO_NelderMead:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n        self.swarm_size = int(np.ceil(self.dim * 5)) # Initial swarm size\n        self.inertia_weight = 0.7\n        self.cognitive_factor = 1.4\n        self.social_factor = 1.4\n        self.exploration_factor = 0.9 # Adjust exploration vs exploitation\n\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        if self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n            self.best_fitness_overall = objective_function(self.best_solution_overall.reshape(1,-1))[0]\n            self.eval_count += 1\n        else:\n            self.best_solution_overall = np.array([])\n            self.best_fitness_overall = 0.0\n\n\n        swarm = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.swarm_size, self.dim))\n        velocities = np.zeros((self.swarm_size, self.dim))\n        personal_bests = swarm.copy()\n        personal_best_fitness = np.array([objective_function(x.reshape(1,-1))[0] for x in swarm])\n        self.eval_count += self.swarm_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.swarm_size):\n                if personal_best_fitness[i] < self.best_fitness_overall:\n                    self.best_fitness_overall = personal_best_fitness[i]\n                    self.best_solution_overall = personal_bests[i].copy()\n\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            velocities = self.inertia_weight * velocities + self.cognitive_factor * r1 * (personal_bests - swarm) + self.social_factor * r2 * (self.best_solution_overall - swarm)\n            swarm = swarm + velocities\n            swarm = np.clip(swarm, self.lower_bounds, self.upper_bounds)\n\n            fitness_values = objective_function(swarm)\n            self.eval_count += self.swarm_size\n\n            for i in range(self.swarm_size):\n                if fitness_values[i] < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness_values[i]\n                    personal_bests[i] = swarm[i].copy()\n\n            # Adaptive adjustments\n            improvement_rate = (self.best_fitness_overall - np.mean(personal_best_fitness)) / self.best_fitness_overall if self.best_fitness_overall !=0 else 1.0\n            if improvement_rate < 0.1: # Needs more exploration\n                self.swarm_size = int(np.ceil(self.swarm_size * self.exploration_factor))\n                self.inertia_weight = max(0.4, self.inertia_weight * 0.9) # Increase inertia\n            else: # Needs more exploitation\n                self.swarm_size = int(np.ceil(self.swarm_size / self.exploration_factor))\n                self.inertia_weight = min(0.9, self.inertia_weight * 1.1) # Decrease inertia\n\n            self.swarm_size = max(1, min(self.swarm_size, self.budget - self.eval_count)) #Avoid exceeding budget\n\n            # Local Search with Nelder-Mead\n            if self.eval_count < self.budget:\n                res = minimize(objective_function, self.best_solution_overall, method='nelder-mead', options={'maxfev': min(100, self.budget - self.eval_count)})\n                if res.fun < self.best_fitness_overall:\n                    self.best_fitness_overall = res.fun\n                    self.best_solution_overall = res.x\n                    self.eval_count += res.nfev\n\n            if self.eval_count >= self.budget: break\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info\n", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveHybridPSO_NelderMead got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00 with standard deviation 0.00.", "error": "", "parent_ids": ["7ae3b875-5878-40fa-a3f1-8aeee230b964"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}}
{"id": "31c6aade-8460-45bb-b2bc-1c43178aa0d5", "fitness": 0.0, "name": "AdaptiveHybridPSONelderMead", "description": "Enhanced Hybrid PSO-NelderMead with adaptive inertia weight and improved Nelder-Mead integration for robust black-box optimization.", "code": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveHybridPSONelderMead:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n        self.swarm_size = int(np.ceil(self.dim * 5))  # Dynamic swarm size\n        self.inertia_weight = 0.7\n        self.cognitive_factor = 1.4\n        self.social_factor = 1.4\n        self.nelder_mead_budget_ratio = 0.2 #Allocate 20% of budget to Nelder-Mead\n\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        if self.dim > 0:\n            self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n            self.best_fitness_overall = objective_function(self.best_solution_overall.reshape(1,-1))[0]\n            self.eval_count += 1\n        else:\n            return np.array([]), float('inf'), {'function_evaluations_used': 0, 'final_best_fitness': float('inf')}\n\n\n        swarm = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.swarm_size, self.dim))\n        velocities = np.zeros((self.swarm_size, self.dim))\n        personal_bests = swarm.copy()\n        personal_best_fitness = np.array([objective_function(x.reshape(1,-1))[0] for x in swarm])\n        self.eval_count += self.swarm_size\n\n        nelder_mead_budget = int(self.budget * self.nelder_mead_budget_ratio)\n        \n        while self.eval_count < self.budget:\n            for i in range(self.swarm_size):\n                if personal_best_fitness[i] < self.best_fitness_overall:\n                    self.best_fitness_overall = personal_best_fitness[i]\n                    self.best_solution_overall = personal_bests[i].copy()\n\n            #Adaptive Inertia Weight\n            self.inertia_weight = 0.4 + 0.3 * np.exp(-self.eval_count / self.budget)\n\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            velocities = self.inertia_weight * velocities + self.cognitive_factor * r1 * (personal_bests - swarm) + self.social_factor * r2 * (self.best_solution_overall - swarm)\n            swarm = swarm + velocities\n            swarm = np.clip(swarm, self.lower_bounds, self.upper_bounds)\n\n            fitness_values = objective_function(swarm)\n            self.eval_count += self.swarm_size\n\n            for i in range(self.swarm_size):\n                if fitness_values[i] < personal_best_fitness[i]:\n                    personal_best_fitness[i] = fitness_values[i]\n                    personal_bests[i] = swarm[i].copy()\n\n            # More frequent and adaptive Nelder-Mead application\n            if self.eval_count % (self.budget // 10) == 0 and self.eval_count < self.budget - nelder_mead_budget: #Apply Nelder-Mead every 10% of budget\n                res = minimize(objective_function, self.best_solution_overall, method='nelder-mead', options={'maxfev': min(nelder_mead_budget, self.budget-self.eval_count)})\n                if res.fun < self.best_fitness_overall:\n                    self.best_fitness_overall = res.fun\n                    self.best_solution_overall = res.x\n                    self.eval_count += res.nfev\n\n            if self.eval_count >= self.budget:\n                break\n\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info\n", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveHybridPSONelderMead got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00 with standard deviation 0.00.", "error": "", "parent_ids": ["7ae3b875-5878-40fa-a3f1-8aeee230b964"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}}
{"id": "afdd7366-611e-4904-8958-9d1b9e18d4e0", "fitness": 0.0, "name": "AdaptiveHybridPSONelderMead", "description": "Adaptive Hybrid PSO-Nelder Mead with dynamic swarm size and adaptive inertia weight, employing a multi-start strategy and improved local search triggering.", "code": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveHybridPSONelderMead:\n    def __init__(self, budget: int, dim: int, lower_bounds: list[float], upper_bounds: list[float]):\n        self.budget = int(budget)\n        self.dim = int(dim)\n        self.lower_bounds = np.array(lower_bounds, dtype=float)\n        self.upper_bounds = np.array(upper_bounds, dtype=float)\n\n        self.eval_count = 0\n        self.best_solution_overall = None\n        self.best_fitness_overall = float('inf')\n        self.swarm_size = int(np.ceil(self.dim * 5))  # Dynamic swarm size\n        self.max_swarm_size = int(np.ceil(self.dim * 10)) # Maximum swarm size\n        self.min_swarm_size = int(np.ceil(self.dim * 2)) # Minimum swarm size\n\n\n    def optimize(self, objective_function: callable, acceptance_threshold: float = 1e-8) -> tuple:\n        self.eval_count = 0\n        self.best_solution_overall = np.random.uniform(self.lower_bounds, self.upper_bounds, self.dim)\n        self.best_fitness_overall = objective_function(self.best_solution_overall.reshape(1,-1))[0]\n        self.eval_count += 1\n\n        num_restarts = 5 #Number of restarts\n\n        for restart in range(num_restarts):\n            swarm = np.random.uniform(self.lower_bounds, self.upper_bounds, (self.swarm_size, self.dim))\n            velocities = np.zeros((self.swarm_size, self.dim))\n            personal_bests = swarm.copy()\n            personal_best_fitness = np.array([objective_function(x.reshape(1,-1))[0] for x in swarm])\n            self.eval_count += self.swarm_size\n\n            inertia_weight = 0.7 # Initial inertia weight\n            while self.eval_count < self.budget:\n                for i in range(self.swarm_size):\n                    if personal_best_fitness[i] < self.best_fitness_overall:\n                        self.best_fitness_overall = personal_best_fitness[i]\n                        self.best_solution_overall = personal_bests[i].copy()\n\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities = inertia_weight * velocities + 1.4 * r1 * (personal_bests - swarm) + 1.4 * r2 * (self.best_solution_overall - swarm)\n                swarm = swarm + velocities\n                swarm = np.clip(swarm, self.lower_bounds, self.upper_bounds)\n\n                fitness_values = objective_function(swarm)\n                self.eval_count += self.swarm_size\n\n                for i in range(self.swarm_size):\n                    if fitness_values[i] < personal_best_fitness[i]:\n                        personal_best_fitness[i] = fitness_values[i]\n                        personal_bests[i] = swarm[i].copy()\n\n                #Adaptive Swarm Size\n                if np.mean(personal_best_fitness) < self.best_fitness_overall * 0.9 :\n                    self.swarm_size = min(self.swarm_size * 2, self.max_swarm_size)\n                elif np.mean(personal_best_fitness) > self.best_fitness_overall * 1.1 :\n                    self.swarm_size = max(self.swarm_size // 2, self.min_swarm_size)\n\n\n                #Adaptive Inertia Weight\n                inertia_weight = 0.4 + 0.3 * np.exp(-self.eval_count / self.budget)\n\n                # Local Search with Nelder-Mead (triggered more strategically)\n                if self.eval_count < 0.8 * self.budget and self.eval_count % (self.swarm_size * 2) == 0: #Trigger Local search every other iteration\n                    res = minimize(objective_function, self.best_solution_overall, method='nelder-mead', options={'maxfev': int(0.02 * self.budget)}) #Reduced maxfev for better efficiency\n                    if res.fun < self.best_fitness_overall and self.eval_count + res.nfev <= self.budget:\n                        self.best_fitness_overall = res.fun\n                        self.best_solution_overall = res.x\n                        self.eval_count += res.nfev\n\n                if self.eval_count >= self.budget:\n                    break\n\n        optimization_info = {\n            'function_evaluations_used': self.eval_count,\n            'final_best_fitness': self.best_fitness_overall\n        }\n        return self.best_solution_overall, self.best_fitness_overall, optimization_info", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveHybridPSONelderMead got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00 with standard deviation 0.00.", "error": "", "parent_ids": ["7ae3b875-5878-40fa-a3f1-8aeee230b964"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}}
